// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mpmsg.proto

#ifndef PROTOBUF_mpmsg_2eproto__INCLUDED
#define PROTOBUF_mpmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mpcomm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mpmsg_2eproto();
void protobuf_AssignDesc_mpmsg_2eproto();
void protobuf_ShutdownFile_mpmsg_2eproto();

class TestMessage;
class TokenReq;
class TokenResp;
class GetCallbackIPReq;
class GetCallbackIPResp;
class MenuButton;
class MenuMatchRule;
class Menu;
class CreateMenuReq;
class CreateMenuResp;
class GetMenuReq;
class GetMenuResp;
class DeleteMenuReq;
class DeleteMenuResp;
class AddConditionalMenuReq;
class AddConditionalMenuResp;
class DelConditionalMenuReq;
class DelConditionalMenuResp;
class TryMatchMenuReq;
class TryMatchMenuResp;
class GetCurrentSelfMenuInfoReq;
class RespNews;
class RespNewsList;
class CurrentSelfMenuButton;
class CurrentSelfMenuButtonList;
class CurrentSelfMenu;
class GetCurrentSelfMenuInfoResp;
class ReplyItem;
class KeyWordItem;
class AutoReplyRule;
class AutoReplyRuleList;
class GetCurrentAutoReplyInfoReq;
class GetCurrentAutoReplyInfoResp;
class Text;
class Image;
class Voice;
class Video;
class Link;
class Card;
class ArticlesItem;
class NewsMsg;
class Music;
class MpNewsMsg;
class MpVideo;
class WxCard;
class CustomServiceInfo;
class SendCustomMessageReq;
class SendCustomMessageResp;
class SendFilter;
class MassSendAllReq;
class MassSendAllResp;
class MassSendReq;
class MassSendResp;
class MassDeleteReq;
class MassDeleteResp;
class MassPreviewReq;
class MassPreviewResp;
class MassGetReq;
class MassGetResp;
class SetIndustryReq;
class SetIndustryResp;
class GetIndustryReq;
class Industry;
class GetIndustryResp;
class AddTemplateReq;
class AddTemplateResp;
class GetAllPrivateTemplateReq;
class PrivateTemplate;
class GetAllPrivateTemplateResp;
class DelPrivateTemplateReq;
class DelPrivateTemplateResp;
class Json;
class SendTemplateMessageReq;
class SendTemplateMessageResp;
class MediaFile;
class NewsItem;
class NewsInfo;
class UploadImgReq;
class UploadImgResp;
class UploadNewsReq;
class UploadNewsResp;
class UploadMediaReq;
class UploadMediaResp;
class GetMediaReq;
class GetMediaResp;
class MaterialVideoDescription;
class AddNewsMaterialReq;
class AddNewsMaterialResp;
class AddMaterialReq;
class AddMaterialResp;
class GetMaterialReq;
class GetMaterialResp;
class DelMaterialReq;
class DelMaterialResp;
class UpdateNewsReq;
class UpdateNewsResp;
class GetMaterialCountReq;
class GetMaterialCountResp;
class BatchGetMaterialReq;
class MaterialItem;
class BatchGetMaterialResp;
class Tag;
class CreateTagsReq;
class CreateTagsResp;
class GetTagsReq;
class GetTagsResp;
class UpdateTagsReq;
class UpdateTagsResp;
class UpdateTagsMembersReq;
class UpdateTagsMembersResp;
class BatchUpdateTagsMembersReq;
class BatchUpdateTagsMembersResp;
class DeleteTagsReq;
class DeleteTagsResp;
class TagUserData;
class GetTagUserReq;
class GetTagUserResp;
class BatchTaggingMembersReq;
class BatchTaggingMembersResp;
class BatchUnTaggingMembersReq;
class BatchUnTaggingMembersResp;
class GetTagsIdListReq;
class GetTagsIdListResp;
class UpdateUserInfoRemarkReq;
class UpdateUserInfoRemarkResp;
class UserInfoReq;
class UserInfoResp;
class BatchGetUserItem;
class BatchGetUserInfoReq;
class UserInfoItem;
class BatchGetUserInfoResp;
class GetUserReq;
class UserList;
class GetUserResp;

// ===================================================================

class TestMessage : public ::google::protobuf::Message {
 public:
  TestMessage();
  virtual ~TestMessage();

  TestMessage(const TestMessage& from);

  inline TestMessage& operator=(const TestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestMessage& default_instance();

  void Swap(TestMessage* other);

  // implements Message ----------------------------------------------

  TestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestMessage& from);
  void MergeFrom(const TestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 field1 = 1;
  inline bool has_field1() const;
  inline void clear_field1();
  static const int kField1FieldNumber = 1;
  inline ::google::protobuf::int64 field1() const;
  inline void set_field1(::google::protobuf::int64 value);

  // optional uint64 field2 = 2;
  inline bool has_field2() const;
  inline void clear_field2();
  static const int kField2FieldNumber = 2;
  inline ::google::protobuf::uint64 field2() const;
  inline void set_field2(::google::protobuf::uint64 value);

  // optional string field3 = 3;
  inline bool has_field3() const;
  inline void clear_field3();
  static const int kField3FieldNumber = 3;
  inline const ::std::string& field3() const;
  inline void set_field3(const ::std::string& value);
  inline void set_field3(const char* value);
  inline void set_field3(const char* value, size_t size);
  inline ::std::string* mutable_field3();
  inline ::std::string* release_field3();
  inline void set_allocated_field3(::std::string* field3);

  // optional string field4 = 4;
  inline bool has_field4() const;
  inline void clear_field4();
  static const int kField4FieldNumber = 4;
  inline const ::std::string& field4() const;
  inline void set_field4(const ::std::string& value);
  inline void set_field4(const char* value);
  inline void set_field4(const char* value, size_t size);
  inline ::std::string* mutable_field4();
  inline ::std::string* release_field4();
  inline void set_allocated_field4(::std::string* field4);

  // optional .mpcomm.TestMessage field5 = 5;
  inline bool has_field5() const;
  inline void clear_field5();
  static const int kField5FieldNumber = 5;
  inline const ::mpcomm::TestMessage& field5() const;
  inline ::mpcomm::TestMessage* mutable_field5();
  inline ::mpcomm::TestMessage* release_field5();
  inline void set_allocated_field5(::mpcomm::TestMessage* field5);

  // @@protoc_insertion_point(class_scope:mpcomm.TestMessage)
 private:
  inline void set_has_field1();
  inline void clear_has_field1();
  inline void set_has_field2();
  inline void clear_has_field2();
  inline void set_has_field3();
  inline void clear_has_field3();
  inline void set_has_field4();
  inline void clear_has_field4();
  inline void set_has_field5();
  inline void clear_has_field5();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 field1_;
  ::google::protobuf::uint64 field2_;
  ::std::string* field3_;
  ::std::string* field4_;
  ::mpcomm::TestMessage* field5_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static TestMessage* default_instance_;
};
// -------------------------------------------------------------------

class TokenReq : public ::google::protobuf::Message {
 public:
  TokenReq();
  virtual ~TokenReq();

  TokenReq(const TokenReq& from);

  inline TokenReq& operator=(const TokenReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TokenReq& default_instance();

  void Swap(TokenReq* other);

  // implements Message ----------------------------------------------

  TokenReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TokenReq& from);
  void MergeFrom(const TokenReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string grant_type = 1 [default = "client_credential"];
  inline bool has_grant_type() const;
  inline void clear_grant_type();
  static const int kGrantTypeFieldNumber = 1;
  inline const ::std::string& grant_type() const;
  inline void set_grant_type(const ::std::string& value);
  inline void set_grant_type(const char* value);
  inline void set_grant_type(const char* value, size_t size);
  inline ::std::string* mutable_grant_type();
  inline ::std::string* release_grant_type();
  inline void set_allocated_grant_type(::std::string* grant_type);

  // optional string appid = 2;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 2;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  inline void set_allocated_appid(::std::string* appid);

  // optional string secret = 3;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 3;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const char* value, size_t size);
  inline ::std::string* mutable_secret();
  inline ::std::string* release_secret();
  inline void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:mpcomm.TokenReq)
 private:
  inline void set_has_grant_type();
  inline void clear_has_grant_type();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_secret();
  inline void clear_has_secret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  static ::std::string* _default_grant_type_;
  ::std::string* grant_type_;
  ::std::string* appid_;
  ::std::string* secret_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static TokenReq* default_instance_;
};
// -------------------------------------------------------------------

class TokenResp : public ::google::protobuf::Message {
 public:
  TokenResp();
  virtual ~TokenResp();

  TokenResp(const TokenResp& from);

  inline TokenResp& operator=(const TokenResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TokenResp& default_instance();

  void Swap(TokenResp* other);

  // implements Message ----------------------------------------------

  TokenResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TokenResp& from);
  void MergeFrom(const TokenResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional string access_token = 3;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 3;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional uint64 expires_in = 4;
  inline bool has_expires_in() const;
  inline void clear_expires_in();
  static const int kExpiresInFieldNumber = 4;
  inline ::google::protobuf::uint64 expires_in() const;
  inline void set_expires_in(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.TokenResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_expires_in();
  inline void clear_has_expires_in();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::std::string* access_token_;
  ::google::protobuf::uint64 expires_in_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static TokenResp* default_instance_;
};
// -------------------------------------------------------------------

class GetCallbackIPReq : public ::google::protobuf::Message {
 public:
  GetCallbackIPReq();
  virtual ~GetCallbackIPReq();

  GetCallbackIPReq(const GetCallbackIPReq& from);

  inline GetCallbackIPReq& operator=(const GetCallbackIPReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCallbackIPReq& default_instance();

  void Swap(GetCallbackIPReq* other);

  // implements Message ----------------------------------------------

  GetCallbackIPReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCallbackIPReq& from);
  void MergeFrom(const GetCallbackIPReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:mpcomm.GetCallbackIPReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetCallbackIPReq* default_instance_;
};
// -------------------------------------------------------------------

class GetCallbackIPResp : public ::google::protobuf::Message {
 public:
  GetCallbackIPResp();
  virtual ~GetCallbackIPResp();

  GetCallbackIPResp(const GetCallbackIPResp& from);

  inline GetCallbackIPResp& operator=(const GetCallbackIPResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCallbackIPResp& default_instance();

  void Swap(GetCallbackIPResp* other);

  // implements Message ----------------------------------------------

  GetCallbackIPResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCallbackIPResp& from);
  void MergeFrom(const GetCallbackIPResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // repeated string ip_list = 3;
  inline int ip_list_size() const;
  inline void clear_ip_list();
  static const int kIpListFieldNumber = 3;
  inline const ::std::string& ip_list(int index) const;
  inline ::std::string* mutable_ip_list(int index);
  inline void set_ip_list(int index, const ::std::string& value);
  inline void set_ip_list(int index, const char* value);
  inline void set_ip_list(int index, const char* value, size_t size);
  inline ::std::string* add_ip_list();
  inline void add_ip_list(const ::std::string& value);
  inline void add_ip_list(const char* value);
  inline void add_ip_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ip_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ip_list();

  // @@protoc_insertion_point(class_scope:mpcomm.GetCallbackIPResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ip_list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetCallbackIPResp* default_instance_;
};
// -------------------------------------------------------------------

class MenuButton : public ::google::protobuf::Message {
 public:
  MenuButton();
  virtual ~MenuButton();

  MenuButton(const MenuButton& from);

  inline MenuButton& operator=(const MenuButton& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MenuButton& default_instance();

  void Swap(MenuButton* other);

  // implements Message ----------------------------------------------

  MenuButton* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MenuButton& from);
  void MergeFrom(const MenuButton& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string url = 4;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 4;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // repeated .mpcomm.MenuButton sub_button = 5;
  inline int sub_button_size() const;
  inline void clear_sub_button();
  static const int kSubButtonFieldNumber = 5;
  inline const ::mpcomm::MenuButton& sub_button(int index) const;
  inline ::mpcomm::MenuButton* mutable_sub_button(int index);
  inline ::mpcomm::MenuButton* add_sub_button();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
      sub_button() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
      mutable_sub_button();

  // optional string media_id = 6;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 6;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.MenuButton)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_media_id();
  inline void clear_has_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* name_;
  ::std::string* key_;
  ::std::string* url_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton > sub_button_;
  ::std::string* media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MenuButton* default_instance_;
};
// -------------------------------------------------------------------

class MenuMatchRule : public ::google::protobuf::Message {
 public:
  MenuMatchRule();
  virtual ~MenuMatchRule();

  MenuMatchRule(const MenuMatchRule& from);

  inline MenuMatchRule& operator=(const MenuMatchRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MenuMatchRule& default_instance();

  void Swap(MenuMatchRule* other);

  // implements Message ----------------------------------------------

  MenuMatchRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MenuMatchRule& from);
  void MergeFrom(const MenuMatchRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tag_id = 1;
  inline bool has_tag_id() const;
  inline void clear_tag_id();
  static const int kTagIdFieldNumber = 1;
  inline const ::std::string& tag_id() const;
  inline void set_tag_id(const ::std::string& value);
  inline void set_tag_id(const char* value);
  inline void set_tag_id(const char* value, size_t size);
  inline ::std::string* mutable_tag_id();
  inline ::std::string* release_tag_id();
  inline void set_allocated_tag_id(::std::string* tag_id);

  // optional string group_id = 8;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 8;
  inline const ::std::string& group_id() const;
  inline void set_group_id(const ::std::string& value);
  inline void set_group_id(const char* value);
  inline void set_group_id(const char* value, size_t size);
  inline ::std::string* mutable_group_id();
  inline ::std::string* release_group_id();
  inline void set_allocated_group_id(::std::string* group_id);

  // optional string sex = 2;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 2;
  inline const ::std::string& sex() const;
  inline void set_sex(const ::std::string& value);
  inline void set_sex(const char* value);
  inline void set_sex(const char* value, size_t size);
  inline ::std::string* mutable_sex();
  inline ::std::string* release_sex();
  inline void set_allocated_sex(::std::string* sex);

  // optional string client_platform_type = 3;
  inline bool has_client_platform_type() const;
  inline void clear_client_platform_type();
  static const int kClientPlatformTypeFieldNumber = 3;
  inline const ::std::string& client_platform_type() const;
  inline void set_client_platform_type(const ::std::string& value);
  inline void set_client_platform_type(const char* value);
  inline void set_client_platform_type(const char* value, size_t size);
  inline ::std::string* mutable_client_platform_type();
  inline ::std::string* release_client_platform_type();
  inline void set_allocated_client_platform_type(::std::string* client_platform_type);

  // optional string country = 4;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 4;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string province = 5;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 5;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const char* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  inline void set_allocated_province(::std::string* province);

  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string language = 7;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 7;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:mpcomm.MenuMatchRule)
 private:
  inline void set_has_tag_id();
  inline void clear_has_tag_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_client_platform_type();
  inline void clear_has_client_platform_type();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_language();
  inline void clear_has_language();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tag_id_;
  ::std::string* group_id_;
  ::std::string* sex_;
  ::std::string* client_platform_type_;
  ::std::string* country_;
  ::std::string* province_;
  ::std::string* city_;
  ::std::string* language_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MenuMatchRule* default_instance_;
};
// -------------------------------------------------------------------

class Menu : public ::google::protobuf::Message {
 public:
  Menu();
  virtual ~Menu();

  Menu(const Menu& from);

  inline Menu& operator=(const Menu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Menu& default_instance();

  void Swap(Menu* other);

  // implements Message ----------------------------------------------

  Menu* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Menu& from);
  void MergeFrom(const Menu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpcomm.MenuButton button = 1;
  inline int button_size() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 1;
  inline const ::mpcomm::MenuButton& button(int index) const;
  inline ::mpcomm::MenuButton* mutable_button(int index);
  inline ::mpcomm::MenuButton* add_button();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
      button() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
      mutable_button();

  // optional .mpcomm.MenuMatchRule matchrule = 2;
  inline bool has_matchrule() const;
  inline void clear_matchrule();
  static const int kMatchruleFieldNumber = 2;
  inline const ::mpcomm::MenuMatchRule& matchrule() const;
  inline ::mpcomm::MenuMatchRule* mutable_matchrule();
  inline ::mpcomm::MenuMatchRule* release_matchrule();
  inline void set_allocated_matchrule(::mpcomm::MenuMatchRule* matchrule);

  // optional uint64 menuid = 3;
  inline bool has_menuid() const;
  inline void clear_menuid();
  static const int kMenuidFieldNumber = 3;
  inline ::google::protobuf::uint64 menuid() const;
  inline void set_menuid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.Menu)
 private:
  inline void set_has_matchrule();
  inline void clear_has_matchrule();
  inline void set_has_menuid();
  inline void clear_has_menuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton > button_;
  ::mpcomm::MenuMatchRule* matchrule_;
  ::google::protobuf::uint64 menuid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Menu* default_instance_;
};
// -------------------------------------------------------------------

class CreateMenuReq : public ::google::protobuf::Message {
 public:
  CreateMenuReq();
  virtual ~CreateMenuReq();

  CreateMenuReq(const CreateMenuReq& from);

  inline CreateMenuReq& operator=(const CreateMenuReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateMenuReq& default_instance();

  void Swap(CreateMenuReq* other);

  // implements Message ----------------------------------------------

  CreateMenuReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateMenuReq& from);
  void MergeFrom(const CreateMenuReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // repeated .mpcomm.MenuButton button = 2;
  inline int button_size() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 2;
  inline const ::mpcomm::MenuButton& button(int index) const;
  inline ::mpcomm::MenuButton* mutable_button(int index);
  inline ::mpcomm::MenuButton* add_button();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
      button() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
      mutable_button();

  // @@protoc_insertion_point(class_scope:mpcomm.CreateMenuReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton > button_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static CreateMenuReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateMenuResp : public ::google::protobuf::Message {
 public:
  CreateMenuResp();
  virtual ~CreateMenuResp();

  CreateMenuResp(const CreateMenuResp& from);

  inline CreateMenuResp& operator=(const CreateMenuResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateMenuResp& default_instance();

  void Swap(CreateMenuResp* other);

  // implements Message ----------------------------------------------

  CreateMenuResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateMenuResp& from);
  void MergeFrom(const CreateMenuResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.CreateMenuResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static CreateMenuResp* default_instance_;
};
// -------------------------------------------------------------------

class GetMenuReq : public ::google::protobuf::Message {
 public:
  GetMenuReq();
  virtual ~GetMenuReq();

  GetMenuReq(const GetMenuReq& from);

  inline GetMenuReq& operator=(const GetMenuReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMenuReq& default_instance();

  void Swap(GetMenuReq* other);

  // implements Message ----------------------------------------------

  GetMenuReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMenuReq& from);
  void MergeFrom(const GetMenuReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:mpcomm.GetMenuReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetMenuReq* default_instance_;
};
// -------------------------------------------------------------------

class GetMenuResp : public ::google::protobuf::Message {
 public:
  GetMenuResp();
  virtual ~GetMenuResp();

  GetMenuResp(const GetMenuResp& from);

  inline GetMenuResp& operator=(const GetMenuResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMenuResp& default_instance();

  void Swap(GetMenuResp* other);

  // implements Message ----------------------------------------------

  GetMenuResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMenuResp& from);
  void MergeFrom(const GetMenuResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional .mpcomm.Menu menu = 3;
  inline bool has_menu() const;
  inline void clear_menu();
  static const int kMenuFieldNumber = 3;
  inline const ::mpcomm::Menu& menu() const;
  inline ::mpcomm::Menu* mutable_menu();
  inline ::mpcomm::Menu* release_menu();
  inline void set_allocated_menu(::mpcomm::Menu* menu);

  // repeated .mpcomm.Menu conditionalmenu = 4;
  inline int conditionalmenu_size() const;
  inline void clear_conditionalmenu();
  static const int kConditionalmenuFieldNumber = 4;
  inline const ::mpcomm::Menu& conditionalmenu(int index) const;
  inline ::mpcomm::Menu* mutable_conditionalmenu(int index);
  inline ::mpcomm::Menu* add_conditionalmenu();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::Menu >&
      conditionalmenu() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::Menu >*
      mutable_conditionalmenu();

  // @@protoc_insertion_point(class_scope:mpcomm.GetMenuResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_menu();
  inline void clear_has_menu();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::mpcomm::Menu* menu_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::Menu > conditionalmenu_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetMenuResp* default_instance_;
};
// -------------------------------------------------------------------

class DeleteMenuReq : public ::google::protobuf::Message {
 public:
  DeleteMenuReq();
  virtual ~DeleteMenuReq();

  DeleteMenuReq(const DeleteMenuReq& from);

  inline DeleteMenuReq& operator=(const DeleteMenuReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteMenuReq& default_instance();

  void Swap(DeleteMenuReq* other);

  // implements Message ----------------------------------------------

  DeleteMenuReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteMenuReq& from);
  void MergeFrom(const DeleteMenuReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:mpcomm.DeleteMenuReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DeleteMenuReq* default_instance_;
};
// -------------------------------------------------------------------

class DeleteMenuResp : public ::google::protobuf::Message {
 public:
  DeleteMenuResp();
  virtual ~DeleteMenuResp();

  DeleteMenuResp(const DeleteMenuResp& from);

  inline DeleteMenuResp& operator=(const DeleteMenuResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteMenuResp& default_instance();

  void Swap(DeleteMenuResp* other);

  // implements Message ----------------------------------------------

  DeleteMenuResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteMenuResp& from);
  void MergeFrom(const DeleteMenuResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.DeleteMenuResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DeleteMenuResp* default_instance_;
};
// -------------------------------------------------------------------

class AddConditionalMenuReq : public ::google::protobuf::Message {
 public:
  AddConditionalMenuReq();
  virtual ~AddConditionalMenuReq();

  AddConditionalMenuReq(const AddConditionalMenuReq& from);

  inline AddConditionalMenuReq& operator=(const AddConditionalMenuReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddConditionalMenuReq& default_instance();

  void Swap(AddConditionalMenuReq* other);

  // implements Message ----------------------------------------------

  AddConditionalMenuReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddConditionalMenuReq& from);
  void MergeFrom(const AddConditionalMenuReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // repeated .mpcomm.MenuButton button = 2;
  inline int button_size() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 2;
  inline const ::mpcomm::MenuButton& button(int index) const;
  inline ::mpcomm::MenuButton* mutable_button(int index);
  inline ::mpcomm::MenuButton* add_button();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
      button() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
      mutable_button();

  // optional .mpcomm.MenuMatchRule matchrule = 3;
  inline bool has_matchrule() const;
  inline void clear_matchrule();
  static const int kMatchruleFieldNumber = 3;
  inline const ::mpcomm::MenuMatchRule& matchrule() const;
  inline ::mpcomm::MenuMatchRule* mutable_matchrule();
  inline ::mpcomm::MenuMatchRule* release_matchrule();
  inline void set_allocated_matchrule(::mpcomm::MenuMatchRule* matchrule);

  // @@protoc_insertion_point(class_scope:mpcomm.AddConditionalMenuReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_matchrule();
  inline void clear_has_matchrule();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton > button_;
  ::mpcomm::MenuMatchRule* matchrule_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AddConditionalMenuReq* default_instance_;
};
// -------------------------------------------------------------------

class AddConditionalMenuResp : public ::google::protobuf::Message {
 public:
  AddConditionalMenuResp();
  virtual ~AddConditionalMenuResp();

  AddConditionalMenuResp(const AddConditionalMenuResp& from);

  inline AddConditionalMenuResp& operator=(const AddConditionalMenuResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddConditionalMenuResp& default_instance();

  void Swap(AddConditionalMenuResp* other);

  // implements Message ----------------------------------------------

  AddConditionalMenuResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddConditionalMenuResp& from);
  void MergeFrom(const AddConditionalMenuResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 menuid = 3;
  inline bool has_menuid() const;
  inline void clear_menuid();
  static const int kMenuidFieldNumber = 3;
  inline ::google::protobuf::uint64 menuid() const;
  inline void set_menuid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.AddConditionalMenuResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_menuid();
  inline void clear_has_menuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 menuid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AddConditionalMenuResp* default_instance_;
};
// -------------------------------------------------------------------

class DelConditionalMenuReq : public ::google::protobuf::Message {
 public:
  DelConditionalMenuReq();
  virtual ~DelConditionalMenuReq();

  DelConditionalMenuReq(const DelConditionalMenuReq& from);

  inline DelConditionalMenuReq& operator=(const DelConditionalMenuReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelConditionalMenuReq& default_instance();

  void Swap(DelConditionalMenuReq* other);

  // implements Message ----------------------------------------------

  DelConditionalMenuReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelConditionalMenuReq& from);
  void MergeFrom(const DelConditionalMenuReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional uint64 menuid = 2;
  inline bool has_menuid() const;
  inline void clear_menuid();
  static const int kMenuidFieldNumber = 2;
  inline ::google::protobuf::uint64 menuid() const;
  inline void set_menuid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.DelConditionalMenuReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_menuid();
  inline void clear_has_menuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::uint64 menuid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DelConditionalMenuReq* default_instance_;
};
// -------------------------------------------------------------------

class DelConditionalMenuResp : public ::google::protobuf::Message {
 public:
  DelConditionalMenuResp();
  virtual ~DelConditionalMenuResp();

  DelConditionalMenuResp(const DelConditionalMenuResp& from);

  inline DelConditionalMenuResp& operator=(const DelConditionalMenuResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelConditionalMenuResp& default_instance();

  void Swap(DelConditionalMenuResp* other);

  // implements Message ----------------------------------------------

  DelConditionalMenuResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelConditionalMenuResp& from);
  void MergeFrom(const DelConditionalMenuResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.DelConditionalMenuResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DelConditionalMenuResp* default_instance_;
};
// -------------------------------------------------------------------

class TryMatchMenuReq : public ::google::protobuf::Message {
 public:
  TryMatchMenuReq();
  virtual ~TryMatchMenuReq();

  TryMatchMenuReq(const TryMatchMenuReq& from);

  inline TryMatchMenuReq& operator=(const TryMatchMenuReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TryMatchMenuReq& default_instance();

  void Swap(TryMatchMenuReq* other);

  // implements Message ----------------------------------------------

  TryMatchMenuReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TryMatchMenuReq& from);
  void MergeFrom(const TryMatchMenuReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:mpcomm.TryMatchMenuReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* user_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static TryMatchMenuReq* default_instance_;
};
// -------------------------------------------------------------------

class TryMatchMenuResp : public ::google::protobuf::Message {
 public:
  TryMatchMenuResp();
  virtual ~TryMatchMenuResp();

  TryMatchMenuResp(const TryMatchMenuResp& from);

  inline TryMatchMenuResp& operator=(const TryMatchMenuResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TryMatchMenuResp& default_instance();

  void Swap(TryMatchMenuResp* other);

  // implements Message ----------------------------------------------

  TryMatchMenuResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TryMatchMenuResp& from);
  void MergeFrom(const TryMatchMenuResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // repeated .mpcomm.MenuButton button = 3;
  inline int button_size() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 3;
  inline const ::mpcomm::MenuButton& button(int index) const;
  inline ::mpcomm::MenuButton* mutable_button(int index);
  inline ::mpcomm::MenuButton* add_button();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
      button() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
      mutable_button();

  // @@protoc_insertion_point(class_scope:mpcomm.TryMatchMenuResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton > button_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static TryMatchMenuResp* default_instance_;
};
// -------------------------------------------------------------------

class GetCurrentSelfMenuInfoReq : public ::google::protobuf::Message {
 public:
  GetCurrentSelfMenuInfoReq();
  virtual ~GetCurrentSelfMenuInfoReq();

  GetCurrentSelfMenuInfoReq(const GetCurrentSelfMenuInfoReq& from);

  inline GetCurrentSelfMenuInfoReq& operator=(const GetCurrentSelfMenuInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCurrentSelfMenuInfoReq& default_instance();

  void Swap(GetCurrentSelfMenuInfoReq* other);

  // implements Message ----------------------------------------------

  GetCurrentSelfMenuInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCurrentSelfMenuInfoReq& from);
  void MergeFrom(const GetCurrentSelfMenuInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:mpcomm.GetCurrentSelfMenuInfoReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetCurrentSelfMenuInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class RespNews : public ::google::protobuf::Message {
 public:
  RespNews();
  virtual ~RespNews();

  RespNews(const RespNews& from);

  inline RespNews& operator=(const RespNews& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespNews& default_instance();

  void Swap(RespNews* other);

  // implements Message ----------------------------------------------

  RespNews* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespNews& from);
  void MergeFrom(const RespNews& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string author = 2;
  inline bool has_author() const;
  inline void clear_author();
  static const int kAuthorFieldNumber = 2;
  inline const ::std::string& author() const;
  inline void set_author(const ::std::string& value);
  inline void set_author(const char* value);
  inline void set_author(const char* value, size_t size);
  inline ::std::string* mutable_author();
  inline ::std::string* release_author();
  inline void set_allocated_author(::std::string* author);

  // optional string digest = 3;
  inline bool has_digest() const;
  inline void clear_digest();
  static const int kDigestFieldNumber = 3;
  inline const ::std::string& digest() const;
  inline void set_digest(const ::std::string& value);
  inline void set_digest(const char* value);
  inline void set_digest(const char* value, size_t size);
  inline ::std::string* mutable_digest();
  inline ::std::string* release_digest();
  inline void set_allocated_digest(::std::string* digest);

  // optional uint64 show_cover = 4;
  inline bool has_show_cover() const;
  inline void clear_show_cover();
  static const int kShowCoverFieldNumber = 4;
  inline ::google::protobuf::uint64 show_cover() const;
  inline void set_show_cover(::google::protobuf::uint64 value);

  // optional string cover_url = 5;
  inline bool has_cover_url() const;
  inline void clear_cover_url();
  static const int kCoverUrlFieldNumber = 5;
  inline const ::std::string& cover_url() const;
  inline void set_cover_url(const ::std::string& value);
  inline void set_cover_url(const char* value);
  inline void set_cover_url(const char* value, size_t size);
  inline ::std::string* mutable_cover_url();
  inline ::std::string* release_cover_url();
  inline void set_allocated_cover_url(::std::string* cover_url);

  // optional string content_url = 6;
  inline bool has_content_url() const;
  inline void clear_content_url();
  static const int kContentUrlFieldNumber = 6;
  inline const ::std::string& content_url() const;
  inline void set_content_url(const ::std::string& value);
  inline void set_content_url(const char* value);
  inline void set_content_url(const char* value, size_t size);
  inline ::std::string* mutable_content_url();
  inline ::std::string* release_content_url();
  inline void set_allocated_content_url(::std::string* content_url);

  // optional string source_url = 7;
  inline bool has_source_url() const;
  inline void clear_source_url();
  static const int kSourceUrlFieldNumber = 7;
  inline const ::std::string& source_url() const;
  inline void set_source_url(const ::std::string& value);
  inline void set_source_url(const char* value);
  inline void set_source_url(const char* value, size_t size);
  inline ::std::string* mutable_source_url();
  inline ::std::string* release_source_url();
  inline void set_allocated_source_url(::std::string* source_url);

  // @@protoc_insertion_point(class_scope:mpcomm.RespNews)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_author();
  inline void clear_has_author();
  inline void set_has_digest();
  inline void clear_has_digest();
  inline void set_has_show_cover();
  inline void clear_has_show_cover();
  inline void set_has_cover_url();
  inline void clear_has_cover_url();
  inline void set_has_content_url();
  inline void clear_has_content_url();
  inline void set_has_source_url();
  inline void clear_has_source_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* author_;
  ::std::string* digest_;
  ::google::protobuf::uint64 show_cover_;
  ::std::string* cover_url_;
  ::std::string* content_url_;
  ::std::string* source_url_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static RespNews* default_instance_;
};
// -------------------------------------------------------------------

class RespNewsList : public ::google::protobuf::Message {
 public:
  RespNewsList();
  virtual ~RespNewsList();

  RespNewsList(const RespNewsList& from);

  inline RespNewsList& operator=(const RespNewsList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespNewsList& default_instance();

  void Swap(RespNewsList* other);

  // implements Message ----------------------------------------------

  RespNewsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespNewsList& from);
  void MergeFrom(const RespNewsList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpcomm.RespNews list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::mpcomm::RespNews& list(int index) const;
  inline ::mpcomm::RespNews* mutable_list(int index);
  inline ::mpcomm::RespNews* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::RespNews >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::RespNews >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:mpcomm.RespNewsList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::RespNews > list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static RespNewsList* default_instance_;
};
// -------------------------------------------------------------------

class CurrentSelfMenuButton : public ::google::protobuf::Message {
 public:
  CurrentSelfMenuButton();
  virtual ~CurrentSelfMenuButton();

  CurrentSelfMenuButton(const CurrentSelfMenuButton& from);

  inline CurrentSelfMenuButton& operator=(const CurrentSelfMenuButton& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentSelfMenuButton& default_instance();

  void Swap(CurrentSelfMenuButton* other);

  // implements Message ----------------------------------------------

  CurrentSelfMenuButton* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurrentSelfMenuButton& from);
  void MergeFrom(const CurrentSelfMenuButton& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string url = 4;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 4;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional .mpcomm.RespNewsList news_info = 6;
  inline bool has_news_info() const;
  inline void clear_news_info();
  static const int kNewsInfoFieldNumber = 6;
  inline const ::mpcomm::RespNewsList& news_info() const;
  inline ::mpcomm::RespNewsList* mutable_news_info();
  inline ::mpcomm::RespNewsList* release_news_info();
  inline void set_allocated_news_info(::mpcomm::RespNewsList* news_info);

  // optional .mpcomm.CurrentSelfMenuButtonList sub_button = 7;
  inline bool has_sub_button() const;
  inline void clear_sub_button();
  static const int kSubButtonFieldNumber = 7;
  inline const ::mpcomm::CurrentSelfMenuButtonList& sub_button() const;
  inline ::mpcomm::CurrentSelfMenuButtonList* mutable_sub_button();
  inline ::mpcomm::CurrentSelfMenuButtonList* release_sub_button();
  inline void set_allocated_sub_button(::mpcomm::CurrentSelfMenuButtonList* sub_button);

  // @@protoc_insertion_point(class_scope:mpcomm.CurrentSelfMenuButton)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_news_info();
  inline void clear_has_news_info();
  inline void set_has_sub_button();
  inline void clear_has_sub_button();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* name_;
  ::std::string* key_;
  ::std::string* url_;
  ::std::string* value_;
  ::mpcomm::RespNewsList* news_info_;
  ::mpcomm::CurrentSelfMenuButtonList* sub_button_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static CurrentSelfMenuButton* default_instance_;
};
// -------------------------------------------------------------------

class CurrentSelfMenuButtonList : public ::google::protobuf::Message {
 public:
  CurrentSelfMenuButtonList();
  virtual ~CurrentSelfMenuButtonList();

  CurrentSelfMenuButtonList(const CurrentSelfMenuButtonList& from);

  inline CurrentSelfMenuButtonList& operator=(const CurrentSelfMenuButtonList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentSelfMenuButtonList& default_instance();

  void Swap(CurrentSelfMenuButtonList* other);

  // implements Message ----------------------------------------------

  CurrentSelfMenuButtonList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurrentSelfMenuButtonList& from);
  void MergeFrom(const CurrentSelfMenuButtonList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpcomm.CurrentSelfMenuButton list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::mpcomm::CurrentSelfMenuButton& list(int index) const;
  inline ::mpcomm::CurrentSelfMenuButton* mutable_list(int index);
  inline ::mpcomm::CurrentSelfMenuButton* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:mpcomm.CurrentSelfMenuButtonList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton > list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static CurrentSelfMenuButtonList* default_instance_;
};
// -------------------------------------------------------------------

class CurrentSelfMenu : public ::google::protobuf::Message {
 public:
  CurrentSelfMenu();
  virtual ~CurrentSelfMenu();

  CurrentSelfMenu(const CurrentSelfMenu& from);

  inline CurrentSelfMenu& operator=(const CurrentSelfMenu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentSelfMenu& default_instance();

  void Swap(CurrentSelfMenu* other);

  // implements Message ----------------------------------------------

  CurrentSelfMenu* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurrentSelfMenu& from);
  void MergeFrom(const CurrentSelfMenu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpcomm.CurrentSelfMenuButton button = 1;
  inline int button_size() const;
  inline void clear_button();
  static const int kButtonFieldNumber = 1;
  inline const ::mpcomm::CurrentSelfMenuButton& button(int index) const;
  inline ::mpcomm::CurrentSelfMenuButton* mutable_button(int index);
  inline ::mpcomm::CurrentSelfMenuButton* add_button();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton >&
      button() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton >*
      mutable_button();

  // @@protoc_insertion_point(class_scope:mpcomm.CurrentSelfMenu)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton > button_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static CurrentSelfMenu* default_instance_;
};
// -------------------------------------------------------------------

class GetCurrentSelfMenuInfoResp : public ::google::protobuf::Message {
 public:
  GetCurrentSelfMenuInfoResp();
  virtual ~GetCurrentSelfMenuInfoResp();

  GetCurrentSelfMenuInfoResp(const GetCurrentSelfMenuInfoResp& from);

  inline GetCurrentSelfMenuInfoResp& operator=(const GetCurrentSelfMenuInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCurrentSelfMenuInfoResp& default_instance();

  void Swap(GetCurrentSelfMenuInfoResp* other);

  // implements Message ----------------------------------------------

  GetCurrentSelfMenuInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCurrentSelfMenuInfoResp& from);
  void MergeFrom(const GetCurrentSelfMenuInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 is_menu_open = 3;
  inline bool has_is_menu_open() const;
  inline void clear_is_menu_open();
  static const int kIsMenuOpenFieldNumber = 3;
  inline ::google::protobuf::uint64 is_menu_open() const;
  inline void set_is_menu_open(::google::protobuf::uint64 value);

  // optional .mpcomm.CurrentSelfMenu selfmenu_info = 4;
  inline bool has_selfmenu_info() const;
  inline void clear_selfmenu_info();
  static const int kSelfmenuInfoFieldNumber = 4;
  inline const ::mpcomm::CurrentSelfMenu& selfmenu_info() const;
  inline ::mpcomm::CurrentSelfMenu* mutable_selfmenu_info();
  inline ::mpcomm::CurrentSelfMenu* release_selfmenu_info();
  inline void set_allocated_selfmenu_info(::mpcomm::CurrentSelfMenu* selfmenu_info);

  // @@protoc_insertion_point(class_scope:mpcomm.GetCurrentSelfMenuInfoResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_is_menu_open();
  inline void clear_has_is_menu_open();
  inline void set_has_selfmenu_info();
  inline void clear_has_selfmenu_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 is_menu_open_;
  ::mpcomm::CurrentSelfMenu* selfmenu_info_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetCurrentSelfMenuInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class ReplyItem : public ::google::protobuf::Message {
 public:
  ReplyItem();
  virtual ~ReplyItem();

  ReplyItem(const ReplyItem& from);

  inline ReplyItem& operator=(const ReplyItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyItem& default_instance();

  void Swap(ReplyItem* other);

  // implements Message ----------------------------------------------

  ReplyItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplyItem& from);
  void MergeFrom(const ReplyItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional .mpcomm.RespNewsList news_info = 3;
  inline bool has_news_info() const;
  inline void clear_news_info();
  static const int kNewsInfoFieldNumber = 3;
  inline const ::mpcomm::RespNewsList& news_info() const;
  inline ::mpcomm::RespNewsList* mutable_news_info();
  inline ::mpcomm::RespNewsList* release_news_info();
  inline void set_allocated_news_info(::mpcomm::RespNewsList* news_info);

  // @@protoc_insertion_point(class_scope:mpcomm.ReplyItem)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_news_info();
  inline void clear_has_news_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* content_;
  ::mpcomm::RespNewsList* news_info_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static ReplyItem* default_instance_;
};
// -------------------------------------------------------------------

class KeyWordItem : public ::google::protobuf::Message {
 public:
  KeyWordItem();
  virtual ~KeyWordItem();

  KeyWordItem(const KeyWordItem& from);

  inline KeyWordItem& operator=(const KeyWordItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyWordItem& default_instance();

  void Swap(KeyWordItem* other);

  // implements Message ----------------------------------------------

  KeyWordItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyWordItem& from);
  void MergeFrom(const KeyWordItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string match_mode = 2;
  inline bool has_match_mode() const;
  inline void clear_match_mode();
  static const int kMatchModeFieldNumber = 2;
  inline const ::std::string& match_mode() const;
  inline void set_match_mode(const ::std::string& value);
  inline void set_match_mode(const char* value);
  inline void set_match_mode(const char* value, size_t size);
  inline ::std::string* mutable_match_mode();
  inline ::std::string* release_match_mode();
  inline void set_allocated_match_mode(::std::string* match_mode);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:mpcomm.KeyWordItem)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_match_mode();
  inline void clear_has_match_mode();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* match_mode_;
  ::std::string* content_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static KeyWordItem* default_instance_;
};
// -------------------------------------------------------------------

class AutoReplyRule : public ::google::protobuf::Message {
 public:
  AutoReplyRule();
  virtual ~AutoReplyRule();

  AutoReplyRule(const AutoReplyRule& from);

  inline AutoReplyRule& operator=(const AutoReplyRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoReplyRule& default_instance();

  void Swap(AutoReplyRule* other);

  // implements Message ----------------------------------------------

  AutoReplyRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutoReplyRule& from);
  void MergeFrom(const AutoReplyRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rule_name = 1;
  inline bool has_rule_name() const;
  inline void clear_rule_name();
  static const int kRuleNameFieldNumber = 1;
  inline const ::std::string& rule_name() const;
  inline void set_rule_name(const ::std::string& value);
  inline void set_rule_name(const char* value);
  inline void set_rule_name(const char* value, size_t size);
  inline ::std::string* mutable_rule_name();
  inline ::std::string* release_rule_name();
  inline void set_allocated_rule_name(::std::string* rule_name);

  // optional uint64 create_time = 2;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 create_time() const;
  inline void set_create_time(::google::protobuf::uint64 value);

  // optional string reply_mode = 3;
  inline bool has_reply_mode() const;
  inline void clear_reply_mode();
  static const int kReplyModeFieldNumber = 3;
  inline const ::std::string& reply_mode() const;
  inline void set_reply_mode(const ::std::string& value);
  inline void set_reply_mode(const char* value);
  inline void set_reply_mode(const char* value, size_t size);
  inline ::std::string* mutable_reply_mode();
  inline ::std::string* release_reply_mode();
  inline void set_allocated_reply_mode(::std::string* reply_mode);

  // repeated .mpcomm.KeyWordItem keyword_list_info = 4;
  inline int keyword_list_info_size() const;
  inline void clear_keyword_list_info();
  static const int kKeywordListInfoFieldNumber = 4;
  inline const ::mpcomm::KeyWordItem& keyword_list_info(int index) const;
  inline ::mpcomm::KeyWordItem* mutable_keyword_list_info(int index);
  inline ::mpcomm::KeyWordItem* add_keyword_list_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::KeyWordItem >&
      keyword_list_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::KeyWordItem >*
      mutable_keyword_list_info();

  // repeated .mpcomm.ReplyItem reply_list_info = 5;
  inline int reply_list_info_size() const;
  inline void clear_reply_list_info();
  static const int kReplyListInfoFieldNumber = 5;
  inline const ::mpcomm::ReplyItem& reply_list_info(int index) const;
  inline ::mpcomm::ReplyItem* mutable_reply_list_info(int index);
  inline ::mpcomm::ReplyItem* add_reply_list_info();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::ReplyItem >&
      reply_list_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::ReplyItem >*
      mutable_reply_list_info();

  // @@protoc_insertion_point(class_scope:mpcomm.AutoReplyRule)
 private:
  inline void set_has_rule_name();
  inline void clear_has_rule_name();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_reply_mode();
  inline void clear_has_reply_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rule_name_;
  ::google::protobuf::uint64 create_time_;
  ::std::string* reply_mode_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::KeyWordItem > keyword_list_info_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::ReplyItem > reply_list_info_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AutoReplyRule* default_instance_;
};
// -------------------------------------------------------------------

class AutoReplyRuleList : public ::google::protobuf::Message {
 public:
  AutoReplyRuleList();
  virtual ~AutoReplyRuleList();

  AutoReplyRuleList(const AutoReplyRuleList& from);

  inline AutoReplyRuleList& operator=(const AutoReplyRuleList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoReplyRuleList& default_instance();

  void Swap(AutoReplyRuleList* other);

  // implements Message ----------------------------------------------

  AutoReplyRuleList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutoReplyRuleList& from);
  void MergeFrom(const AutoReplyRuleList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpcomm.AutoReplyRule list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::mpcomm::AutoReplyRule& list(int index) const;
  inline ::mpcomm::AutoReplyRule* mutable_list(int index);
  inline ::mpcomm::AutoReplyRule* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::AutoReplyRule >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::AutoReplyRule >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:mpcomm.AutoReplyRuleList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::AutoReplyRule > list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AutoReplyRuleList* default_instance_;
};
// -------------------------------------------------------------------

class GetCurrentAutoReplyInfoReq : public ::google::protobuf::Message {
 public:
  GetCurrentAutoReplyInfoReq();
  virtual ~GetCurrentAutoReplyInfoReq();

  GetCurrentAutoReplyInfoReq(const GetCurrentAutoReplyInfoReq& from);

  inline GetCurrentAutoReplyInfoReq& operator=(const GetCurrentAutoReplyInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCurrentAutoReplyInfoReq& default_instance();

  void Swap(GetCurrentAutoReplyInfoReq* other);

  // implements Message ----------------------------------------------

  GetCurrentAutoReplyInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCurrentAutoReplyInfoReq& from);
  void MergeFrom(const GetCurrentAutoReplyInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:mpcomm.GetCurrentAutoReplyInfoReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetCurrentAutoReplyInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class GetCurrentAutoReplyInfoResp : public ::google::protobuf::Message {
 public:
  GetCurrentAutoReplyInfoResp();
  virtual ~GetCurrentAutoReplyInfoResp();

  GetCurrentAutoReplyInfoResp(const GetCurrentAutoReplyInfoResp& from);

  inline GetCurrentAutoReplyInfoResp& operator=(const GetCurrentAutoReplyInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCurrentAutoReplyInfoResp& default_instance();

  void Swap(GetCurrentAutoReplyInfoResp* other);

  // implements Message ----------------------------------------------

  GetCurrentAutoReplyInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCurrentAutoReplyInfoResp& from);
  void MergeFrom(const GetCurrentAutoReplyInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 is_add_friend_reply_open = 3;
  inline bool has_is_add_friend_reply_open() const;
  inline void clear_is_add_friend_reply_open();
  static const int kIsAddFriendReplyOpenFieldNumber = 3;
  inline ::google::protobuf::uint64 is_add_friend_reply_open() const;
  inline void set_is_add_friend_reply_open(::google::protobuf::uint64 value);

  // optional uint64 is_autoreply_open = 4;
  inline bool has_is_autoreply_open() const;
  inline void clear_is_autoreply_open();
  static const int kIsAutoreplyOpenFieldNumber = 4;
  inline ::google::protobuf::uint64 is_autoreply_open() const;
  inline void set_is_autoreply_open(::google::protobuf::uint64 value);

  // optional .mpcomm.ReplyItem add_friend_autoreply_info = 5;
  inline bool has_add_friend_autoreply_info() const;
  inline void clear_add_friend_autoreply_info();
  static const int kAddFriendAutoreplyInfoFieldNumber = 5;
  inline const ::mpcomm::ReplyItem& add_friend_autoreply_info() const;
  inline ::mpcomm::ReplyItem* mutable_add_friend_autoreply_info();
  inline ::mpcomm::ReplyItem* release_add_friend_autoreply_info();
  inline void set_allocated_add_friend_autoreply_info(::mpcomm::ReplyItem* add_friend_autoreply_info);

  // optional .mpcomm.ReplyItem message_default_autoreply_info = 6;
  inline bool has_message_default_autoreply_info() const;
  inline void clear_message_default_autoreply_info();
  static const int kMessageDefaultAutoreplyInfoFieldNumber = 6;
  inline const ::mpcomm::ReplyItem& message_default_autoreply_info() const;
  inline ::mpcomm::ReplyItem* mutable_message_default_autoreply_info();
  inline ::mpcomm::ReplyItem* release_message_default_autoreply_info();
  inline void set_allocated_message_default_autoreply_info(::mpcomm::ReplyItem* message_default_autoreply_info);

  // optional .mpcomm.AutoReplyRuleList keyword_autoreply_info = 7;
  inline bool has_keyword_autoreply_info() const;
  inline void clear_keyword_autoreply_info();
  static const int kKeywordAutoreplyInfoFieldNumber = 7;
  inline const ::mpcomm::AutoReplyRuleList& keyword_autoreply_info() const;
  inline ::mpcomm::AutoReplyRuleList* mutable_keyword_autoreply_info();
  inline ::mpcomm::AutoReplyRuleList* release_keyword_autoreply_info();
  inline void set_allocated_keyword_autoreply_info(::mpcomm::AutoReplyRuleList* keyword_autoreply_info);

  // @@protoc_insertion_point(class_scope:mpcomm.GetCurrentAutoReplyInfoResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_is_add_friend_reply_open();
  inline void clear_has_is_add_friend_reply_open();
  inline void set_has_is_autoreply_open();
  inline void clear_has_is_autoreply_open();
  inline void set_has_add_friend_autoreply_info();
  inline void clear_has_add_friend_autoreply_info();
  inline void set_has_message_default_autoreply_info();
  inline void clear_has_message_default_autoreply_info();
  inline void set_has_keyword_autoreply_info();
  inline void clear_has_keyword_autoreply_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 is_add_friend_reply_open_;
  ::google::protobuf::uint64 is_autoreply_open_;
  ::mpcomm::ReplyItem* add_friend_autoreply_info_;
  ::mpcomm::ReplyItem* message_default_autoreply_info_;
  ::mpcomm::AutoReplyRuleList* keyword_autoreply_info_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetCurrentAutoReplyInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class Text : public ::google::protobuf::Message {
 public:
  Text();
  virtual ~Text();

  Text(const Text& from);

  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Text& default_instance();

  void Swap(Text* other);

  // implements Message ----------------------------------------------

  Text* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Text& from);
  void MergeFrom(const Text& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:mpcomm.Text)
 private:
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* content_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Text* default_instance_;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  Image* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string media_id = 1;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 1;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.Image)
 private:
  inline void set_has_media_id();
  inline void clear_has_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class Voice : public ::google::protobuf::Message {
 public:
  Voice();
  virtual ~Voice();

  Voice(const Voice& from);

  inline Voice& operator=(const Voice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Voice& default_instance();

  void Swap(Voice* other);

  // implements Message ----------------------------------------------

  Voice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Voice& from);
  void MergeFrom(const Voice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string media_id = 1;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 1;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.Voice)
 private:
  inline void set_has_media_id();
  inline void clear_has_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Voice* default_instance_;
};
// -------------------------------------------------------------------

class Video : public ::google::protobuf::Message {
 public:
  Video();
  virtual ~Video();

  Video(const Video& from);

  inline Video& operator=(const Video& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Video& default_instance();

  void Swap(Video* other);

  // implements Message ----------------------------------------------

  Video* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Video& from);
  void MergeFrom(const Video& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string media_id = 1;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 1;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // optional string thumb_media_id = 2;
  inline bool has_thumb_media_id() const;
  inline void clear_thumb_media_id();
  static const int kThumbMediaIdFieldNumber = 2;
  inline const ::std::string& thumb_media_id() const;
  inline void set_thumb_media_id(const ::std::string& value);
  inline void set_thumb_media_id(const char* value);
  inline void set_thumb_media_id(const char* value, size_t size);
  inline ::std::string* mutable_thumb_media_id();
  inline ::std::string* release_thumb_media_id();
  inline void set_allocated_thumb_media_id(::std::string* thumb_media_id);

  // optional string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:mpcomm.Video)
 private:
  inline void set_has_media_id();
  inline void clear_has_media_id();
  inline void set_has_thumb_media_id();
  inline void clear_has_thumb_media_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* media_id_;
  ::std::string* thumb_media_id_;
  ::std::string* title_;
  ::std::string* description_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Video* default_instance_;
};
// -------------------------------------------------------------------

class Link : public ::google::protobuf::Message {
 public:
  Link();
  virtual ~Link();

  Link(const Link& from);

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Link& default_instance();

  void Swap(Link* other);

  // implements Message ----------------------------------------------

  Link* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Link& from);
  void MergeFrom(const Link& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string thumb_media_id = 4;
  inline bool has_thumb_media_id() const;
  inline void clear_thumb_media_id();
  static const int kThumbMediaIdFieldNumber = 4;
  inline const ::std::string& thumb_media_id() const;
  inline void set_thumb_media_id(const ::std::string& value);
  inline void set_thumb_media_id(const char* value);
  inline void set_thumb_media_id(const char* value, size_t size);
  inline ::std::string* mutable_thumb_media_id();
  inline ::std::string* release_thumb_media_id();
  inline void set_allocated_thumb_media_id(::std::string* thumb_media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.Link)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_thumb_media_id();
  inline void clear_has_thumb_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* description_;
  ::std::string* url_;
  ::std::string* thumb_media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Link* default_instance_;
};
// -------------------------------------------------------------------

class Card : public ::google::protobuf::Message {
 public:
  Card();
  virtual ~Card();

  Card(const Card& from);

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Card& default_instance();

  void Swap(Card* other);

  // implements Message ----------------------------------------------

  Card* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Card& from);
  void MergeFrom(const Card& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string weixin_id = 1;
  inline bool has_weixin_id() const;
  inline void clear_weixin_id();
  static const int kWeixinIdFieldNumber = 1;
  inline const ::std::string& weixin_id() const;
  inline void set_weixin_id(const ::std::string& value);
  inline void set_weixin_id(const char* value);
  inline void set_weixin_id(const char* value, size_t size);
  inline ::std::string* mutable_weixin_id();
  inline ::std::string* release_weixin_id();
  inline void set_allocated_weixin_id(::std::string* weixin_id);

  // @@protoc_insertion_point(class_scope:mpcomm.Card)
 private:
  inline void set_has_weixin_id();
  inline void clear_has_weixin_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* weixin_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Card* default_instance_;
};
// -------------------------------------------------------------------

class ArticlesItem : public ::google::protobuf::Message {
 public:
  ArticlesItem();
  virtual ~ArticlesItem();

  ArticlesItem(const ArticlesItem& from);

  inline ArticlesItem& operator=(const ArticlesItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArticlesItem& default_instance();

  void Swap(ArticlesItem* other);

  // implements Message ----------------------------------------------

  ArticlesItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArticlesItem& from);
  void MergeFrom(const ArticlesItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string picurl = 3;
  inline bool has_picurl() const;
  inline void clear_picurl();
  static const int kPicurlFieldNumber = 3;
  inline const ::std::string& picurl() const;
  inline void set_picurl(const ::std::string& value);
  inline void set_picurl(const char* value);
  inline void set_picurl(const char* value, size_t size);
  inline ::std::string* mutable_picurl();
  inline ::std::string* release_picurl();
  inline void set_allocated_picurl(::std::string* picurl);

  // optional string url = 4;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 4;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:mpcomm.ArticlesItem)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_picurl();
  inline void clear_has_picurl();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* description_;
  ::std::string* picurl_;
  ::std::string* url_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static ArticlesItem* default_instance_;
};
// -------------------------------------------------------------------

class NewsMsg : public ::google::protobuf::Message {
 public:
  NewsMsg();
  virtual ~NewsMsg();

  NewsMsg(const NewsMsg& from);

  inline NewsMsg& operator=(const NewsMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewsMsg& default_instance();

  void Swap(NewsMsg* other);

  // implements Message ----------------------------------------------

  NewsMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewsMsg& from);
  void MergeFrom(const NewsMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpcomm.ArticlesItem articles = 1;
  inline int articles_size() const;
  inline void clear_articles();
  static const int kArticlesFieldNumber = 1;
  inline const ::mpcomm::ArticlesItem& articles(int index) const;
  inline ::mpcomm::ArticlesItem* mutable_articles(int index);
  inline ::mpcomm::ArticlesItem* add_articles();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::ArticlesItem >&
      articles() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::ArticlesItem >*
      mutable_articles();

  // optional string thumb_media_id = 4;
  inline bool has_thumb_media_id() const;
  inline void clear_thumb_media_id();
  static const int kThumbMediaIdFieldNumber = 4;
  inline const ::std::string& thumb_media_id() const;
  inline void set_thumb_media_id(const ::std::string& value);
  inline void set_thumb_media_id(const char* value);
  inline void set_thumb_media_id(const char* value, size_t size);
  inline ::std::string* mutable_thumb_media_id();
  inline ::std::string* release_thumb_media_id();
  inline void set_allocated_thumb_media_id(::std::string* thumb_media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.NewsMsg)
 private:
  inline void set_has_thumb_media_id();
  inline void clear_has_thumb_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::ArticlesItem > articles_;
  ::std::string* thumb_media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static NewsMsg* default_instance_;
};
// -------------------------------------------------------------------

class Music : public ::google::protobuf::Message {
 public:
  Music();
  virtual ~Music();

  Music(const Music& from);

  inline Music& operator=(const Music& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Music& default_instance();

  void Swap(Music* other);

  // implements Message ----------------------------------------------

  Music* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Music& from);
  void MergeFrom(const Music& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string musicurl = 3;
  inline bool has_musicurl() const;
  inline void clear_musicurl();
  static const int kMusicurlFieldNumber = 3;
  inline const ::std::string& musicurl() const;
  inline void set_musicurl(const ::std::string& value);
  inline void set_musicurl(const char* value);
  inline void set_musicurl(const char* value, size_t size);
  inline ::std::string* mutable_musicurl();
  inline ::std::string* release_musicurl();
  inline void set_allocated_musicurl(::std::string* musicurl);

  // optional string hqmusicurl = 4;
  inline bool has_hqmusicurl() const;
  inline void clear_hqmusicurl();
  static const int kHqmusicurlFieldNumber = 4;
  inline const ::std::string& hqmusicurl() const;
  inline void set_hqmusicurl(const ::std::string& value);
  inline void set_hqmusicurl(const char* value);
  inline void set_hqmusicurl(const char* value, size_t size);
  inline ::std::string* mutable_hqmusicurl();
  inline ::std::string* release_hqmusicurl();
  inline void set_allocated_hqmusicurl(::std::string* hqmusicurl);

  // optional string thumb_media_id = 5;
  inline bool has_thumb_media_id() const;
  inline void clear_thumb_media_id();
  static const int kThumbMediaIdFieldNumber = 5;
  inline const ::std::string& thumb_media_id() const;
  inline void set_thumb_media_id(const ::std::string& value);
  inline void set_thumb_media_id(const char* value);
  inline void set_thumb_media_id(const char* value, size_t size);
  inline ::std::string* mutable_thumb_media_id();
  inline ::std::string* release_thumb_media_id();
  inline void set_allocated_thumb_media_id(::std::string* thumb_media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.Music)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_musicurl();
  inline void clear_has_musicurl();
  inline void set_has_hqmusicurl();
  inline void clear_has_hqmusicurl();
  inline void set_has_thumb_media_id();
  inline void clear_has_thumb_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* description_;
  ::std::string* musicurl_;
  ::std::string* hqmusicurl_;
  ::std::string* thumb_media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Music* default_instance_;
};
// -------------------------------------------------------------------

class MpNewsMsg : public ::google::protobuf::Message {
 public:
  MpNewsMsg();
  virtual ~MpNewsMsg();

  MpNewsMsg(const MpNewsMsg& from);

  inline MpNewsMsg& operator=(const MpNewsMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MpNewsMsg& default_instance();

  void Swap(MpNewsMsg* other);

  // implements Message ----------------------------------------------

  MpNewsMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MpNewsMsg& from);
  void MergeFrom(const MpNewsMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string media_id = 1;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 1;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.MpNewsMsg)
 private:
  inline void set_has_media_id();
  inline void clear_has_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MpNewsMsg* default_instance_;
};
// -------------------------------------------------------------------

class MpVideo : public ::google::protobuf::Message {
 public:
  MpVideo();
  virtual ~MpVideo();

  MpVideo(const MpVideo& from);

  inline MpVideo& operator=(const MpVideo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MpVideo& default_instance();

  void Swap(MpVideo* other);

  // implements Message ----------------------------------------------

  MpVideo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MpVideo& from);
  void MergeFrom(const MpVideo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string media_id = 1;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 1;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.MpVideo)
 private:
  inline void set_has_media_id();
  inline void clear_has_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MpVideo* default_instance_;
};
// -------------------------------------------------------------------

class WxCard : public ::google::protobuf::Message {
 public:
  WxCard();
  virtual ~WxCard();

  WxCard(const WxCard& from);

  inline WxCard& operator=(const WxCard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WxCard& default_instance();

  void Swap(WxCard* other);

  // implements Message ----------------------------------------------

  WxCard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WxCard& from);
  void MergeFrom(const WxCard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string card_id = 1;
  inline bool has_card_id() const;
  inline void clear_card_id();
  static const int kCardIdFieldNumber = 1;
  inline const ::std::string& card_id() const;
  inline void set_card_id(const ::std::string& value);
  inline void set_card_id(const char* value);
  inline void set_card_id(const char* value, size_t size);
  inline ::std::string* mutable_card_id();
  inline ::std::string* release_card_id();
  inline void set_allocated_card_id(::std::string* card_id);

  // optional string card_ext = 2;
  inline bool has_card_ext() const;
  inline void clear_card_ext();
  static const int kCardExtFieldNumber = 2;
  inline const ::std::string& card_ext() const;
  inline void set_card_ext(const ::std::string& value);
  inline void set_card_ext(const char* value);
  inline void set_card_ext(const char* value, size_t size);
  inline ::std::string* mutable_card_ext();
  inline ::std::string* release_card_ext();
  inline void set_allocated_card_ext(::std::string* card_ext);

  // @@protoc_insertion_point(class_scope:mpcomm.WxCard)
 private:
  inline void set_has_card_id();
  inline void clear_has_card_id();
  inline void set_has_card_ext();
  inline void clear_has_card_ext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* card_id_;
  ::std::string* card_ext_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static WxCard* default_instance_;
};
// -------------------------------------------------------------------

class CustomServiceInfo : public ::google::protobuf::Message {
 public:
  CustomServiceInfo();
  virtual ~CustomServiceInfo();

  CustomServiceInfo(const CustomServiceInfo& from);

  inline CustomServiceInfo& operator=(const CustomServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomServiceInfo& default_instance();

  void Swap(CustomServiceInfo* other);

  // implements Message ----------------------------------------------

  CustomServiceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CustomServiceInfo& from);
  void MergeFrom(const CustomServiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string kf_account = 1;
  inline bool has_kf_account() const;
  inline void clear_kf_account();
  static const int kKfAccountFieldNumber = 1;
  inline const ::std::string& kf_account() const;
  inline void set_kf_account(const ::std::string& value);
  inline void set_kf_account(const char* value);
  inline void set_kf_account(const char* value, size_t size);
  inline ::std::string* mutable_kf_account();
  inline ::std::string* release_kf_account();
  inline void set_allocated_kf_account(::std::string* kf_account);

  // @@protoc_insertion_point(class_scope:mpcomm.CustomServiceInfo)
 private:
  inline void set_has_kf_account();
  inline void clear_has_kf_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* kf_account_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static CustomServiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class SendCustomMessageReq : public ::google::protobuf::Message {
 public:
  SendCustomMessageReq();
  virtual ~SendCustomMessageReq();

  SendCustomMessageReq(const SendCustomMessageReq& from);

  inline SendCustomMessageReq& operator=(const SendCustomMessageReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendCustomMessageReq& default_instance();

  void Swap(SendCustomMessageReq* other);

  // implements Message ----------------------------------------------

  SendCustomMessageReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendCustomMessageReq& from);
  void MergeFrom(const SendCustomMessageReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string msgtype = 2;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 2;
  inline const ::std::string& msgtype() const;
  inline void set_msgtype(const ::std::string& value);
  inline void set_msgtype(const char* value);
  inline void set_msgtype(const char* value, size_t size);
  inline ::std::string* mutable_msgtype();
  inline ::std::string* release_msgtype();
  inline void set_allocated_msgtype(::std::string* msgtype);

  // optional string touser = 3;
  inline bool has_touser() const;
  inline void clear_touser();
  static const int kTouserFieldNumber = 3;
  inline const ::std::string& touser() const;
  inline void set_touser(const ::std::string& value);
  inline void set_touser(const char* value);
  inline void set_touser(const char* value, size_t size);
  inline ::std::string* mutable_touser();
  inline ::std::string* release_touser();
  inline void set_allocated_touser(::std::string* touser);

  // optional .mpcomm.Text text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::mpcomm::Text& text() const;
  inline ::mpcomm::Text* mutable_text();
  inline ::mpcomm::Text* release_text();
  inline void set_allocated_text(::mpcomm::Text* text);

  // optional .mpcomm.Image image = 5;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 5;
  inline const ::mpcomm::Image& image() const;
  inline ::mpcomm::Image* mutable_image();
  inline ::mpcomm::Image* release_image();
  inline void set_allocated_image(::mpcomm::Image* image);

  // optional .mpcomm.Voice voice = 6;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 6;
  inline const ::mpcomm::Voice& voice() const;
  inline ::mpcomm::Voice* mutable_voice();
  inline ::mpcomm::Voice* release_voice();
  inline void set_allocated_voice(::mpcomm::Voice* voice);

  // optional .mpcomm.Video video = 7;
  inline bool has_video() const;
  inline void clear_video();
  static const int kVideoFieldNumber = 7;
  inline const ::mpcomm::Video& video() const;
  inline ::mpcomm::Video* mutable_video();
  inline ::mpcomm::Video* release_video();
  inline void set_allocated_video(::mpcomm::Video* video);

  // optional .mpcomm.Music music = 8;
  inline bool has_music() const;
  inline void clear_music();
  static const int kMusicFieldNumber = 8;
  inline const ::mpcomm::Music& music() const;
  inline ::mpcomm::Music* mutable_music();
  inline ::mpcomm::Music* release_music();
  inline void set_allocated_music(::mpcomm::Music* music);

  // optional .mpcomm.NewsMsg news = 9;
  inline bool has_news() const;
  inline void clear_news();
  static const int kNewsFieldNumber = 9;
  inline const ::mpcomm::NewsMsg& news() const;
  inline ::mpcomm::NewsMsg* mutable_news();
  inline ::mpcomm::NewsMsg* release_news();
  inline void set_allocated_news(::mpcomm::NewsMsg* news);

  // optional .mpcomm.MpNewsMsg mpnews = 10;
  inline bool has_mpnews() const;
  inline void clear_mpnews();
  static const int kMpnewsFieldNumber = 10;
  inline const ::mpcomm::MpNewsMsg& mpnews() const;
  inline ::mpcomm::MpNewsMsg* mutable_mpnews();
  inline ::mpcomm::MpNewsMsg* release_mpnews();
  inline void set_allocated_mpnews(::mpcomm::MpNewsMsg* mpnews);

  // optional .mpcomm.WxCard wxcard = 11;
  inline bool has_wxcard() const;
  inline void clear_wxcard();
  static const int kWxcardFieldNumber = 11;
  inline const ::mpcomm::WxCard& wxcard() const;
  inline ::mpcomm::WxCard* mutable_wxcard();
  inline ::mpcomm::WxCard* release_wxcard();
  inline void set_allocated_wxcard(::mpcomm::WxCard* wxcard);

  // optional .mpcomm.CustomServiceInfo customservice = 12;
  inline bool has_customservice() const;
  inline void clear_customservice();
  static const int kCustomserviceFieldNumber = 12;
  inline const ::mpcomm::CustomServiceInfo& customservice() const;
  inline ::mpcomm::CustomServiceInfo* mutable_customservice();
  inline ::mpcomm::CustomServiceInfo* release_customservice();
  inline void set_allocated_customservice(::mpcomm::CustomServiceInfo* customservice);

  // optional .mpcomm.MpVideo mpvideo = 13;
  inline bool has_mpvideo() const;
  inline void clear_mpvideo();
  static const int kMpvideoFieldNumber = 13;
  inline const ::mpcomm::MpVideo& mpvideo() const;
  inline ::mpcomm::MpVideo* mutable_mpvideo();
  inline ::mpcomm::MpVideo* release_mpvideo();
  inline void set_allocated_mpvideo(::mpcomm::MpVideo* mpvideo);

  // @@protoc_insertion_point(class_scope:mpcomm.SendCustomMessageReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_touser();
  inline void clear_has_touser();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_voice();
  inline void clear_has_voice();
  inline void set_has_video();
  inline void clear_has_video();
  inline void set_has_music();
  inline void clear_has_music();
  inline void set_has_news();
  inline void clear_has_news();
  inline void set_has_mpnews();
  inline void clear_has_mpnews();
  inline void set_has_wxcard();
  inline void clear_has_wxcard();
  inline void set_has_customservice();
  inline void clear_has_customservice();
  inline void set_has_mpvideo();
  inline void clear_has_mpvideo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* msgtype_;
  ::std::string* touser_;
  ::mpcomm::Text* text_;
  ::mpcomm::Image* image_;
  ::mpcomm::Voice* voice_;
  ::mpcomm::Video* video_;
  ::mpcomm::Music* music_;
  ::mpcomm::NewsMsg* news_;
  ::mpcomm::MpNewsMsg* mpnews_;
  ::mpcomm::WxCard* wxcard_;
  ::mpcomm::CustomServiceInfo* customservice_;
  ::mpcomm::MpVideo* mpvideo_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static SendCustomMessageReq* default_instance_;
};
// -------------------------------------------------------------------

class SendCustomMessageResp : public ::google::protobuf::Message {
 public:
  SendCustomMessageResp();
  virtual ~SendCustomMessageResp();

  SendCustomMessageResp(const SendCustomMessageResp& from);

  inline SendCustomMessageResp& operator=(const SendCustomMessageResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendCustomMessageResp& default_instance();

  void Swap(SendCustomMessageResp* other);

  // implements Message ----------------------------------------------

  SendCustomMessageResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendCustomMessageResp& from);
  void MergeFrom(const SendCustomMessageResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.SendCustomMessageResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static SendCustomMessageResp* default_instance_;
};
// -------------------------------------------------------------------

class SendFilter : public ::google::protobuf::Message {
 public:
  SendFilter();
  virtual ~SendFilter();

  SendFilter(const SendFilter& from);

  inline SendFilter& operator=(const SendFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendFilter& default_instance();

  void Swap(SendFilter* other);

  // implements Message ----------------------------------------------

  SendFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendFilter& from);
  void MergeFrom(const SendFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_to_all = 1;
  inline bool has_is_to_all() const;
  inline void clear_is_to_all();
  static const int kIsToAllFieldNumber = 1;
  inline bool is_to_all() const;
  inline void set_is_to_all(bool value);

  // optional uint64 tag_id = 2;
  inline bool has_tag_id() const;
  inline void clear_tag_id();
  static const int kTagIdFieldNumber = 2;
  inline ::google::protobuf::uint64 tag_id() const;
  inline void set_tag_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.SendFilter)
 private:
  inline void set_has_is_to_all();
  inline void clear_has_is_to_all();
  inline void set_has_tag_id();
  inline void clear_has_tag_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 tag_id_;
  bool is_to_all_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static SendFilter* default_instance_;
};
// -------------------------------------------------------------------

class MassSendAllReq : public ::google::protobuf::Message {
 public:
  MassSendAllReq();
  virtual ~MassSendAllReq();

  MassSendAllReq(const MassSendAllReq& from);

  inline MassSendAllReq& operator=(const MassSendAllReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassSendAllReq& default_instance();

  void Swap(MassSendAllReq* other);

  // implements Message ----------------------------------------------

  MassSendAllReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassSendAllReq& from);
  void MergeFrom(const MassSendAllReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional .mpcomm.SendFilter filter = 2;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 2;
  inline const ::mpcomm::SendFilter& filter() const;
  inline ::mpcomm::SendFilter* mutable_filter();
  inline ::mpcomm::SendFilter* release_filter();
  inline void set_allocated_filter(::mpcomm::SendFilter* filter);

  // optional string msgtype = 3;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 3;
  inline const ::std::string& msgtype() const;
  inline void set_msgtype(const ::std::string& value);
  inline void set_msgtype(const char* value);
  inline void set_msgtype(const char* value, size_t size);
  inline ::std::string* mutable_msgtype();
  inline ::std::string* release_msgtype();
  inline void set_allocated_msgtype(::std::string* msgtype);

  // optional .mpcomm.Text text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::mpcomm::Text& text() const;
  inline ::mpcomm::Text* mutable_text();
  inline ::mpcomm::Text* release_text();
  inline void set_allocated_text(::mpcomm::Text* text);

  // optional .mpcomm.Image image = 5;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 5;
  inline const ::mpcomm::Image& image() const;
  inline ::mpcomm::Image* mutable_image();
  inline ::mpcomm::Image* release_image();
  inline void set_allocated_image(::mpcomm::Image* image);

  // optional .mpcomm.Voice voice = 6;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 6;
  inline const ::mpcomm::Voice& voice() const;
  inline ::mpcomm::Voice* mutable_voice();
  inline ::mpcomm::Voice* release_voice();
  inline void set_allocated_voice(::mpcomm::Voice* voice);

  // optional .mpcomm.MpVideo mpvideo = 7;
  inline bool has_mpvideo() const;
  inline void clear_mpvideo();
  static const int kMpvideoFieldNumber = 7;
  inline const ::mpcomm::MpVideo& mpvideo() const;
  inline ::mpcomm::MpVideo* mutable_mpvideo();
  inline ::mpcomm::MpVideo* release_mpvideo();
  inline void set_allocated_mpvideo(::mpcomm::MpVideo* mpvideo);

  // optional .mpcomm.MpNewsMsg mpnews = 8;
  inline bool has_mpnews() const;
  inline void clear_mpnews();
  static const int kMpnewsFieldNumber = 8;
  inline const ::mpcomm::MpNewsMsg& mpnews() const;
  inline ::mpcomm::MpNewsMsg* mutable_mpnews();
  inline ::mpcomm::MpNewsMsg* release_mpnews();
  inline void set_allocated_mpnews(::mpcomm::MpNewsMsg* mpnews);

  // optional .mpcomm.WxCard wxcard = 9;
  inline bool has_wxcard() const;
  inline void clear_wxcard();
  static const int kWxcardFieldNumber = 9;
  inline const ::mpcomm::WxCard& wxcard() const;
  inline ::mpcomm::WxCard* mutable_wxcard();
  inline ::mpcomm::WxCard* release_wxcard();
  inline void set_allocated_wxcard(::mpcomm::WxCard* wxcard);

  // @@protoc_insertion_point(class_scope:mpcomm.MassSendAllReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_voice();
  inline void clear_has_voice();
  inline void set_has_mpvideo();
  inline void clear_has_mpvideo();
  inline void set_has_mpnews();
  inline void clear_has_mpnews();
  inline void set_has_wxcard();
  inline void clear_has_wxcard();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::mpcomm::SendFilter* filter_;
  ::std::string* msgtype_;
  ::mpcomm::Text* text_;
  ::mpcomm::Image* image_;
  ::mpcomm::Voice* voice_;
  ::mpcomm::MpVideo* mpvideo_;
  ::mpcomm::MpNewsMsg* mpnews_;
  ::mpcomm::WxCard* wxcard_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassSendAllReq* default_instance_;
};
// -------------------------------------------------------------------

class MassSendAllResp : public ::google::protobuf::Message {
 public:
  MassSendAllResp();
  virtual ~MassSendAllResp();

  MassSendAllResp(const MassSendAllResp& from);

  inline MassSendAllResp& operator=(const MassSendAllResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassSendAllResp& default_instance();

  void Swap(MassSendAllResp* other);

  // implements Message ----------------------------------------------

  MassSendAllResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassSendAllResp& from);
  void MergeFrom(const MassSendAllResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 msg_id = 3;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  inline ::google::protobuf::uint64 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint64 value);

  // optional uint64 msg_data_id = 4;
  inline bool has_msg_data_id() const;
  inline void clear_msg_data_id();
  static const int kMsgDataIdFieldNumber = 4;
  inline ::google::protobuf::uint64 msg_data_id() const;
  inline void set_msg_data_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.MassSendAllResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_msg_data_id();
  inline void clear_has_msg_data_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 msg_id_;
  ::google::protobuf::uint64 msg_data_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassSendAllResp* default_instance_;
};
// -------------------------------------------------------------------

class MassSendReq : public ::google::protobuf::Message {
 public:
  MassSendReq();
  virtual ~MassSendReq();

  MassSendReq(const MassSendReq& from);

  inline MassSendReq& operator=(const MassSendReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassSendReq& default_instance();

  void Swap(MassSendReq* other);

  // implements Message ----------------------------------------------

  MassSendReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassSendReq& from);
  void MergeFrom(const MassSendReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // repeated string touser = 2;
  inline int touser_size() const;
  inline void clear_touser();
  static const int kTouserFieldNumber = 2;
  inline const ::std::string& touser(int index) const;
  inline ::std::string* mutable_touser(int index);
  inline void set_touser(int index, const ::std::string& value);
  inline void set_touser(int index, const char* value);
  inline void set_touser(int index, const char* value, size_t size);
  inline ::std::string* add_touser();
  inline void add_touser(const ::std::string& value);
  inline void add_touser(const char* value);
  inline void add_touser(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& touser() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_touser();

  // optional string msgtype = 3;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 3;
  inline const ::std::string& msgtype() const;
  inline void set_msgtype(const ::std::string& value);
  inline void set_msgtype(const char* value);
  inline void set_msgtype(const char* value, size_t size);
  inline ::std::string* mutable_msgtype();
  inline ::std::string* release_msgtype();
  inline void set_allocated_msgtype(::std::string* msgtype);

  // optional .mpcomm.Text text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::mpcomm::Text& text() const;
  inline ::mpcomm::Text* mutable_text();
  inline ::mpcomm::Text* release_text();
  inline void set_allocated_text(::mpcomm::Text* text);

  // optional .mpcomm.Image image = 5;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 5;
  inline const ::mpcomm::Image& image() const;
  inline ::mpcomm::Image* mutable_image();
  inline ::mpcomm::Image* release_image();
  inline void set_allocated_image(::mpcomm::Image* image);

  // optional .mpcomm.Voice voice = 6;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 6;
  inline const ::mpcomm::Voice& voice() const;
  inline ::mpcomm::Voice* mutable_voice();
  inline ::mpcomm::Voice* release_voice();
  inline void set_allocated_voice(::mpcomm::Voice* voice);

  // optional .mpcomm.MpNewsMsg mpnews = 8;
  inline bool has_mpnews() const;
  inline void clear_mpnews();
  static const int kMpnewsFieldNumber = 8;
  inline const ::mpcomm::MpNewsMsg& mpnews() const;
  inline ::mpcomm::MpNewsMsg* mutable_mpnews();
  inline ::mpcomm::MpNewsMsg* release_mpnews();
  inline void set_allocated_mpnews(::mpcomm::MpNewsMsg* mpnews);

  // optional .mpcomm.WxCard wxcard = 9;
  inline bool has_wxcard() const;
  inline void clear_wxcard();
  static const int kWxcardFieldNumber = 9;
  inline const ::mpcomm::WxCard& wxcard() const;
  inline ::mpcomm::WxCard* mutable_wxcard();
  inline ::mpcomm::WxCard* release_wxcard();
  inline void set_allocated_wxcard(::mpcomm::WxCard* wxcard);

  // optional .mpcomm.MpVideo mpvideo = 10;
  inline bool has_mpvideo() const;
  inline void clear_mpvideo();
  static const int kMpvideoFieldNumber = 10;
  inline const ::mpcomm::MpVideo& mpvideo() const;
  inline ::mpcomm::MpVideo* mutable_mpvideo();
  inline ::mpcomm::MpVideo* release_mpvideo();
  inline void set_allocated_mpvideo(::mpcomm::MpVideo* mpvideo);

  // @@protoc_insertion_point(class_scope:mpcomm.MassSendReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_voice();
  inline void clear_has_voice();
  inline void set_has_mpnews();
  inline void clear_has_mpnews();
  inline void set_has_wxcard();
  inline void clear_has_wxcard();
  inline void set_has_mpvideo();
  inline void clear_has_mpvideo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> touser_;
  ::std::string* msgtype_;
  ::mpcomm::Text* text_;
  ::mpcomm::Image* image_;
  ::mpcomm::Voice* voice_;
  ::mpcomm::MpNewsMsg* mpnews_;
  ::mpcomm::WxCard* wxcard_;
  ::mpcomm::MpVideo* mpvideo_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassSendReq* default_instance_;
};
// -------------------------------------------------------------------

class MassSendResp : public ::google::protobuf::Message {
 public:
  MassSendResp();
  virtual ~MassSendResp();

  MassSendResp(const MassSendResp& from);

  inline MassSendResp& operator=(const MassSendResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassSendResp& default_instance();

  void Swap(MassSendResp* other);

  // implements Message ----------------------------------------------

  MassSendResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassSendResp& from);
  void MergeFrom(const MassSendResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 msg_id = 3;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  inline ::google::protobuf::uint64 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint64 value);

  // optional uint64 msg_data_id = 4;
  inline bool has_msg_data_id() const;
  inline void clear_msg_data_id();
  static const int kMsgDataIdFieldNumber = 4;
  inline ::google::protobuf::uint64 msg_data_id() const;
  inline void set_msg_data_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.MassSendResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_msg_data_id();
  inline void clear_has_msg_data_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 msg_id_;
  ::google::protobuf::uint64 msg_data_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassSendResp* default_instance_;
};
// -------------------------------------------------------------------

class MassDeleteReq : public ::google::protobuf::Message {
 public:
  MassDeleteReq();
  virtual ~MassDeleteReq();

  MassDeleteReq(const MassDeleteReq& from);

  inline MassDeleteReq& operator=(const MassDeleteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassDeleteReq& default_instance();

  void Swap(MassDeleteReq* other);

  // implements Message ----------------------------------------------

  MassDeleteReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassDeleteReq& from);
  void MergeFrom(const MassDeleteReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional uint64 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint64 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.MassDeleteReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::uint64 msg_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassDeleteReq* default_instance_;
};
// -------------------------------------------------------------------

class MassDeleteResp : public ::google::protobuf::Message {
 public:
  MassDeleteResp();
  virtual ~MassDeleteResp();

  MassDeleteResp(const MassDeleteResp& from);

  inline MassDeleteResp& operator=(const MassDeleteResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassDeleteResp& default_instance();

  void Swap(MassDeleteResp* other);

  // implements Message ----------------------------------------------

  MassDeleteResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassDeleteResp& from);
  void MergeFrom(const MassDeleteResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 msg_id = 3;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  inline ::google::protobuf::uint64 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.MassDeleteResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 msg_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassDeleteResp* default_instance_;
};
// -------------------------------------------------------------------

class MassPreviewReq : public ::google::protobuf::Message {
 public:
  MassPreviewReq();
  virtual ~MassPreviewReq();

  MassPreviewReq(const MassPreviewReq& from);

  inline MassPreviewReq& operator=(const MassPreviewReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassPreviewReq& default_instance();

  void Swap(MassPreviewReq* other);

  // implements Message ----------------------------------------------

  MassPreviewReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassPreviewReq& from);
  void MergeFrom(const MassPreviewReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string touser = 2;
  inline bool has_touser() const;
  inline void clear_touser();
  static const int kTouserFieldNumber = 2;
  inline const ::std::string& touser() const;
  inline void set_touser(const ::std::string& value);
  inline void set_touser(const char* value);
  inline void set_touser(const char* value, size_t size);
  inline ::std::string* mutable_touser();
  inline ::std::string* release_touser();
  inline void set_allocated_touser(::std::string* touser);

  // optional string towxname = 3;
  inline bool has_towxname() const;
  inline void clear_towxname();
  static const int kTowxnameFieldNumber = 3;
  inline const ::std::string& towxname() const;
  inline void set_towxname(const ::std::string& value);
  inline void set_towxname(const char* value);
  inline void set_towxname(const char* value, size_t size);
  inline ::std::string* mutable_towxname();
  inline ::std::string* release_towxname();
  inline void set_allocated_towxname(::std::string* towxname);

  // optional string msgtype = 4;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 4;
  inline const ::std::string& msgtype() const;
  inline void set_msgtype(const ::std::string& value);
  inline void set_msgtype(const char* value);
  inline void set_msgtype(const char* value, size_t size);
  inline ::std::string* mutable_msgtype();
  inline ::std::string* release_msgtype();
  inline void set_allocated_msgtype(::std::string* msgtype);

  // optional .mpcomm.Text text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::mpcomm::Text& text() const;
  inline ::mpcomm::Text* mutable_text();
  inline ::mpcomm::Text* release_text();
  inline void set_allocated_text(::mpcomm::Text* text);

  // optional .mpcomm.Image image = 6;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 6;
  inline const ::mpcomm::Image& image() const;
  inline ::mpcomm::Image* mutable_image();
  inline ::mpcomm::Image* release_image();
  inline void set_allocated_image(::mpcomm::Image* image);

  // optional .mpcomm.Voice voice = 7;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 7;
  inline const ::mpcomm::Voice& voice() const;
  inline ::mpcomm::Voice* mutable_voice();
  inline ::mpcomm::Voice* release_voice();
  inline void set_allocated_voice(::mpcomm::Voice* voice);

  // optional .mpcomm.MpNewsMsg mpnews = 8;
  inline bool has_mpnews() const;
  inline void clear_mpnews();
  static const int kMpnewsFieldNumber = 8;
  inline const ::mpcomm::MpNewsMsg& mpnews() const;
  inline ::mpcomm::MpNewsMsg* mutable_mpnews();
  inline ::mpcomm::MpNewsMsg* release_mpnews();
  inline void set_allocated_mpnews(::mpcomm::MpNewsMsg* mpnews);

  // optional .mpcomm.WxCard wxcard = 9;
  inline bool has_wxcard() const;
  inline void clear_wxcard();
  static const int kWxcardFieldNumber = 9;
  inline const ::mpcomm::WxCard& wxcard() const;
  inline ::mpcomm::WxCard* mutable_wxcard();
  inline ::mpcomm::WxCard* release_wxcard();
  inline void set_allocated_wxcard(::mpcomm::WxCard* wxcard);

  // optional .mpcomm.MpVideo mpvideo = 10;
  inline bool has_mpvideo() const;
  inline void clear_mpvideo();
  static const int kMpvideoFieldNumber = 10;
  inline const ::mpcomm::MpVideo& mpvideo() const;
  inline ::mpcomm::MpVideo* mutable_mpvideo();
  inline ::mpcomm::MpVideo* release_mpvideo();
  inline void set_allocated_mpvideo(::mpcomm::MpVideo* mpvideo);

  // @@protoc_insertion_point(class_scope:mpcomm.MassPreviewReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_touser();
  inline void clear_has_touser();
  inline void set_has_towxname();
  inline void clear_has_towxname();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_voice();
  inline void clear_has_voice();
  inline void set_has_mpnews();
  inline void clear_has_mpnews();
  inline void set_has_wxcard();
  inline void clear_has_wxcard();
  inline void set_has_mpvideo();
  inline void clear_has_mpvideo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* touser_;
  ::std::string* towxname_;
  ::std::string* msgtype_;
  ::mpcomm::Text* text_;
  ::mpcomm::Image* image_;
  ::mpcomm::Voice* voice_;
  ::mpcomm::MpNewsMsg* mpnews_;
  ::mpcomm::WxCard* wxcard_;
  ::mpcomm::MpVideo* mpvideo_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassPreviewReq* default_instance_;
};
// -------------------------------------------------------------------

class MassPreviewResp : public ::google::protobuf::Message {
 public:
  MassPreviewResp();
  virtual ~MassPreviewResp();

  MassPreviewResp(const MassPreviewResp& from);

  inline MassPreviewResp& operator=(const MassPreviewResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassPreviewResp& default_instance();

  void Swap(MassPreviewResp* other);

  // implements Message ----------------------------------------------

  MassPreviewResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassPreviewResp& from);
  void MergeFrom(const MassPreviewResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.MassPreviewResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassPreviewResp* default_instance_;
};
// -------------------------------------------------------------------

class MassGetReq : public ::google::protobuf::Message {
 public:
  MassGetReq();
  virtual ~MassGetReq();

  MassGetReq(const MassGetReq& from);

  inline MassGetReq& operator=(const MassGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassGetReq& default_instance();

  void Swap(MassGetReq* other);

  // implements Message ----------------------------------------------

  MassGetReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassGetReq& from);
  void MergeFrom(const MassGetReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional uint64 msg_id = 2;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 2;
  inline ::google::protobuf::uint64 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.MassGetReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::uint64 msg_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassGetReq* default_instance_;
};
// -------------------------------------------------------------------

class MassGetResp : public ::google::protobuf::Message {
 public:
  MassGetResp();
  virtual ~MassGetResp();

  MassGetResp(const MassGetResp& from);

  inline MassGetResp& operator=(const MassGetResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MassGetResp& default_instance();

  void Swap(MassGetResp* other);

  // implements Message ----------------------------------------------

  MassGetResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MassGetResp& from);
  void MergeFrom(const MassGetResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 msg_id = 3;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 3;
  inline ::google::protobuf::uint64 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint64 value);

  // optional string msg_status = 4;
  inline bool has_msg_status() const;
  inline void clear_msg_status();
  static const int kMsgStatusFieldNumber = 4;
  inline const ::std::string& msg_status() const;
  inline void set_msg_status(const ::std::string& value);
  inline void set_msg_status(const char* value);
  inline void set_msg_status(const char* value, size_t size);
  inline ::std::string* mutable_msg_status();
  inline ::std::string* release_msg_status();
  inline void set_allocated_msg_status(::std::string* msg_status);

  // @@protoc_insertion_point(class_scope:mpcomm.MassGetResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_msg_status();
  inline void clear_has_msg_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 msg_id_;
  ::std::string* msg_status_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MassGetResp* default_instance_;
};
// -------------------------------------------------------------------

class SetIndustryReq : public ::google::protobuf::Message {
 public:
  SetIndustryReq();
  virtual ~SetIndustryReq();

  SetIndustryReq(const SetIndustryReq& from);

  inline SetIndustryReq& operator=(const SetIndustryReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetIndustryReq& default_instance();

  void Swap(SetIndustryReq* other);

  // implements Message ----------------------------------------------

  SetIndustryReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetIndustryReq& from);
  void MergeFrom(const SetIndustryReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string industry_id1 = 2;
  inline bool has_industry_id1() const;
  inline void clear_industry_id1();
  static const int kIndustryId1FieldNumber = 2;
  inline const ::std::string& industry_id1() const;
  inline void set_industry_id1(const ::std::string& value);
  inline void set_industry_id1(const char* value);
  inline void set_industry_id1(const char* value, size_t size);
  inline ::std::string* mutable_industry_id1();
  inline ::std::string* release_industry_id1();
  inline void set_allocated_industry_id1(::std::string* industry_id1);

  // optional string industry_id2 = 3;
  inline bool has_industry_id2() const;
  inline void clear_industry_id2();
  static const int kIndustryId2FieldNumber = 3;
  inline const ::std::string& industry_id2() const;
  inline void set_industry_id2(const ::std::string& value);
  inline void set_industry_id2(const char* value);
  inline void set_industry_id2(const char* value, size_t size);
  inline ::std::string* mutable_industry_id2();
  inline ::std::string* release_industry_id2();
  inline void set_allocated_industry_id2(::std::string* industry_id2);

  // @@protoc_insertion_point(class_scope:mpcomm.SetIndustryReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_industry_id1();
  inline void clear_has_industry_id1();
  inline void set_has_industry_id2();
  inline void clear_has_industry_id2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* industry_id1_;
  ::std::string* industry_id2_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static SetIndustryReq* default_instance_;
};
// -------------------------------------------------------------------

class SetIndustryResp : public ::google::protobuf::Message {
 public:
  SetIndustryResp();
  virtual ~SetIndustryResp();

  SetIndustryResp(const SetIndustryResp& from);

  inline SetIndustryResp& operator=(const SetIndustryResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetIndustryResp& default_instance();

  void Swap(SetIndustryResp* other);

  // implements Message ----------------------------------------------

  SetIndustryResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetIndustryResp& from);
  void MergeFrom(const SetIndustryResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.SetIndustryResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static SetIndustryResp* default_instance_;
};
// -------------------------------------------------------------------

class GetIndustryReq : public ::google::protobuf::Message {
 public:
  GetIndustryReq();
  virtual ~GetIndustryReq();

  GetIndustryReq(const GetIndustryReq& from);

  inline GetIndustryReq& operator=(const GetIndustryReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIndustryReq& default_instance();

  void Swap(GetIndustryReq* other);

  // implements Message ----------------------------------------------

  GetIndustryReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetIndustryReq& from);
  void MergeFrom(const GetIndustryReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:mpcomm.GetIndustryReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetIndustryReq* default_instance_;
};
// -------------------------------------------------------------------

class Industry : public ::google::protobuf::Message {
 public:
  Industry();
  virtual ~Industry();

  Industry(const Industry& from);

  inline Industry& operator=(const Industry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Industry& default_instance();

  void Swap(Industry* other);

  // implements Message ----------------------------------------------

  Industry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Industry& from);
  void MergeFrom(const Industry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string first_class = 1;
  inline bool has_first_class() const;
  inline void clear_first_class();
  static const int kFirstClassFieldNumber = 1;
  inline const ::std::string& first_class() const;
  inline void set_first_class(const ::std::string& value);
  inline void set_first_class(const char* value);
  inline void set_first_class(const char* value, size_t size);
  inline ::std::string* mutable_first_class();
  inline ::std::string* release_first_class();
  inline void set_allocated_first_class(::std::string* first_class);

  // optional string second_class = 2;
  inline bool has_second_class() const;
  inline void clear_second_class();
  static const int kSecondClassFieldNumber = 2;
  inline const ::std::string& second_class() const;
  inline void set_second_class(const ::std::string& value);
  inline void set_second_class(const char* value);
  inline void set_second_class(const char* value, size_t size);
  inline ::std::string* mutable_second_class();
  inline ::std::string* release_second_class();
  inline void set_allocated_second_class(::std::string* second_class);

  // @@protoc_insertion_point(class_scope:mpcomm.Industry)
 private:
  inline void set_has_first_class();
  inline void clear_has_first_class();
  inline void set_has_second_class();
  inline void clear_has_second_class();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* first_class_;
  ::std::string* second_class_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Industry* default_instance_;
};
// -------------------------------------------------------------------

class GetIndustryResp : public ::google::protobuf::Message {
 public:
  GetIndustryResp();
  virtual ~GetIndustryResp();

  GetIndustryResp(const GetIndustryResp& from);

  inline GetIndustryResp& operator=(const GetIndustryResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIndustryResp& default_instance();

  void Swap(GetIndustryResp* other);

  // implements Message ----------------------------------------------

  GetIndustryResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetIndustryResp& from);
  void MergeFrom(const GetIndustryResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional .mpcomm.Industry primary_industry = 3;
  inline bool has_primary_industry() const;
  inline void clear_primary_industry();
  static const int kPrimaryIndustryFieldNumber = 3;
  inline const ::mpcomm::Industry& primary_industry() const;
  inline ::mpcomm::Industry* mutable_primary_industry();
  inline ::mpcomm::Industry* release_primary_industry();
  inline void set_allocated_primary_industry(::mpcomm::Industry* primary_industry);

  // optional .mpcomm.Industry secondary_industry = 4;
  inline bool has_secondary_industry() const;
  inline void clear_secondary_industry();
  static const int kSecondaryIndustryFieldNumber = 4;
  inline const ::mpcomm::Industry& secondary_industry() const;
  inline ::mpcomm::Industry* mutable_secondary_industry();
  inline ::mpcomm::Industry* release_secondary_industry();
  inline void set_allocated_secondary_industry(::mpcomm::Industry* secondary_industry);

  // @@protoc_insertion_point(class_scope:mpcomm.GetIndustryResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_primary_industry();
  inline void clear_has_primary_industry();
  inline void set_has_secondary_industry();
  inline void clear_has_secondary_industry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::mpcomm::Industry* primary_industry_;
  ::mpcomm::Industry* secondary_industry_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetIndustryResp* default_instance_;
};
// -------------------------------------------------------------------

class AddTemplateReq : public ::google::protobuf::Message {
 public:
  AddTemplateReq();
  virtual ~AddTemplateReq();

  AddTemplateReq(const AddTemplateReq& from);

  inline AddTemplateReq& operator=(const AddTemplateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddTemplateReq& default_instance();

  void Swap(AddTemplateReq* other);

  // implements Message ----------------------------------------------

  AddTemplateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddTemplateReq& from);
  void MergeFrom(const AddTemplateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string template_id_short = 2;
  inline bool has_template_id_short() const;
  inline void clear_template_id_short();
  static const int kTemplateIdShortFieldNumber = 2;
  inline const ::std::string& template_id_short() const;
  inline void set_template_id_short(const ::std::string& value);
  inline void set_template_id_short(const char* value);
  inline void set_template_id_short(const char* value, size_t size);
  inline ::std::string* mutable_template_id_short();
  inline ::std::string* release_template_id_short();
  inline void set_allocated_template_id_short(::std::string* template_id_short);

  // @@protoc_insertion_point(class_scope:mpcomm.AddTemplateReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_template_id_short();
  inline void clear_has_template_id_short();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* template_id_short_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AddTemplateReq* default_instance_;
};
// -------------------------------------------------------------------

class AddTemplateResp : public ::google::protobuf::Message {
 public:
  AddTemplateResp();
  virtual ~AddTemplateResp();

  AddTemplateResp(const AddTemplateResp& from);

  inline AddTemplateResp& operator=(const AddTemplateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddTemplateResp& default_instance();

  void Swap(AddTemplateResp* other);

  // implements Message ----------------------------------------------

  AddTemplateResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddTemplateResp& from);
  void MergeFrom(const AddTemplateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional string template_id = 3;
  inline bool has_template_id() const;
  inline void clear_template_id();
  static const int kTemplateIdFieldNumber = 3;
  inline const ::std::string& template_id() const;
  inline void set_template_id(const ::std::string& value);
  inline void set_template_id(const char* value);
  inline void set_template_id(const char* value, size_t size);
  inline ::std::string* mutable_template_id();
  inline ::std::string* release_template_id();
  inline void set_allocated_template_id(::std::string* template_id);

  // @@protoc_insertion_point(class_scope:mpcomm.AddTemplateResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_template_id();
  inline void clear_has_template_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::std::string* template_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AddTemplateResp* default_instance_;
};
// -------------------------------------------------------------------

class GetAllPrivateTemplateReq : public ::google::protobuf::Message {
 public:
  GetAllPrivateTemplateReq();
  virtual ~GetAllPrivateTemplateReq();

  GetAllPrivateTemplateReq(const GetAllPrivateTemplateReq& from);

  inline GetAllPrivateTemplateReq& operator=(const GetAllPrivateTemplateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllPrivateTemplateReq& default_instance();

  void Swap(GetAllPrivateTemplateReq* other);

  // implements Message ----------------------------------------------

  GetAllPrivateTemplateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAllPrivateTemplateReq& from);
  void MergeFrom(const GetAllPrivateTemplateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:mpcomm.GetAllPrivateTemplateReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetAllPrivateTemplateReq* default_instance_;
};
// -------------------------------------------------------------------

class PrivateTemplate : public ::google::protobuf::Message {
 public:
  PrivateTemplate();
  virtual ~PrivateTemplate();

  PrivateTemplate(const PrivateTemplate& from);

  inline PrivateTemplate& operator=(const PrivateTemplate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateTemplate& default_instance();

  void Swap(PrivateTemplate* other);

  // implements Message ----------------------------------------------

  PrivateTemplate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrivateTemplate& from);
  void MergeFrom(const PrivateTemplate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string template_id = 1;
  inline bool has_template_id() const;
  inline void clear_template_id();
  static const int kTemplateIdFieldNumber = 1;
  inline const ::std::string& template_id() const;
  inline void set_template_id(const ::std::string& value);
  inline void set_template_id(const char* value);
  inline void set_template_id(const char* value, size_t size);
  inline ::std::string* mutable_template_id();
  inline ::std::string* release_template_id();
  inline void set_allocated_template_id(::std::string* template_id);

  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string primary_industry = 3;
  inline bool has_primary_industry() const;
  inline void clear_primary_industry();
  static const int kPrimaryIndustryFieldNumber = 3;
  inline const ::std::string& primary_industry() const;
  inline void set_primary_industry(const ::std::string& value);
  inline void set_primary_industry(const char* value);
  inline void set_primary_industry(const char* value, size_t size);
  inline ::std::string* mutable_primary_industry();
  inline ::std::string* release_primary_industry();
  inline void set_allocated_primary_industry(::std::string* primary_industry);

  // optional string deputy_industry = 4;
  inline bool has_deputy_industry() const;
  inline void clear_deputy_industry();
  static const int kDeputyIndustryFieldNumber = 4;
  inline const ::std::string& deputy_industry() const;
  inline void set_deputy_industry(const ::std::string& value);
  inline void set_deputy_industry(const char* value);
  inline void set_deputy_industry(const char* value, size_t size);
  inline ::std::string* mutable_deputy_industry();
  inline ::std::string* release_deputy_industry();
  inline void set_allocated_deputy_industry(::std::string* deputy_industry);

  // optional string content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string example = 6;
  inline bool has_example() const;
  inline void clear_example();
  static const int kExampleFieldNumber = 6;
  inline const ::std::string& example() const;
  inline void set_example(const ::std::string& value);
  inline void set_example(const char* value);
  inline void set_example(const char* value, size_t size);
  inline ::std::string* mutable_example();
  inline ::std::string* release_example();
  inline void set_allocated_example(::std::string* example);

  // @@protoc_insertion_point(class_scope:mpcomm.PrivateTemplate)
 private:
  inline void set_has_template_id();
  inline void clear_has_template_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_primary_industry();
  inline void clear_has_primary_industry();
  inline void set_has_deputy_industry();
  inline void clear_has_deputy_industry();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_example();
  inline void clear_has_example();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* template_id_;
  ::std::string* title_;
  ::std::string* primary_industry_;
  ::std::string* deputy_industry_;
  ::std::string* content_;
  ::std::string* example_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static PrivateTemplate* default_instance_;
};
// -------------------------------------------------------------------

class GetAllPrivateTemplateResp : public ::google::protobuf::Message {
 public:
  GetAllPrivateTemplateResp();
  virtual ~GetAllPrivateTemplateResp();

  GetAllPrivateTemplateResp(const GetAllPrivateTemplateResp& from);

  inline GetAllPrivateTemplateResp& operator=(const GetAllPrivateTemplateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllPrivateTemplateResp& default_instance();

  void Swap(GetAllPrivateTemplateResp* other);

  // implements Message ----------------------------------------------

  GetAllPrivateTemplateResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAllPrivateTemplateResp& from);
  void MergeFrom(const GetAllPrivateTemplateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // repeated .mpcomm.PrivateTemplate template_list = 3;
  inline int template_list_size() const;
  inline void clear_template_list();
  static const int kTemplateListFieldNumber = 3;
  inline const ::mpcomm::PrivateTemplate& template_list(int index) const;
  inline ::mpcomm::PrivateTemplate* mutable_template_list(int index);
  inline ::mpcomm::PrivateTemplate* add_template_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::PrivateTemplate >&
      template_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::PrivateTemplate >*
      mutable_template_list();

  // @@protoc_insertion_point(class_scope:mpcomm.GetAllPrivateTemplateResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::PrivateTemplate > template_list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetAllPrivateTemplateResp* default_instance_;
};
// -------------------------------------------------------------------

class DelPrivateTemplateReq : public ::google::protobuf::Message {
 public:
  DelPrivateTemplateReq();
  virtual ~DelPrivateTemplateReq();

  DelPrivateTemplateReq(const DelPrivateTemplateReq& from);

  inline DelPrivateTemplateReq& operator=(const DelPrivateTemplateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelPrivateTemplateReq& default_instance();

  void Swap(DelPrivateTemplateReq* other);

  // implements Message ----------------------------------------------

  DelPrivateTemplateReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelPrivateTemplateReq& from);
  void MergeFrom(const DelPrivateTemplateReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string template_id = 2;
  inline bool has_template_id() const;
  inline void clear_template_id();
  static const int kTemplateIdFieldNumber = 2;
  inline const ::std::string& template_id() const;
  inline void set_template_id(const ::std::string& value);
  inline void set_template_id(const char* value);
  inline void set_template_id(const char* value, size_t size);
  inline ::std::string* mutable_template_id();
  inline ::std::string* release_template_id();
  inline void set_allocated_template_id(::std::string* template_id);

  // @@protoc_insertion_point(class_scope:mpcomm.DelPrivateTemplateReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_template_id();
  inline void clear_has_template_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* template_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DelPrivateTemplateReq* default_instance_;
};
// -------------------------------------------------------------------

class DelPrivateTemplateResp : public ::google::protobuf::Message {
 public:
  DelPrivateTemplateResp();
  virtual ~DelPrivateTemplateResp();

  DelPrivateTemplateResp(const DelPrivateTemplateResp& from);

  inline DelPrivateTemplateResp& operator=(const DelPrivateTemplateResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelPrivateTemplateResp& default_instance();

  void Swap(DelPrivateTemplateResp* other);

  // implements Message ----------------------------------------------

  DelPrivateTemplateResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelPrivateTemplateResp& from);
  void MergeFrom(const DelPrivateTemplateResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.DelPrivateTemplateResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DelPrivateTemplateResp* default_instance_;
};
// -------------------------------------------------------------------

class Json : public ::google::protobuf::Message {
 public:
  Json();
  virtual ~Json();

  Json(const Json& from);

  inline Json& operator=(const Json& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Json& default_instance();

  void Swap(Json* other);

  // implements Message ----------------------------------------------

  Json* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Json& from);
  void MergeFrom(const Json& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:mpcomm.Json)
 private:
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* content_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Json* default_instance_;
};
// -------------------------------------------------------------------

class SendTemplateMessageReq : public ::google::protobuf::Message {
 public:
  SendTemplateMessageReq();
  virtual ~SendTemplateMessageReq();

  SendTemplateMessageReq(const SendTemplateMessageReq& from);

  inline SendTemplateMessageReq& operator=(const SendTemplateMessageReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendTemplateMessageReq& default_instance();

  void Swap(SendTemplateMessageReq* other);

  // implements Message ----------------------------------------------

  SendTemplateMessageReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendTemplateMessageReq& from);
  void MergeFrom(const SendTemplateMessageReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string touser = 2;
  inline bool has_touser() const;
  inline void clear_touser();
  static const int kTouserFieldNumber = 2;
  inline const ::std::string& touser() const;
  inline void set_touser(const ::std::string& value);
  inline void set_touser(const char* value);
  inline void set_touser(const char* value, size_t size);
  inline ::std::string* mutable_touser();
  inline ::std::string* release_touser();
  inline void set_allocated_touser(::std::string* touser);

  // optional string template_id = 3;
  inline bool has_template_id() const;
  inline void clear_template_id();
  static const int kTemplateIdFieldNumber = 3;
  inline const ::std::string& template_id() const;
  inline void set_template_id(const ::std::string& value);
  inline void set_template_id(const char* value);
  inline void set_template_id(const char* value, size_t size);
  inline ::std::string* mutable_template_id();
  inline ::std::string* release_template_id();
  inline void set_allocated_template_id(::std::string* template_id);

  // optional string url = 4;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 4;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional .mpcomm.Json data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::mpcomm::Json& data() const;
  inline ::mpcomm::Json* mutable_data();
  inline ::mpcomm::Json* release_data();
  inline void set_allocated_data(::mpcomm::Json* data);

  // @@protoc_insertion_point(class_scope:mpcomm.SendTemplateMessageReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_touser();
  inline void clear_has_touser();
  inline void set_has_template_id();
  inline void clear_has_template_id();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* touser_;
  ::std::string* template_id_;
  ::std::string* url_;
  ::mpcomm::Json* data_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static SendTemplateMessageReq* default_instance_;
};
// -------------------------------------------------------------------

class SendTemplateMessageResp : public ::google::protobuf::Message {
 public:
  SendTemplateMessageResp();
  virtual ~SendTemplateMessageResp();

  SendTemplateMessageResp(const SendTemplateMessageResp& from);

  inline SendTemplateMessageResp& operator=(const SendTemplateMessageResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendTemplateMessageResp& default_instance();

  void Swap(SendTemplateMessageResp* other);

  // implements Message ----------------------------------------------

  SendTemplateMessageResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendTemplateMessageResp& from);
  void MergeFrom(const SendTemplateMessageResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 msgid = 3;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgidFieldNumber = 3;
  inline ::google::protobuf::uint64 msgid() const;
  inline void set_msgid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.SendTemplateMessageResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_msgid();
  inline void clear_has_msgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 msgid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static SendTemplateMessageResp* default_instance_;
};
// -------------------------------------------------------------------

class MediaFile : public ::google::protobuf::Message {
 public:
  MediaFile();
  virtual ~MediaFile();

  MediaFile(const MediaFile& from);

  inline MediaFile& operator=(const MediaFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MediaFile& default_instance();

  void Swap(MediaFile* other);

  // implements Message ----------------------------------------------

  MediaFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MediaFile& from);
  void MergeFrom(const MediaFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional string buffer = 2;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 2;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const char* value, size_t size);
  inline ::std::string* mutable_buffer();
  inline ::std::string* release_buffer();
  inline void set_allocated_buffer(::std::string* buffer);

  // @@protoc_insertion_point(class_scope:mpcomm.MediaFile)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_buffer();
  inline void clear_has_buffer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* file_name_;
  ::std::string* buffer_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MediaFile* default_instance_;
};
// -------------------------------------------------------------------

class NewsItem : public ::google::protobuf::Message {
 public:
  NewsItem();
  virtual ~NewsItem();

  NewsItem(const NewsItem& from);

  inline NewsItem& operator=(const NewsItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewsItem& default_instance();

  void Swap(NewsItem* other);

  // implements Message ----------------------------------------------

  NewsItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewsItem& from);
  void MergeFrom(const NewsItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string author = 2;
  inline bool has_author() const;
  inline void clear_author();
  static const int kAuthorFieldNumber = 2;
  inline const ::std::string& author() const;
  inline void set_author(const ::std::string& value);
  inline void set_author(const char* value);
  inline void set_author(const char* value, size_t size);
  inline ::std::string* mutable_author();
  inline ::std::string* release_author();
  inline void set_allocated_author(::std::string* author);

  // optional string digest = 3;
  inline bool has_digest() const;
  inline void clear_digest();
  static const int kDigestFieldNumber = 3;
  inline const ::std::string& digest() const;
  inline void set_digest(const ::std::string& value);
  inline void set_digest(const char* value);
  inline void set_digest(const char* value, size_t size);
  inline ::std::string* mutable_digest();
  inline ::std::string* release_digest();
  inline void set_allocated_digest(::std::string* digest);

  // optional string content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string content_source_url = 5;
  inline bool has_content_source_url() const;
  inline void clear_content_source_url();
  static const int kContentSourceUrlFieldNumber = 5;
  inline const ::std::string& content_source_url() const;
  inline void set_content_source_url(const ::std::string& value);
  inline void set_content_source_url(const char* value);
  inline void set_content_source_url(const char* value, size_t size);
  inline ::std::string* mutable_content_source_url();
  inline ::std::string* release_content_source_url();
  inline void set_allocated_content_source_url(::std::string* content_source_url);

  // optional string thumb_media_id = 6;
  inline bool has_thumb_media_id() const;
  inline void clear_thumb_media_id();
  static const int kThumbMediaIdFieldNumber = 6;
  inline const ::std::string& thumb_media_id() const;
  inline void set_thumb_media_id(const ::std::string& value);
  inline void set_thumb_media_id(const char* value);
  inline void set_thumb_media_id(const char* value, size_t size);
  inline ::std::string* mutable_thumb_media_id();
  inline ::std::string* release_thumb_media_id();
  inline void set_allocated_thumb_media_id(::std::string* thumb_media_id);

  // optional int64 show_cover_pic = 7;
  inline bool has_show_cover_pic() const;
  inline void clear_show_cover_pic();
  static const int kShowCoverPicFieldNumber = 7;
  inline ::google::protobuf::int64 show_cover_pic() const;
  inline void set_show_cover_pic(::google::protobuf::int64 value);

  // optional string url = 8;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 8;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string thumb_url = 9;
  inline bool has_thumb_url() const;
  inline void clear_thumb_url();
  static const int kThumbUrlFieldNumber = 9;
  inline const ::std::string& thumb_url() const;
  inline void set_thumb_url(const ::std::string& value);
  inline void set_thumb_url(const char* value);
  inline void set_thumb_url(const char* value, size_t size);
  inline ::std::string* mutable_thumb_url();
  inline ::std::string* release_thumb_url();
  inline void set_allocated_thumb_url(::std::string* thumb_url);

  // @@protoc_insertion_point(class_scope:mpcomm.NewsItem)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_author();
  inline void clear_has_author();
  inline void set_has_digest();
  inline void clear_has_digest();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_content_source_url();
  inline void clear_has_content_source_url();
  inline void set_has_thumb_media_id();
  inline void clear_has_thumb_media_id();
  inline void set_has_show_cover_pic();
  inline void clear_has_show_cover_pic();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_thumb_url();
  inline void clear_has_thumb_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* author_;
  ::std::string* digest_;
  ::std::string* content_;
  ::std::string* content_source_url_;
  ::std::string* thumb_media_id_;
  ::google::protobuf::int64 show_cover_pic_;
  ::std::string* url_;
  ::std::string* thumb_url_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static NewsItem* default_instance_;
};
// -------------------------------------------------------------------

class NewsInfo : public ::google::protobuf::Message {
 public:
  NewsInfo();
  virtual ~NewsInfo();

  NewsInfo(const NewsInfo& from);

  inline NewsInfo& operator=(const NewsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewsInfo& default_instance();

  void Swap(NewsInfo* other);

  // implements Message ----------------------------------------------

  NewsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewsInfo& from);
  void MergeFrom(const NewsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpcomm.NewsItem news_item = 1;
  inline int news_item_size() const;
  inline void clear_news_item();
  static const int kNewsItemFieldNumber = 1;
  inline const ::mpcomm::NewsItem& news_item(int index) const;
  inline ::mpcomm::NewsItem* mutable_news_item(int index);
  inline ::mpcomm::NewsItem* add_news_item();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >&
      news_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >*
      mutable_news_item();

  // @@protoc_insertion_point(class_scope:mpcomm.NewsInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem > news_item_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static NewsInfo* default_instance_;
};
// -------------------------------------------------------------------

class UploadImgReq : public ::google::protobuf::Message {
 public:
  UploadImgReq();
  virtual ~UploadImgReq();

  UploadImgReq(const UploadImgReq& from);

  inline UploadImgReq& operator=(const UploadImgReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadImgReq& default_instance();

  void Swap(UploadImgReq* other);

  // implements Message ----------------------------------------------

  UploadImgReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadImgReq& from);
  void MergeFrom(const UploadImgReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional .mpcomm.MediaFile media = 2;
  inline bool has_media() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 2;
  inline const ::mpcomm::MediaFile& media() const;
  inline ::mpcomm::MediaFile* mutable_media();
  inline ::mpcomm::MediaFile* release_media();
  inline void set_allocated_media(::mpcomm::MediaFile* media);

  // @@protoc_insertion_point(class_scope:mpcomm.UploadImgReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_media();
  inline void clear_has_media();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::mpcomm::MediaFile* media_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UploadImgReq* default_instance_;
};
// -------------------------------------------------------------------

class UploadImgResp : public ::google::protobuf::Message {
 public:
  UploadImgResp();
  virtual ~UploadImgResp();

  UploadImgResp(const UploadImgResp& from);

  inline UploadImgResp& operator=(const UploadImgResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadImgResp& default_instance();

  void Swap(UploadImgResp* other);

  // implements Message ----------------------------------------------

  UploadImgResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadImgResp& from);
  void MergeFrom(const UploadImgResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:mpcomm.UploadImgResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::std::string* url_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UploadImgResp* default_instance_;
};
// -------------------------------------------------------------------

class UploadNewsReq : public ::google::protobuf::Message {
 public:
  UploadNewsReq();
  virtual ~UploadNewsReq();

  UploadNewsReq(const UploadNewsReq& from);

  inline UploadNewsReq& operator=(const UploadNewsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadNewsReq& default_instance();

  void Swap(UploadNewsReq* other);

  // implements Message ----------------------------------------------

  UploadNewsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadNewsReq& from);
  void MergeFrom(const UploadNewsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // repeated .mpcomm.NewsItem articles = 2;
  inline int articles_size() const;
  inline void clear_articles();
  static const int kArticlesFieldNumber = 2;
  inline const ::mpcomm::NewsItem& articles(int index) const;
  inline ::mpcomm::NewsItem* mutable_articles(int index);
  inline ::mpcomm::NewsItem* add_articles();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >&
      articles() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >*
      mutable_articles();

  // @@protoc_insertion_point(class_scope:mpcomm.UploadNewsReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem > articles_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UploadNewsReq* default_instance_;
};
// -------------------------------------------------------------------

class UploadNewsResp : public ::google::protobuf::Message {
 public:
  UploadNewsResp();
  virtual ~UploadNewsResp();

  UploadNewsResp(const UploadNewsResp& from);

  inline UploadNewsResp& operator=(const UploadNewsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadNewsResp& default_instance();

  void Swap(UploadNewsResp* other);

  // implements Message ----------------------------------------------

  UploadNewsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadNewsResp& from);
  void MergeFrom(const UploadNewsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string media_id = 4;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 4;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // optional uint64 created_at = 5;
  inline bool has_created_at() const;
  inline void clear_created_at();
  static const int kCreatedAtFieldNumber = 5;
  inline ::google::protobuf::uint64 created_at() const;
  inline void set_created_at(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.UploadNewsResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_media_id();
  inline void clear_has_media_id();
  inline void set_has_created_at();
  inline void clear_has_created_at();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::std::string* type_;
  ::std::string* media_id_;
  ::google::protobuf::uint64 created_at_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UploadNewsResp* default_instance_;
};
// -------------------------------------------------------------------

class UploadMediaReq : public ::google::protobuf::Message {
 public:
  UploadMediaReq();
  virtual ~UploadMediaReq();

  UploadMediaReq(const UploadMediaReq& from);

  inline UploadMediaReq& operator=(const UploadMediaReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadMediaReq& default_instance();

  void Swap(UploadMediaReq* other);

  // implements Message ----------------------------------------------

  UploadMediaReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadMediaReq& from);
  void MergeFrom(const UploadMediaReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional .mpcomm.MediaFile media = 3;
  inline bool has_media() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 3;
  inline const ::mpcomm::MediaFile& media() const;
  inline ::mpcomm::MediaFile* mutable_media();
  inline ::mpcomm::MediaFile* release_media();
  inline void set_allocated_media(::mpcomm::MediaFile* media);

  // @@protoc_insertion_point(class_scope:mpcomm.UploadMediaReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_media();
  inline void clear_has_media();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* type_;
  ::mpcomm::MediaFile* media_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UploadMediaReq* default_instance_;
};
// -------------------------------------------------------------------

class UploadMediaResp : public ::google::protobuf::Message {
 public:
  UploadMediaResp();
  virtual ~UploadMediaResp();

  UploadMediaResp(const UploadMediaResp& from);

  inline UploadMediaResp& operator=(const UploadMediaResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadMediaResp& default_instance();

  void Swap(UploadMediaResp* other);

  // implements Message ----------------------------------------------

  UploadMediaResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadMediaResp& from);
  void MergeFrom(const UploadMediaResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string media_id = 4;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 4;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // optional uint64 created_at = 5;
  inline bool has_created_at() const;
  inline void clear_created_at();
  static const int kCreatedAtFieldNumber = 5;
  inline ::google::protobuf::uint64 created_at() const;
  inline void set_created_at(::google::protobuf::uint64 value);

  // optional string thumb_media_id = 6;
  inline bool has_thumb_media_id() const;
  inline void clear_thumb_media_id();
  static const int kThumbMediaIdFieldNumber = 6;
  inline const ::std::string& thumb_media_id() const;
  inline void set_thumb_media_id(const ::std::string& value);
  inline void set_thumb_media_id(const char* value);
  inline void set_thumb_media_id(const char* value, size_t size);
  inline ::std::string* mutable_thumb_media_id();
  inline ::std::string* release_thumb_media_id();
  inline void set_allocated_thumb_media_id(::std::string* thumb_media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.UploadMediaResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_media_id();
  inline void clear_has_media_id();
  inline void set_has_created_at();
  inline void clear_has_created_at();
  inline void set_has_thumb_media_id();
  inline void clear_has_thumb_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::std::string* type_;
  ::std::string* media_id_;
  ::google::protobuf::uint64 created_at_;
  ::std::string* thumb_media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UploadMediaResp* default_instance_;
};
// -------------------------------------------------------------------

class GetMediaReq : public ::google::protobuf::Message {
 public:
  GetMediaReq();
  virtual ~GetMediaReq();

  GetMediaReq(const GetMediaReq& from);

  inline GetMediaReq& operator=(const GetMediaReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMediaReq& default_instance();

  void Swap(GetMediaReq* other);

  // implements Message ----------------------------------------------

  GetMediaReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMediaReq& from);
  void MergeFrom(const GetMediaReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string media_id = 2;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 2;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.GetMediaReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_media_id();
  inline void clear_has_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetMediaReq* default_instance_;
};
// -------------------------------------------------------------------

class GetMediaResp : public ::google::protobuf::Message {
 public:
  GetMediaResp();
  virtual ~GetMediaResp();

  GetMediaResp(const GetMediaResp& from);

  inline GetMediaResp& operator=(const GetMediaResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMediaResp& default_instance();

  void Swap(GetMediaResp* other);

  // implements Message ----------------------------------------------

  GetMediaResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMediaResp& from);
  void MergeFrom(const GetMediaResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional .mpcomm.MediaFile media = 3;
  inline bool has_media() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 3;
  inline const ::mpcomm::MediaFile& media() const;
  inline ::mpcomm::MediaFile* mutable_media();
  inline ::mpcomm::MediaFile* release_media();
  inline void set_allocated_media(::mpcomm::MediaFile* media);

  // @@protoc_insertion_point(class_scope:mpcomm.GetMediaResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_media();
  inline void clear_has_media();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::mpcomm::MediaFile* media_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetMediaResp* default_instance_;
};
// -------------------------------------------------------------------

class MaterialVideoDescription : public ::google::protobuf::Message {
 public:
  MaterialVideoDescription();
  virtual ~MaterialVideoDescription();

  MaterialVideoDescription(const MaterialVideoDescription& from);

  inline MaterialVideoDescription& operator=(const MaterialVideoDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaterialVideoDescription& default_instance();

  void Swap(MaterialVideoDescription* other);

  // implements Message ----------------------------------------------

  MaterialVideoDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaterialVideoDescription& from);
  void MergeFrom(const MaterialVideoDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string introduction = 2;
  inline bool has_introduction() const;
  inline void clear_introduction();
  static const int kIntroductionFieldNumber = 2;
  inline const ::std::string& introduction() const;
  inline void set_introduction(const ::std::string& value);
  inline void set_introduction(const char* value);
  inline void set_introduction(const char* value, size_t size);
  inline ::std::string* mutable_introduction();
  inline ::std::string* release_introduction();
  inline void set_allocated_introduction(::std::string* introduction);

  // @@protoc_insertion_point(class_scope:mpcomm.MaterialVideoDescription)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_introduction();
  inline void clear_has_introduction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  ::std::string* introduction_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MaterialVideoDescription* default_instance_;
};
// -------------------------------------------------------------------

class AddNewsMaterialReq : public ::google::protobuf::Message {
 public:
  AddNewsMaterialReq();
  virtual ~AddNewsMaterialReq();

  AddNewsMaterialReq(const AddNewsMaterialReq& from);

  inline AddNewsMaterialReq& operator=(const AddNewsMaterialReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddNewsMaterialReq& default_instance();

  void Swap(AddNewsMaterialReq* other);

  // implements Message ----------------------------------------------

  AddNewsMaterialReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddNewsMaterialReq& from);
  void MergeFrom(const AddNewsMaterialReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // repeated .mpcomm.NewsItem articles = 2;
  inline int articles_size() const;
  inline void clear_articles();
  static const int kArticlesFieldNumber = 2;
  inline const ::mpcomm::NewsItem& articles(int index) const;
  inline ::mpcomm::NewsItem* mutable_articles(int index);
  inline ::mpcomm::NewsItem* add_articles();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >&
      articles() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >*
      mutable_articles();

  // @@protoc_insertion_point(class_scope:mpcomm.AddNewsMaterialReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem > articles_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AddNewsMaterialReq* default_instance_;
};
// -------------------------------------------------------------------

class AddNewsMaterialResp : public ::google::protobuf::Message {
 public:
  AddNewsMaterialResp();
  virtual ~AddNewsMaterialResp();

  AddNewsMaterialResp(const AddNewsMaterialResp& from);

  inline AddNewsMaterialResp& operator=(const AddNewsMaterialResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddNewsMaterialResp& default_instance();

  void Swap(AddNewsMaterialResp* other);

  // implements Message ----------------------------------------------

  AddNewsMaterialResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddNewsMaterialResp& from);
  void MergeFrom(const AddNewsMaterialResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional string media_id = 3;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 3;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.AddNewsMaterialResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_media_id();
  inline void clear_has_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::std::string* media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AddNewsMaterialResp* default_instance_;
};
// -------------------------------------------------------------------

class AddMaterialReq : public ::google::protobuf::Message {
 public:
  AddMaterialReq();
  virtual ~AddMaterialReq();

  AddMaterialReq(const AddMaterialReq& from);

  inline AddMaterialReq& operator=(const AddMaterialReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddMaterialReq& default_instance();

  void Swap(AddMaterialReq* other);

  // implements Message ----------------------------------------------

  AddMaterialReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddMaterialReq& from);
  void MergeFrom(const AddMaterialReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional .mpcomm.MediaFile media = 3;
  inline bool has_media() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 3;
  inline const ::mpcomm::MediaFile& media() const;
  inline ::mpcomm::MediaFile* mutable_media();
  inline ::mpcomm::MediaFile* release_media();
  inline void set_allocated_media(::mpcomm::MediaFile* media);

  // optional .mpcomm.MaterialVideoDescription description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::mpcomm::MaterialVideoDescription& description() const;
  inline ::mpcomm::MaterialVideoDescription* mutable_description();
  inline ::mpcomm::MaterialVideoDescription* release_description();
  inline void set_allocated_description(::mpcomm::MaterialVideoDescription* description);

  // @@protoc_insertion_point(class_scope:mpcomm.AddMaterialReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_media();
  inline void clear_has_media();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* type_;
  ::mpcomm::MediaFile* media_;
  ::mpcomm::MaterialVideoDescription* description_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AddMaterialReq* default_instance_;
};
// -------------------------------------------------------------------

class AddMaterialResp : public ::google::protobuf::Message {
 public:
  AddMaterialResp();
  virtual ~AddMaterialResp();

  AddMaterialResp(const AddMaterialResp& from);

  inline AddMaterialResp& operator=(const AddMaterialResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddMaterialResp& default_instance();

  void Swap(AddMaterialResp* other);

  // implements Message ----------------------------------------------

  AddMaterialResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddMaterialResp& from);
  void MergeFrom(const AddMaterialResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional string media_id = 3;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 3;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // optional string url = 4;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 4;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:mpcomm.AddMaterialResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_media_id();
  inline void clear_has_media_id();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::std::string* media_id_;
  ::std::string* url_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static AddMaterialResp* default_instance_;
};
// -------------------------------------------------------------------

class GetMaterialReq : public ::google::protobuf::Message {
 public:
  GetMaterialReq();
  virtual ~GetMaterialReq();

  GetMaterialReq(const GetMaterialReq& from);

  inline GetMaterialReq& operator=(const GetMaterialReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMaterialReq& default_instance();

  void Swap(GetMaterialReq* other);

  // implements Message ----------------------------------------------

  GetMaterialReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMaterialReq& from);
  void MergeFrom(const GetMaterialReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string media_id = 2;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 2;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.GetMaterialReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_media_id();
  inline void clear_has_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetMaterialReq* default_instance_;
};
// -------------------------------------------------------------------

class GetMaterialResp : public ::google::protobuf::Message {
 public:
  GetMaterialResp();
  virtual ~GetMaterialResp();

  GetMaterialResp(const GetMaterialResp& from);

  inline GetMaterialResp& operator=(const GetMaterialResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMaterialResp& default_instance();

  void Swap(GetMaterialResp* other);

  // implements Message ----------------------------------------------

  GetMaterialResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMaterialResp& from);
  void MergeFrom(const GetMaterialResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // repeated .mpcomm.NewsItem news_item = 3;
  inline int news_item_size() const;
  inline void clear_news_item();
  static const int kNewsItemFieldNumber = 3;
  inline const ::mpcomm::NewsItem& news_item(int index) const;
  inline ::mpcomm::NewsItem* mutable_news_item(int index);
  inline ::mpcomm::NewsItem* add_news_item();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >&
      news_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >*
      mutable_news_item();

  // optional string title = 4;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 4;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string down_url = 6;
  inline bool has_down_url() const;
  inline void clear_down_url();
  static const int kDownUrlFieldNumber = 6;
  inline const ::std::string& down_url() const;
  inline void set_down_url(const ::std::string& value);
  inline void set_down_url(const char* value);
  inline void set_down_url(const char* value, size_t size);
  inline ::std::string* mutable_down_url();
  inline ::std::string* release_down_url();
  inline void set_allocated_down_url(::std::string* down_url);

  // optional .mpcomm.MediaFile media = 7;
  inline bool has_media() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 7;
  inline const ::mpcomm::MediaFile& media() const;
  inline ::mpcomm::MediaFile* mutable_media();
  inline ::mpcomm::MediaFile* release_media();
  inline void set_allocated_media(::mpcomm::MediaFile* media);

  // @@protoc_insertion_point(class_scope:mpcomm.GetMaterialResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_down_url();
  inline void clear_has_down_url();
  inline void set_has_media();
  inline void clear_has_media();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem > news_item_;
  ::std::string* title_;
  ::std::string* description_;
  ::std::string* down_url_;
  ::mpcomm::MediaFile* media_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetMaterialResp* default_instance_;
};
// -------------------------------------------------------------------

class DelMaterialReq : public ::google::protobuf::Message {
 public:
  DelMaterialReq();
  virtual ~DelMaterialReq();

  DelMaterialReq(const DelMaterialReq& from);

  inline DelMaterialReq& operator=(const DelMaterialReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelMaterialReq& default_instance();

  void Swap(DelMaterialReq* other);

  // implements Message ----------------------------------------------

  DelMaterialReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelMaterialReq& from);
  void MergeFrom(const DelMaterialReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string media_id = 2;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 2;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // @@protoc_insertion_point(class_scope:mpcomm.DelMaterialReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_media_id();
  inline void clear_has_media_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* media_id_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DelMaterialReq* default_instance_;
};
// -------------------------------------------------------------------

class DelMaterialResp : public ::google::protobuf::Message {
 public:
  DelMaterialResp();
  virtual ~DelMaterialResp();

  DelMaterialResp(const DelMaterialResp& from);

  inline DelMaterialResp& operator=(const DelMaterialResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelMaterialResp& default_instance();

  void Swap(DelMaterialResp* other);

  // implements Message ----------------------------------------------

  DelMaterialResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DelMaterialResp& from);
  void MergeFrom(const DelMaterialResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.DelMaterialResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DelMaterialResp* default_instance_;
};
// -------------------------------------------------------------------

class UpdateNewsReq : public ::google::protobuf::Message {
 public:
  UpdateNewsReq();
  virtual ~UpdateNewsReq();

  UpdateNewsReq(const UpdateNewsReq& from);

  inline UpdateNewsReq& operator=(const UpdateNewsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateNewsReq& default_instance();

  void Swap(UpdateNewsReq* other);

  // implements Message ----------------------------------------------

  UpdateNewsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateNewsReq& from);
  void MergeFrom(const UpdateNewsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string media_id = 2;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 2;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // optional uint64 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // optional .mpcomm.NewsItem articles = 4;
  inline bool has_articles() const;
  inline void clear_articles();
  static const int kArticlesFieldNumber = 4;
  inline const ::mpcomm::NewsItem& articles() const;
  inline ::mpcomm::NewsItem* mutable_articles();
  inline ::mpcomm::NewsItem* release_articles();
  inline void set_allocated_articles(::mpcomm::NewsItem* articles);

  // @@protoc_insertion_point(class_scope:mpcomm.UpdateNewsReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_media_id();
  inline void clear_has_media_id();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_articles();
  inline void clear_has_articles();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* media_id_;
  ::google::protobuf::uint64 index_;
  ::mpcomm::NewsItem* articles_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UpdateNewsReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdateNewsResp : public ::google::protobuf::Message {
 public:
  UpdateNewsResp();
  virtual ~UpdateNewsResp();

  UpdateNewsResp(const UpdateNewsResp& from);

  inline UpdateNewsResp& operator=(const UpdateNewsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateNewsResp& default_instance();

  void Swap(UpdateNewsResp* other);

  // implements Message ----------------------------------------------

  UpdateNewsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateNewsResp& from);
  void MergeFrom(const UpdateNewsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.UpdateNewsResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UpdateNewsResp* default_instance_;
};
// -------------------------------------------------------------------

class GetMaterialCountReq : public ::google::protobuf::Message {
 public:
  GetMaterialCountReq();
  virtual ~GetMaterialCountReq();

  GetMaterialCountReq(const GetMaterialCountReq& from);

  inline GetMaterialCountReq& operator=(const GetMaterialCountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMaterialCountReq& default_instance();

  void Swap(GetMaterialCountReq* other);

  // implements Message ----------------------------------------------

  GetMaterialCountReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMaterialCountReq& from);
  void MergeFrom(const GetMaterialCountReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:mpcomm.GetMaterialCountReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetMaterialCountReq* default_instance_;
};
// -------------------------------------------------------------------

class GetMaterialCountResp : public ::google::protobuf::Message {
 public:
  GetMaterialCountResp();
  virtual ~GetMaterialCountResp();

  GetMaterialCountResp(const GetMaterialCountResp& from);

  inline GetMaterialCountResp& operator=(const GetMaterialCountResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMaterialCountResp& default_instance();

  void Swap(GetMaterialCountResp* other);

  // implements Message ----------------------------------------------

  GetMaterialCountResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMaterialCountResp& from);
  void MergeFrom(const GetMaterialCountResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 voice_count = 3;
  inline bool has_voice_count() const;
  inline void clear_voice_count();
  static const int kVoiceCountFieldNumber = 3;
  inline ::google::protobuf::uint64 voice_count() const;
  inline void set_voice_count(::google::protobuf::uint64 value);

  // optional uint64 video_count = 4;
  inline bool has_video_count() const;
  inline void clear_video_count();
  static const int kVideoCountFieldNumber = 4;
  inline ::google::protobuf::uint64 video_count() const;
  inline void set_video_count(::google::protobuf::uint64 value);

  // optional uint64 image_count = 5;
  inline bool has_image_count() const;
  inline void clear_image_count();
  static const int kImageCountFieldNumber = 5;
  inline ::google::protobuf::uint64 image_count() const;
  inline void set_image_count(::google::protobuf::uint64 value);

  // optional uint64 news_count = 6;
  inline bool has_news_count() const;
  inline void clear_news_count();
  static const int kNewsCountFieldNumber = 6;
  inline ::google::protobuf::uint64 news_count() const;
  inline void set_news_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.GetMaterialCountResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_voice_count();
  inline void clear_has_voice_count();
  inline void set_has_video_count();
  inline void clear_has_video_count();
  inline void set_has_image_count();
  inline void clear_has_image_count();
  inline void set_has_news_count();
  inline void clear_has_news_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 voice_count_;
  ::google::protobuf::uint64 video_count_;
  ::google::protobuf::uint64 image_count_;
  ::google::protobuf::uint64 news_count_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetMaterialCountResp* default_instance_;
};
// -------------------------------------------------------------------

class BatchGetMaterialReq : public ::google::protobuf::Message {
 public:
  BatchGetMaterialReq();
  virtual ~BatchGetMaterialReq();

  BatchGetMaterialReq(const BatchGetMaterialReq& from);

  inline BatchGetMaterialReq& operator=(const BatchGetMaterialReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchGetMaterialReq& default_instance();

  void Swap(BatchGetMaterialReq* other);

  // implements Message ----------------------------------------------

  BatchGetMaterialReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchGetMaterialReq& from);
  void MergeFrom(const BatchGetMaterialReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional uint64 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);

  // optional uint64 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint64 count() const;
  inline void set_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.BatchGetMaterialReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* type_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 count_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchGetMaterialReq* default_instance_;
};
// -------------------------------------------------------------------

class MaterialItem : public ::google::protobuf::Message {
 public:
  MaterialItem();
  virtual ~MaterialItem();

  MaterialItem(const MaterialItem& from);

  inline MaterialItem& operator=(const MaterialItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaterialItem& default_instance();

  void Swap(MaterialItem* other);

  // implements Message ----------------------------------------------

  MaterialItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaterialItem& from);
  void MergeFrom(const MaterialItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string media_id = 1;
  inline bool has_media_id() const;
  inline void clear_media_id();
  static const int kMediaIdFieldNumber = 1;
  inline const ::std::string& media_id() const;
  inline void set_media_id(const ::std::string& value);
  inline void set_media_id(const char* value);
  inline void set_media_id(const char* value, size_t size);
  inline ::std::string* mutable_media_id();
  inline ::std::string* release_media_id();
  inline void set_allocated_media_id(::std::string* media_id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .mpcomm.NewsInfo content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::mpcomm::NewsInfo& content() const;
  inline ::mpcomm::NewsInfo* mutable_content();
  inline ::mpcomm::NewsInfo* release_content();
  inline void set_allocated_content(::mpcomm::NewsInfo* content);

  // optional uint64 update_time = 4;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 update_time() const;
  inline void set_update_time(::google::protobuf::uint64 value);

  // optional string bind_template_id = 5;
  inline bool has_bind_template_id() const;
  inline void clear_bind_template_id();
  static const int kBindTemplateIdFieldNumber = 5;
  inline const ::std::string& bind_template_id() const;
  inline void set_bind_template_id(const ::std::string& value);
  inline void set_bind_template_id(const char* value);
  inline void set_bind_template_id(const char* value, size_t size);
  inline ::std::string* mutable_bind_template_id();
  inline ::std::string* release_bind_template_id();
  inline void set_allocated_bind_template_id(::std::string* bind_template_id);

  // optional string url = 6;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 6;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:mpcomm.MaterialItem)
 private:
  inline void set_has_media_id();
  inline void clear_has_media_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_bind_template_id();
  inline void clear_has_bind_template_id();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* media_id_;
  ::std::string* name_;
  ::mpcomm::NewsInfo* content_;
  ::google::protobuf::uint64 update_time_;
  ::std::string* bind_template_id_;
  ::std::string* url_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static MaterialItem* default_instance_;
};
// -------------------------------------------------------------------

class BatchGetMaterialResp : public ::google::protobuf::Message {
 public:
  BatchGetMaterialResp();
  virtual ~BatchGetMaterialResp();

  BatchGetMaterialResp(const BatchGetMaterialResp& from);

  inline BatchGetMaterialResp& operator=(const BatchGetMaterialResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchGetMaterialResp& default_instance();

  void Swap(BatchGetMaterialResp* other);

  // implements Message ----------------------------------------------

  BatchGetMaterialResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchGetMaterialResp& from);
  void MergeFrom(const BatchGetMaterialResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // repeated .mpcomm.MaterialItem item = 3;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::mpcomm::MaterialItem& item(int index) const;
  inline ::mpcomm::MaterialItem* mutable_item(int index);
  inline ::mpcomm::MaterialItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MaterialItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MaterialItem >*
      mutable_item();

  // optional uint64 total_count = 4;
  inline bool has_total_count() const;
  inline void clear_total_count();
  static const int kTotalCountFieldNumber = 4;
  inline ::google::protobuf::uint64 total_count() const;
  inline void set_total_count(::google::protobuf::uint64 value);

  // optional uint64 item_count = 5;
  inline bool has_item_count() const;
  inline void clear_item_count();
  static const int kItemCountFieldNumber = 5;
  inline ::google::protobuf::uint64 item_count() const;
  inline void set_item_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.BatchGetMaterialResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_total_count();
  inline void clear_has_total_count();
  inline void set_has_item_count();
  inline void clear_has_item_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::MaterialItem > item_;
  ::google::protobuf::uint64 total_count_;
  ::google::protobuf::uint64 item_count_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchGetMaterialResp* default_instance_;
};
// -------------------------------------------------------------------

class Tag : public ::google::protobuf::Message {
 public:
  Tag();
  virtual ~Tag();

  Tag(const Tag& from);

  inline Tag& operator=(const Tag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tag& default_instance();

  void Swap(Tag* other);

  // implements Message ----------------------------------------------

  Tag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tag& from);
  void MergeFrom(const Tag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint64 count() const;
  inline void set_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.Tag)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::std::string* name_;
  ::google::protobuf::uint64 count_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static Tag* default_instance_;
};
// -------------------------------------------------------------------

class CreateTagsReq : public ::google::protobuf::Message {
 public:
  CreateTagsReq();
  virtual ~CreateTagsReq();

  CreateTagsReq(const CreateTagsReq& from);

  inline CreateTagsReq& operator=(const CreateTagsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTagsReq& default_instance();

  void Swap(CreateTagsReq* other);

  // implements Message ----------------------------------------------

  CreateTagsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateTagsReq& from);
  void MergeFrom(const CreateTagsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional .mpcomm.Tag tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::mpcomm::Tag& tag() const;
  inline ::mpcomm::Tag* mutable_tag();
  inline ::mpcomm::Tag* release_tag();
  inline void set_allocated_tag(::mpcomm::Tag* tag);

  // @@protoc_insertion_point(class_scope:mpcomm.CreateTagsReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::mpcomm::Tag* tag_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static CreateTagsReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateTagsResp : public ::google::protobuf::Message {
 public:
  CreateTagsResp();
  virtual ~CreateTagsResp();

  CreateTagsResp(const CreateTagsResp& from);

  inline CreateTagsResp& operator=(const CreateTagsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTagsResp& default_instance();

  void Swap(CreateTagsResp* other);

  // implements Message ----------------------------------------------

  CreateTagsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateTagsResp& from);
  void MergeFrom(const CreateTagsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional .mpcomm.Tag tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::mpcomm::Tag& tag() const;
  inline ::mpcomm::Tag* mutable_tag();
  inline ::mpcomm::Tag* release_tag();
  inline void set_allocated_tag(::mpcomm::Tag* tag);

  // @@protoc_insertion_point(class_scope:mpcomm.CreateTagsResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::mpcomm::Tag* tag_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static CreateTagsResp* default_instance_;
};
// -------------------------------------------------------------------

class GetTagsReq : public ::google::protobuf::Message {
 public:
  GetTagsReq();
  virtual ~GetTagsReq();

  GetTagsReq(const GetTagsReq& from);

  inline GetTagsReq& operator=(const GetTagsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTagsReq& default_instance();

  void Swap(GetTagsReq* other);

  // implements Message ----------------------------------------------

  GetTagsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTagsReq& from);
  void MergeFrom(const GetTagsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:mpcomm.GetTagsReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetTagsReq* default_instance_;
};
// -------------------------------------------------------------------

class GetTagsResp : public ::google::protobuf::Message {
 public:
  GetTagsResp();
  virtual ~GetTagsResp();

  GetTagsResp(const GetTagsResp& from);

  inline GetTagsResp& operator=(const GetTagsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTagsResp& default_instance();

  void Swap(GetTagsResp* other);

  // implements Message ----------------------------------------------

  GetTagsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTagsResp& from);
  void MergeFrom(const GetTagsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // repeated .mpcomm.Tag tags = 3;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 3;
  inline const ::mpcomm::Tag& tags(int index) const;
  inline ::mpcomm::Tag* mutable_tags(int index);
  inline ::mpcomm::Tag* add_tags();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::Tag >&
      tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::Tag >*
      mutable_tags();

  // @@protoc_insertion_point(class_scope:mpcomm.GetTagsResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::Tag > tags_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetTagsResp* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTagsReq : public ::google::protobuf::Message {
 public:
  UpdateTagsReq();
  virtual ~UpdateTagsReq();

  UpdateTagsReq(const UpdateTagsReq& from);

  inline UpdateTagsReq& operator=(const UpdateTagsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTagsReq& default_instance();

  void Swap(UpdateTagsReq* other);

  // implements Message ----------------------------------------------

  UpdateTagsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTagsReq& from);
  void MergeFrom(const UpdateTagsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional .mpcomm.Tag tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::mpcomm::Tag& tag() const;
  inline ::mpcomm::Tag* mutable_tag();
  inline ::mpcomm::Tag* release_tag();
  inline void set_allocated_tag(::mpcomm::Tag* tag);

  // @@protoc_insertion_point(class_scope:mpcomm.UpdateTagsReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::mpcomm::Tag* tag_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UpdateTagsReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTagsResp : public ::google::protobuf::Message {
 public:
  UpdateTagsResp();
  virtual ~UpdateTagsResp();

  UpdateTagsResp(const UpdateTagsResp& from);

  inline UpdateTagsResp& operator=(const UpdateTagsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTagsResp& default_instance();

  void Swap(UpdateTagsResp* other);

  // implements Message ----------------------------------------------

  UpdateTagsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTagsResp& from);
  void MergeFrom(const UpdateTagsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.UpdateTagsResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UpdateTagsResp* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTagsMembersReq : public ::google::protobuf::Message {
 public:
  UpdateTagsMembersReq();
  virtual ~UpdateTagsMembersReq();

  UpdateTagsMembersReq(const UpdateTagsMembersReq& from);

  inline UpdateTagsMembersReq& operator=(const UpdateTagsMembersReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTagsMembersReq& default_instance();

  void Swap(UpdateTagsMembersReq* other);

  // implements Message ----------------------------------------------

  UpdateTagsMembersReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTagsMembersReq& from);
  void MergeFrom(const UpdateTagsMembersReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string openid = 2;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 2;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional string to_tagid = 3;
  inline bool has_to_tagid() const;
  inline void clear_to_tagid();
  static const int kToTagidFieldNumber = 3;
  inline const ::std::string& to_tagid() const;
  inline void set_to_tagid(const ::std::string& value);
  inline void set_to_tagid(const char* value);
  inline void set_to_tagid(const char* value, size_t size);
  inline ::std::string* mutable_to_tagid();
  inline ::std::string* release_to_tagid();
  inline void set_allocated_to_tagid(::std::string* to_tagid);

  // @@protoc_insertion_point(class_scope:mpcomm.UpdateTagsMembersReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_to_tagid();
  inline void clear_has_to_tagid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* openid_;
  ::std::string* to_tagid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UpdateTagsMembersReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdateTagsMembersResp : public ::google::protobuf::Message {
 public:
  UpdateTagsMembersResp();
  virtual ~UpdateTagsMembersResp();

  UpdateTagsMembersResp(const UpdateTagsMembersResp& from);

  inline UpdateTagsMembersResp& operator=(const UpdateTagsMembersResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateTagsMembersResp& default_instance();

  void Swap(UpdateTagsMembersResp* other);

  // implements Message ----------------------------------------------

  UpdateTagsMembersResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateTagsMembersResp& from);
  void MergeFrom(const UpdateTagsMembersResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.UpdateTagsMembersResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UpdateTagsMembersResp* default_instance_;
};
// -------------------------------------------------------------------

class BatchUpdateTagsMembersReq : public ::google::protobuf::Message {
 public:
  BatchUpdateTagsMembersReq();
  virtual ~BatchUpdateTagsMembersReq();

  BatchUpdateTagsMembersReq(const BatchUpdateTagsMembersReq& from);

  inline BatchUpdateTagsMembersReq& operator=(const BatchUpdateTagsMembersReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchUpdateTagsMembersReq& default_instance();

  void Swap(BatchUpdateTagsMembersReq* other);

  // implements Message ----------------------------------------------

  BatchUpdateTagsMembersReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchUpdateTagsMembersReq& from);
  void MergeFrom(const BatchUpdateTagsMembersReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // repeated string openid_list = 2;
  inline int openid_list_size() const;
  inline void clear_openid_list();
  static const int kOpenidListFieldNumber = 2;
  inline const ::std::string& openid_list(int index) const;
  inline ::std::string* mutable_openid_list(int index);
  inline void set_openid_list(int index, const ::std::string& value);
  inline void set_openid_list(int index, const char* value);
  inline void set_openid_list(int index, const char* value, size_t size);
  inline ::std::string* add_openid_list();
  inline void add_openid_list(const ::std::string& value);
  inline void add_openid_list(const char* value);
  inline void add_openid_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& openid_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_openid_list();

  // optional string to_tagid = 3;
  inline bool has_to_tagid() const;
  inline void clear_to_tagid();
  static const int kToTagidFieldNumber = 3;
  inline const ::std::string& to_tagid() const;
  inline void set_to_tagid(const ::std::string& value);
  inline void set_to_tagid(const char* value);
  inline void set_to_tagid(const char* value, size_t size);
  inline ::std::string* mutable_to_tagid();
  inline ::std::string* release_to_tagid();
  inline void set_allocated_to_tagid(::std::string* to_tagid);

  // @@protoc_insertion_point(class_scope:mpcomm.BatchUpdateTagsMembersReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_to_tagid();
  inline void clear_has_to_tagid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> openid_list_;
  ::std::string* to_tagid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchUpdateTagsMembersReq* default_instance_;
};
// -------------------------------------------------------------------

class BatchUpdateTagsMembersResp : public ::google::protobuf::Message {
 public:
  BatchUpdateTagsMembersResp();
  virtual ~BatchUpdateTagsMembersResp();

  BatchUpdateTagsMembersResp(const BatchUpdateTagsMembersResp& from);

  inline BatchUpdateTagsMembersResp& operator=(const BatchUpdateTagsMembersResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchUpdateTagsMembersResp& default_instance();

  void Swap(BatchUpdateTagsMembersResp* other);

  // implements Message ----------------------------------------------

  BatchUpdateTagsMembersResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchUpdateTagsMembersResp& from);
  void MergeFrom(const BatchUpdateTagsMembersResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.BatchUpdateTagsMembersResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchUpdateTagsMembersResp* default_instance_;
};
// -------------------------------------------------------------------

class DeleteTagsReq : public ::google::protobuf::Message {
 public:
  DeleteTagsReq();
  virtual ~DeleteTagsReq();

  DeleteTagsReq(const DeleteTagsReq& from);

  inline DeleteTagsReq& operator=(const DeleteTagsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteTagsReq& default_instance();

  void Swap(DeleteTagsReq* other);

  // implements Message ----------------------------------------------

  DeleteTagsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteTagsReq& from);
  void MergeFrom(const DeleteTagsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional .mpcomm.Tag tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::mpcomm::Tag& tag() const;
  inline ::mpcomm::Tag* mutable_tag();
  inline ::mpcomm::Tag* release_tag();
  inline void set_allocated_tag(::mpcomm::Tag* tag);

  // @@protoc_insertion_point(class_scope:mpcomm.DeleteTagsReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::mpcomm::Tag* tag_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DeleteTagsReq* default_instance_;
};
// -------------------------------------------------------------------

class DeleteTagsResp : public ::google::protobuf::Message {
 public:
  DeleteTagsResp();
  virtual ~DeleteTagsResp();

  DeleteTagsResp(const DeleteTagsResp& from);

  inline DeleteTagsResp& operator=(const DeleteTagsResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteTagsResp& default_instance();

  void Swap(DeleteTagsResp* other);

  // implements Message ----------------------------------------------

  DeleteTagsResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteTagsResp& from);
  void MergeFrom(const DeleteTagsResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.DeleteTagsResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static DeleteTagsResp* default_instance_;
};
// -------------------------------------------------------------------

class TagUserData : public ::google::protobuf::Message {
 public:
  TagUserData();
  virtual ~TagUserData();

  TagUserData(const TagUserData& from);

  inline TagUserData& operator=(const TagUserData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TagUserData& default_instance();

  void Swap(TagUserData* other);

  // implements Message ----------------------------------------------

  TagUserData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TagUserData& from);
  void MergeFrom(const TagUserData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string openid = 1;
  inline int openid_size() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 1;
  inline const ::std::string& openid(int index) const;
  inline ::std::string* mutable_openid(int index);
  inline void set_openid(int index, const ::std::string& value);
  inline void set_openid(int index, const char* value);
  inline void set_openid(int index, const char* value, size_t size);
  inline ::std::string* add_openid();
  inline void add_openid(const ::std::string& value);
  inline void add_openid(const char* value);
  inline void add_openid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& openid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_openid();

  // @@protoc_insertion_point(class_scope:mpcomm.TagUserData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> openid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static TagUserData* default_instance_;
};
// -------------------------------------------------------------------

class GetTagUserReq : public ::google::protobuf::Message {
 public:
  GetTagUserReq();
  virtual ~GetTagUserReq();

  GetTagUserReq(const GetTagUserReq& from);

  inline GetTagUserReq& operator=(const GetTagUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTagUserReq& default_instance();

  void Swap(GetTagUserReq* other);

  // implements Message ----------------------------------------------

  GetTagUserReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTagUserReq& from);
  void MergeFrom(const GetTagUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional uint64 tagid = 2;
  inline bool has_tagid() const;
  inline void clear_tagid();
  static const int kTagidFieldNumber = 2;
  inline ::google::protobuf::uint64 tagid() const;
  inline void set_tagid(::google::protobuf::uint64 value);

  // optional string next_openid = 3;
  inline bool has_next_openid() const;
  inline void clear_next_openid();
  static const int kNextOpenidFieldNumber = 3;
  inline const ::std::string& next_openid() const;
  inline void set_next_openid(const ::std::string& value);
  inline void set_next_openid(const char* value);
  inline void set_next_openid(const char* value, size_t size);
  inline ::std::string* mutable_next_openid();
  inline ::std::string* release_next_openid();
  inline void set_allocated_next_openid(::std::string* next_openid);

  // @@protoc_insertion_point(class_scope:mpcomm.GetTagUserReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_tagid();
  inline void clear_has_tagid();
  inline void set_has_next_openid();
  inline void clear_has_next_openid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::uint64 tagid_;
  ::std::string* next_openid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetTagUserReq* default_instance_;
};
// -------------------------------------------------------------------

class GetTagUserResp : public ::google::protobuf::Message {
 public:
  GetTagUserResp();
  virtual ~GetTagUserResp();

  GetTagUserResp(const GetTagUserResp& from);

  inline GetTagUserResp& operator=(const GetTagUserResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTagUserResp& default_instance();

  void Swap(GetTagUserResp* other);

  // implements Message ----------------------------------------------

  GetTagUserResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTagUserResp& from);
  void MergeFrom(const GetTagUserResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint64 count() const;
  inline void set_count(::google::protobuf::uint64 value);

  // optional .mpcomm.TagUserData data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::mpcomm::TagUserData& data() const;
  inline ::mpcomm::TagUserData* mutable_data();
  inline ::mpcomm::TagUserData* release_data();
  inline void set_allocated_data(::mpcomm::TagUserData* data);

  // optional string next_openid = 5;
  inline bool has_next_openid() const;
  inline void clear_next_openid();
  static const int kNextOpenidFieldNumber = 5;
  inline const ::std::string& next_openid() const;
  inline void set_next_openid(const ::std::string& value);
  inline void set_next_openid(const char* value);
  inline void set_next_openid(const char* value, size_t size);
  inline ::std::string* mutable_next_openid();
  inline ::std::string* release_next_openid();
  inline void set_allocated_next_openid(::std::string* next_openid);

  // @@protoc_insertion_point(class_scope:mpcomm.GetTagUserResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_next_openid();
  inline void clear_has_next_openid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 count_;
  ::mpcomm::TagUserData* data_;
  ::std::string* next_openid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetTagUserResp* default_instance_;
};
// -------------------------------------------------------------------

class BatchTaggingMembersReq : public ::google::protobuf::Message {
 public:
  BatchTaggingMembersReq();
  virtual ~BatchTaggingMembersReq();

  BatchTaggingMembersReq(const BatchTaggingMembersReq& from);

  inline BatchTaggingMembersReq& operator=(const BatchTaggingMembersReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchTaggingMembersReq& default_instance();

  void Swap(BatchTaggingMembersReq* other);

  // implements Message ----------------------------------------------

  BatchTaggingMembersReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchTaggingMembersReq& from);
  void MergeFrom(const BatchTaggingMembersReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // repeated string openid_list = 2;
  inline int openid_list_size() const;
  inline void clear_openid_list();
  static const int kOpenidListFieldNumber = 2;
  inline const ::std::string& openid_list(int index) const;
  inline ::std::string* mutable_openid_list(int index);
  inline void set_openid_list(int index, const ::std::string& value);
  inline void set_openid_list(int index, const char* value);
  inline void set_openid_list(int index, const char* value, size_t size);
  inline ::std::string* add_openid_list();
  inline void add_openid_list(const ::std::string& value);
  inline void add_openid_list(const char* value);
  inline void add_openid_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& openid_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_openid_list();

  // optional uint64 tagid = 3;
  inline bool has_tagid() const;
  inline void clear_tagid();
  static const int kTagidFieldNumber = 3;
  inline ::google::protobuf::uint64 tagid() const;
  inline void set_tagid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.BatchTaggingMembersReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_tagid();
  inline void clear_has_tagid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> openid_list_;
  ::google::protobuf::uint64 tagid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchTaggingMembersReq* default_instance_;
};
// -------------------------------------------------------------------

class BatchTaggingMembersResp : public ::google::protobuf::Message {
 public:
  BatchTaggingMembersResp();
  virtual ~BatchTaggingMembersResp();

  BatchTaggingMembersResp(const BatchTaggingMembersResp& from);

  inline BatchTaggingMembersResp& operator=(const BatchTaggingMembersResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchTaggingMembersResp& default_instance();

  void Swap(BatchTaggingMembersResp* other);

  // implements Message ----------------------------------------------

  BatchTaggingMembersResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchTaggingMembersResp& from);
  void MergeFrom(const BatchTaggingMembersResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.BatchTaggingMembersResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchTaggingMembersResp* default_instance_;
};
// -------------------------------------------------------------------

class BatchUnTaggingMembersReq : public ::google::protobuf::Message {
 public:
  BatchUnTaggingMembersReq();
  virtual ~BatchUnTaggingMembersReq();

  BatchUnTaggingMembersReq(const BatchUnTaggingMembersReq& from);

  inline BatchUnTaggingMembersReq& operator=(const BatchUnTaggingMembersReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchUnTaggingMembersReq& default_instance();

  void Swap(BatchUnTaggingMembersReq* other);

  // implements Message ----------------------------------------------

  BatchUnTaggingMembersReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchUnTaggingMembersReq& from);
  void MergeFrom(const BatchUnTaggingMembersReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // repeated string openid_list = 2;
  inline int openid_list_size() const;
  inline void clear_openid_list();
  static const int kOpenidListFieldNumber = 2;
  inline const ::std::string& openid_list(int index) const;
  inline ::std::string* mutable_openid_list(int index);
  inline void set_openid_list(int index, const ::std::string& value);
  inline void set_openid_list(int index, const char* value);
  inline void set_openid_list(int index, const char* value, size_t size);
  inline ::std::string* add_openid_list();
  inline void add_openid_list(const ::std::string& value);
  inline void add_openid_list(const char* value);
  inline void add_openid_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& openid_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_openid_list();

  // optional uint64 tagid = 3;
  inline bool has_tagid() const;
  inline void clear_tagid();
  static const int kTagidFieldNumber = 3;
  inline ::google::protobuf::uint64 tagid() const;
  inline void set_tagid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpcomm.BatchUnTaggingMembersReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_tagid();
  inline void clear_has_tagid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> openid_list_;
  ::google::protobuf::uint64 tagid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchUnTaggingMembersReq* default_instance_;
};
// -------------------------------------------------------------------

class BatchUnTaggingMembersResp : public ::google::protobuf::Message {
 public:
  BatchUnTaggingMembersResp();
  virtual ~BatchUnTaggingMembersResp();

  BatchUnTaggingMembersResp(const BatchUnTaggingMembersResp& from);

  inline BatchUnTaggingMembersResp& operator=(const BatchUnTaggingMembersResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchUnTaggingMembersResp& default_instance();

  void Swap(BatchUnTaggingMembersResp* other);

  // implements Message ----------------------------------------------

  BatchUnTaggingMembersResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchUnTaggingMembersResp& from);
  void MergeFrom(const BatchUnTaggingMembersResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.BatchUnTaggingMembersResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchUnTaggingMembersResp* default_instance_;
};
// -------------------------------------------------------------------

class GetTagsIdListReq : public ::google::protobuf::Message {
 public:
  GetTagsIdListReq();
  virtual ~GetTagsIdListReq();

  GetTagsIdListReq(const GetTagsIdListReq& from);

  inline GetTagsIdListReq& operator=(const GetTagsIdListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTagsIdListReq& default_instance();

  void Swap(GetTagsIdListReq* other);

  // implements Message ----------------------------------------------

  GetTagsIdListReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTagsIdListReq& from);
  void MergeFrom(const GetTagsIdListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string openid = 2;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 2;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // @@protoc_insertion_point(class_scope:mpcomm.GetTagsIdListReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_openid();
  inline void clear_has_openid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* openid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetTagsIdListReq* default_instance_;
};
// -------------------------------------------------------------------

class GetTagsIdListResp : public ::google::protobuf::Message {
 public:
  GetTagsIdListResp();
  virtual ~GetTagsIdListResp();

  GetTagsIdListResp(const GetTagsIdListResp& from);

  inline GetTagsIdListResp& operator=(const GetTagsIdListResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTagsIdListResp& default_instance();

  void Swap(GetTagsIdListResp* other);

  // implements Message ----------------------------------------------

  GetTagsIdListResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTagsIdListResp& from);
  void MergeFrom(const GetTagsIdListResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // repeated uint64 tagid_list = 3;
  inline int tagid_list_size() const;
  inline void clear_tagid_list();
  static const int kTagidListFieldNumber = 3;
  inline ::google::protobuf::uint64 tagid_list(int index) const;
  inline void set_tagid_list(int index, ::google::protobuf::uint64 value);
  inline void add_tagid_list(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      tagid_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_tagid_list();

  // @@protoc_insertion_point(class_scope:mpcomm.GetTagsIdListResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > tagid_list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetTagsIdListResp* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserInfoRemarkReq : public ::google::protobuf::Message {
 public:
  UpdateUserInfoRemarkReq();
  virtual ~UpdateUserInfoRemarkReq();

  UpdateUserInfoRemarkReq(const UpdateUserInfoRemarkReq& from);

  inline UpdateUserInfoRemarkReq& operator=(const UpdateUserInfoRemarkReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateUserInfoRemarkReq& default_instance();

  void Swap(UpdateUserInfoRemarkReq* other);

  // implements Message ----------------------------------------------

  UpdateUserInfoRemarkReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateUserInfoRemarkReq& from);
  void MergeFrom(const UpdateUserInfoRemarkReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string openid = 2;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 2;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional string remark = 3;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 3;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:mpcomm.UpdateUserInfoRemarkReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* openid_;
  ::std::string* remark_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserInfoRemarkReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserInfoRemarkResp : public ::google::protobuf::Message {
 public:
  UpdateUserInfoRemarkResp();
  virtual ~UpdateUserInfoRemarkResp();

  UpdateUserInfoRemarkResp(const UpdateUserInfoRemarkResp& from);

  inline UpdateUserInfoRemarkResp& operator=(const UpdateUserInfoRemarkResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateUserInfoRemarkResp& default_instance();

  void Swap(UpdateUserInfoRemarkResp* other);

  // implements Message ----------------------------------------------

  UpdateUserInfoRemarkResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateUserInfoRemarkResp& from);
  void MergeFrom(const UpdateUserInfoRemarkResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // @@protoc_insertion_point(class_scope:mpcomm.UpdateUserInfoRemarkResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UpdateUserInfoRemarkResp* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoReq : public ::google::protobuf::Message {
 public:
  UserInfoReq();
  virtual ~UserInfoReq();

  UserInfoReq(const UserInfoReq& from);

  inline UserInfoReq& operator=(const UserInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoReq& default_instance();

  void Swap(UserInfoReq* other);

  // implements Message ----------------------------------------------

  UserInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoReq& from);
  void MergeFrom(const UserInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string openid = 2;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 2;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional string lang = 3;
  inline bool has_lang() const;
  inline void clear_lang();
  static const int kLangFieldNumber = 3;
  inline const ::std::string& lang() const;
  inline void set_lang(const ::std::string& value);
  inline void set_lang(const char* value);
  inline void set_lang(const char* value, size_t size);
  inline ::std::string* mutable_lang();
  inline ::std::string* release_lang();
  inline void set_allocated_lang(::std::string* lang);

  // @@protoc_insertion_point(class_scope:mpcomm.UserInfoReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_lang();
  inline void clear_has_lang();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* openid_;
  ::std::string* lang_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UserInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoResp : public ::google::protobuf::Message {
 public:
  UserInfoResp();
  virtual ~UserInfoResp();

  UserInfoResp(const UserInfoResp& from);

  inline UserInfoResp& operator=(const UserInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoResp& default_instance();

  void Swap(UserInfoResp* other);

  // implements Message ----------------------------------------------

  UserInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoResp& from);
  void MergeFrom(const UserInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 subscribe = 3;
  inline bool has_subscribe() const;
  inline void clear_subscribe();
  static const int kSubscribeFieldNumber = 3;
  inline ::google::protobuf::uint64 subscribe() const;
  inline void set_subscribe(::google::protobuf::uint64 value);

  // optional string openid = 4;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 4;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional string nickname = 5;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 5;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional uint64 sex = 6;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 6;
  inline ::google::protobuf::uint64 sex() const;
  inline void set_sex(::google::protobuf::uint64 value);

  // optional string language = 7;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 7;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string city = 8;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 8;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string province = 9;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 9;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const char* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  inline void set_allocated_province(::std::string* province);

  // optional string country = 10;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 10;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string headimgurl = 11;
  inline bool has_headimgurl() const;
  inline void clear_headimgurl();
  static const int kHeadimgurlFieldNumber = 11;
  inline const ::std::string& headimgurl() const;
  inline void set_headimgurl(const ::std::string& value);
  inline void set_headimgurl(const char* value);
  inline void set_headimgurl(const char* value, size_t size);
  inline ::std::string* mutable_headimgurl();
  inline ::std::string* release_headimgurl();
  inline void set_allocated_headimgurl(::std::string* headimgurl);

  // optional uint64 subscribe_time = 12;
  inline bool has_subscribe_time() const;
  inline void clear_subscribe_time();
  static const int kSubscribeTimeFieldNumber = 12;
  inline ::google::protobuf::uint64 subscribe_time() const;
  inline void set_subscribe_time(::google::protobuf::uint64 value);

  // optional string unionid = 13;
  inline bool has_unionid() const;
  inline void clear_unionid();
  static const int kUnionidFieldNumber = 13;
  inline const ::std::string& unionid() const;
  inline void set_unionid(const ::std::string& value);
  inline void set_unionid(const char* value);
  inline void set_unionid(const char* value, size_t size);
  inline ::std::string* mutable_unionid();
  inline ::std::string* release_unionid();
  inline void set_allocated_unionid(::std::string* unionid);

  // optional string remark = 14;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 14;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // optional uint64 groupid = 15;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 15;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // repeated uint64 tagid_list = 16;
  inline int tagid_list_size() const;
  inline void clear_tagid_list();
  static const int kTagidListFieldNumber = 16;
  inline ::google::protobuf::uint64 tagid_list(int index) const;
  inline void set_tagid_list(int index, ::google::protobuf::uint64 value);
  inline void add_tagid_list(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      tagid_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_tagid_list();

  // @@protoc_insertion_point(class_scope:mpcomm.UserInfoResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_subscribe();
  inline void clear_has_subscribe();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_headimgurl();
  inline void clear_has_headimgurl();
  inline void set_has_subscribe_time();
  inline void clear_has_subscribe_time();
  inline void set_has_unionid();
  inline void clear_has_unionid();
  inline void set_has_remark();
  inline void clear_has_remark();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 subscribe_;
  ::std::string* openid_;
  ::std::string* nickname_;
  ::google::protobuf::uint64 sex_;
  ::std::string* language_;
  ::std::string* city_;
  ::std::string* province_;
  ::std::string* country_;
  ::std::string* headimgurl_;
  ::google::protobuf::uint64 subscribe_time_;
  ::std::string* unionid_;
  ::std::string* remark_;
  ::google::protobuf::uint64 groupid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > tagid_list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UserInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class BatchGetUserItem : public ::google::protobuf::Message {
 public:
  BatchGetUserItem();
  virtual ~BatchGetUserItem();

  BatchGetUserItem(const BatchGetUserItem& from);

  inline BatchGetUserItem& operator=(const BatchGetUserItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchGetUserItem& default_instance();

  void Swap(BatchGetUserItem* other);

  // implements Message ----------------------------------------------

  BatchGetUserItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchGetUserItem& from);
  void MergeFrom(const BatchGetUserItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string openid = 1;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 1;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional string lang = 2;
  inline bool has_lang() const;
  inline void clear_lang();
  static const int kLangFieldNumber = 2;
  inline const ::std::string& lang() const;
  inline void set_lang(const ::std::string& value);
  inline void set_lang(const char* value);
  inline void set_lang(const char* value, size_t size);
  inline ::std::string* mutable_lang();
  inline ::std::string* release_lang();
  inline void set_allocated_lang(::std::string* lang);

  // @@protoc_insertion_point(class_scope:mpcomm.BatchGetUserItem)
 private:
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_lang();
  inline void clear_has_lang();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* openid_;
  ::std::string* lang_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchGetUserItem* default_instance_;
};
// -------------------------------------------------------------------

class BatchGetUserInfoReq : public ::google::protobuf::Message {
 public:
  BatchGetUserInfoReq();
  virtual ~BatchGetUserInfoReq();

  BatchGetUserInfoReq(const BatchGetUserInfoReq& from);

  inline BatchGetUserInfoReq& operator=(const BatchGetUserInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchGetUserInfoReq& default_instance();

  void Swap(BatchGetUserInfoReq* other);

  // implements Message ----------------------------------------------

  BatchGetUserInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchGetUserInfoReq& from);
  void MergeFrom(const BatchGetUserInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // repeated .mpcomm.BatchGetUserItem user_list = 2;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 2;
  inline const ::mpcomm::BatchGetUserItem& user_list(int index) const;
  inline ::mpcomm::BatchGetUserItem* mutable_user_list(int index);
  inline ::mpcomm::BatchGetUserItem* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::BatchGetUserItem >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::BatchGetUserItem >*
      mutable_user_list();

  // @@protoc_insertion_point(class_scope:mpcomm.BatchGetUserInfoReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::BatchGetUserItem > user_list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchGetUserInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoItem : public ::google::protobuf::Message {
 public:
  UserInfoItem();
  virtual ~UserInfoItem();

  UserInfoItem(const UserInfoItem& from);

  inline UserInfoItem& operator=(const UserInfoItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoItem& default_instance();

  void Swap(UserInfoItem* other);

  // implements Message ----------------------------------------------

  UserInfoItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfoItem& from);
  void MergeFrom(const UserInfoItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 subscribe = 1;
  inline bool has_subscribe() const;
  inline void clear_subscribe();
  static const int kSubscribeFieldNumber = 1;
  inline ::google::protobuf::uint64 subscribe() const;
  inline void set_subscribe(::google::protobuf::uint64 value);

  // optional string openid = 2;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 2;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // optional string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional uint64 sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline ::google::protobuf::uint64 sex() const;
  inline void set_sex(::google::protobuf::uint64 value);

  // optional string language = 5;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 5;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string province = 7;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 7;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const char* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  inline void set_allocated_province(::std::string* province);

  // optional string country = 8;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 8;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string headimgurl = 9;
  inline bool has_headimgurl() const;
  inline void clear_headimgurl();
  static const int kHeadimgurlFieldNumber = 9;
  inline const ::std::string& headimgurl() const;
  inline void set_headimgurl(const ::std::string& value);
  inline void set_headimgurl(const char* value);
  inline void set_headimgurl(const char* value, size_t size);
  inline ::std::string* mutable_headimgurl();
  inline ::std::string* release_headimgurl();
  inline void set_allocated_headimgurl(::std::string* headimgurl);

  // optional uint64 subscribe_time = 10;
  inline bool has_subscribe_time() const;
  inline void clear_subscribe_time();
  static const int kSubscribeTimeFieldNumber = 10;
  inline ::google::protobuf::uint64 subscribe_time() const;
  inline void set_subscribe_time(::google::protobuf::uint64 value);

  // optional string unionid = 11;
  inline bool has_unionid() const;
  inline void clear_unionid();
  static const int kUnionidFieldNumber = 11;
  inline const ::std::string& unionid() const;
  inline void set_unionid(const ::std::string& value);
  inline void set_unionid(const char* value);
  inline void set_unionid(const char* value, size_t size);
  inline ::std::string* mutable_unionid();
  inline ::std::string* release_unionid();
  inline void set_allocated_unionid(::std::string* unionid);

  // optional string remark = 12;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 12;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // optional uint64 groupid = 13;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 13;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // repeated uint64 tagid_list = 14;
  inline int tagid_list_size() const;
  inline void clear_tagid_list();
  static const int kTagidListFieldNumber = 14;
  inline ::google::protobuf::uint64 tagid_list(int index) const;
  inline void set_tagid_list(int index, ::google::protobuf::uint64 value);
  inline void add_tagid_list(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      tagid_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_tagid_list();

  // @@protoc_insertion_point(class_scope:mpcomm.UserInfoItem)
 private:
  inline void set_has_subscribe();
  inline void clear_has_subscribe();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_headimgurl();
  inline void clear_has_headimgurl();
  inline void set_has_subscribe_time();
  inline void clear_has_subscribe_time();
  inline void set_has_unionid();
  inline void clear_has_unionid();
  inline void set_has_remark();
  inline void clear_has_remark();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 subscribe_;
  ::std::string* openid_;
  ::std::string* nickname_;
  ::google::protobuf::uint64 sex_;
  ::std::string* language_;
  ::std::string* city_;
  ::std::string* province_;
  ::std::string* country_;
  ::std::string* headimgurl_;
  ::google::protobuf::uint64 subscribe_time_;
  ::std::string* unionid_;
  ::std::string* remark_;
  ::google::protobuf::uint64 groupid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > tagid_list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UserInfoItem* default_instance_;
};
// -------------------------------------------------------------------

class BatchGetUserInfoResp : public ::google::protobuf::Message {
 public:
  BatchGetUserInfoResp();
  virtual ~BatchGetUserInfoResp();

  BatchGetUserInfoResp(const BatchGetUserInfoResp& from);

  inline BatchGetUserInfoResp& operator=(const BatchGetUserInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchGetUserInfoResp& default_instance();

  void Swap(BatchGetUserInfoResp* other);

  // implements Message ----------------------------------------------

  BatchGetUserInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchGetUserInfoResp& from);
  void MergeFrom(const BatchGetUserInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // repeated .mpcomm.UserInfoItem user_info_list = 3;
  inline int user_info_list_size() const;
  inline void clear_user_info_list();
  static const int kUserInfoListFieldNumber = 3;
  inline const ::mpcomm::UserInfoItem& user_info_list(int index) const;
  inline ::mpcomm::UserInfoItem* mutable_user_info_list(int index);
  inline ::mpcomm::UserInfoItem* add_user_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::UserInfoItem >&
      user_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::mpcomm::UserInfoItem >*
      mutable_user_info_list();

  // @@protoc_insertion_point(class_scope:mpcomm.BatchGetUserInfoResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::RepeatedPtrField< ::mpcomm::UserInfoItem > user_info_list_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static BatchGetUserInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class GetUserReq : public ::google::protobuf::Message {
 public:
  GetUserReq();
  virtual ~GetUserReq();

  GetUserReq(const GetUserReq& from);

  inline GetUserReq& operator=(const GetUserReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserReq& default_instance();

  void Swap(GetUserReq* other);

  // implements Message ----------------------------------------------

  GetUserReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserReq& from);
  void MergeFrom(const GetUserReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  inline void set_allocated_access_token(::std::string* access_token);

  // optional string next_openid = 2;
  inline bool has_next_openid() const;
  inline void clear_next_openid();
  static const int kNextOpenidFieldNumber = 2;
  inline const ::std::string& next_openid() const;
  inline void set_next_openid(const ::std::string& value);
  inline void set_next_openid(const char* value);
  inline void set_next_openid(const char* value, size_t size);
  inline ::std::string* mutable_next_openid();
  inline ::std::string* release_next_openid();
  inline void set_allocated_next_openid(::std::string* next_openid);

  // @@protoc_insertion_point(class_scope:mpcomm.GetUserReq)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_next_openid();
  inline void clear_has_next_openid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* access_token_;
  ::std::string* next_openid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetUserReq* default_instance_;
};
// -------------------------------------------------------------------

class UserList : public ::google::protobuf::Message {
 public:
  UserList();
  virtual ~UserList();

  UserList(const UserList& from);

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserList& default_instance();

  void Swap(UserList* other);

  // implements Message ----------------------------------------------

  UserList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string openid = 1;
  inline int openid_size() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 1;
  inline const ::std::string& openid(int index) const;
  inline ::std::string* mutable_openid(int index);
  inline void set_openid(int index, const ::std::string& value);
  inline void set_openid(int index, const char* value);
  inline void set_openid(int index, const char* value, size_t size);
  inline ::std::string* add_openid();
  inline void add_openid(const ::std::string& value);
  inline void add_openid(const char* value);
  inline void add_openid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& openid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_openid();

  // @@protoc_insertion_point(class_scope:mpcomm.UserList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> openid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static UserList* default_instance_;
};
// -------------------------------------------------------------------

class GetUserResp : public ::google::protobuf::Message {
 public:
  GetUserResp();
  virtual ~GetUserResp();

  GetUserResp(const GetUserResp& from);

  inline GetUserResp& operator=(const GetUserResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserResp& default_instance();

  void Swap(GetUserResp* other);

  // implements Message ----------------------------------------------

  GetUserResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetUserResp& from);
  void MergeFrom(const GetUserResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::int64 errcode() const;
  inline void set_errcode(::google::protobuf::int64 value);

  // optional string errmsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrmsgFieldNumber = 2;
  inline const ::std::string& errmsg() const;
  inline void set_errmsg(const ::std::string& value);
  inline void set_errmsg(const char* value);
  inline void set_errmsg(const char* value, size_t size);
  inline ::std::string* mutable_errmsg();
  inline ::std::string* release_errmsg();
  inline void set_allocated_errmsg(::std::string* errmsg);

  // optional uint64 total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline ::google::protobuf::uint64 total() const;
  inline void set_total(::google::protobuf::uint64 value);

  // optional uint64 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint64 count() const;
  inline void set_count(::google::protobuf::uint64 value);

  // optional .mpcomm.UserList data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::mpcomm::UserList& data() const;
  inline ::mpcomm::UserList* mutable_data();
  inline ::mpcomm::UserList* release_data();
  inline void set_allocated_data(::mpcomm::UserList* data);

  // optional string next_openid = 6;
  inline bool has_next_openid() const;
  inline void clear_next_openid();
  static const int kNextOpenidFieldNumber = 6;
  inline const ::std::string& next_openid() const;
  inline void set_next_openid(const ::std::string& value);
  inline void set_next_openid(const char* value);
  inline void set_next_openid(const char* value, size_t size);
  inline ::std::string* mutable_next_openid();
  inline ::std::string* release_next_openid();
  inline void set_allocated_next_openid(::std::string* next_openid);

  // @@protoc_insertion_point(class_scope:mpcomm.GetUserResp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_next_openid();
  inline void clear_has_next_openid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 errcode_;
  ::std::string* errmsg_;
  ::google::protobuf::uint64 total_;
  ::google::protobuf::uint64 count_;
  ::mpcomm::UserList* data_;
  ::std::string* next_openid_;
  friend void  protobuf_AddDesc_mpmsg_2eproto();
  friend void protobuf_AssignDesc_mpmsg_2eproto();
  friend void protobuf_ShutdownFile_mpmsg_2eproto();

  void InitAsDefaultInstance();
  static GetUserResp* default_instance_;
};
// ===================================================================


// ===================================================================

// TestMessage

// optional int64 field1 = 1;
inline bool TestMessage::has_field1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestMessage::set_has_field1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestMessage::clear_has_field1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestMessage::clear_field1() {
  field1_ = GOOGLE_LONGLONG(0);
  clear_has_field1();
}
inline ::google::protobuf::int64 TestMessage::field1() const {
  // @@protoc_insertion_point(field_get:mpcomm.TestMessage.field1)
  return field1_;
}
inline void TestMessage::set_field1(::google::protobuf::int64 value) {
  set_has_field1();
  field1_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.TestMessage.field1)
}

// optional uint64 field2 = 2;
inline bool TestMessage::has_field2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestMessage::set_has_field2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestMessage::clear_has_field2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestMessage::clear_field2() {
  field2_ = GOOGLE_ULONGLONG(0);
  clear_has_field2();
}
inline ::google::protobuf::uint64 TestMessage::field2() const {
  // @@protoc_insertion_point(field_get:mpcomm.TestMessage.field2)
  return field2_;
}
inline void TestMessage::set_field2(::google::protobuf::uint64 value) {
  set_has_field2();
  field2_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.TestMessage.field2)
}

// optional string field3 = 3;
inline bool TestMessage::has_field3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestMessage::set_has_field3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestMessage::clear_has_field3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestMessage::clear_field3() {
  if (field3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field3_->clear();
  }
  clear_has_field3();
}
inline const ::std::string& TestMessage::field3() const {
  // @@protoc_insertion_point(field_get:mpcomm.TestMessage.field3)
  return *field3_;
}
inline void TestMessage::set_field3(const ::std::string& value) {
  set_has_field3();
  if (field3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field3_ = new ::std::string;
  }
  field3_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TestMessage.field3)
}
inline void TestMessage::set_field3(const char* value) {
  set_has_field3();
  if (field3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field3_ = new ::std::string;
  }
  field3_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TestMessage.field3)
}
inline void TestMessage::set_field3(const char* value, size_t size) {
  set_has_field3();
  if (field3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field3_ = new ::std::string;
  }
  field3_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TestMessage.field3)
}
inline ::std::string* TestMessage::mutable_field3() {
  set_has_field3();
  if (field3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field3_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TestMessage.field3)
  return field3_;
}
inline ::std::string* TestMessage::release_field3() {
  clear_has_field3();
  if (field3_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = field3_;
    field3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TestMessage::set_allocated_field3(::std::string* field3) {
  if (field3_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete field3_;
  }
  if (field3) {
    set_has_field3();
    field3_ = field3;
  } else {
    clear_has_field3();
    field3_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TestMessage.field3)
}

// optional string field4 = 4;
inline bool TestMessage::has_field4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestMessage::set_has_field4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestMessage::clear_has_field4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestMessage::clear_field4() {
  if (field4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field4_->clear();
  }
  clear_has_field4();
}
inline const ::std::string& TestMessage::field4() const {
  // @@protoc_insertion_point(field_get:mpcomm.TestMessage.field4)
  return *field4_;
}
inline void TestMessage::set_field4(const ::std::string& value) {
  set_has_field4();
  if (field4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field4_ = new ::std::string;
  }
  field4_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TestMessage.field4)
}
inline void TestMessage::set_field4(const char* value) {
  set_has_field4();
  if (field4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field4_ = new ::std::string;
  }
  field4_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TestMessage.field4)
}
inline void TestMessage::set_field4(const char* value, size_t size) {
  set_has_field4();
  if (field4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field4_ = new ::std::string;
  }
  field4_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TestMessage.field4)
}
inline ::std::string* TestMessage::mutable_field4() {
  set_has_field4();
  if (field4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    field4_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TestMessage.field4)
  return field4_;
}
inline ::std::string* TestMessage::release_field4() {
  clear_has_field4();
  if (field4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = field4_;
    field4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TestMessage::set_allocated_field4(::std::string* field4) {
  if (field4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete field4_;
  }
  if (field4) {
    set_has_field4();
    field4_ = field4;
  } else {
    clear_has_field4();
    field4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TestMessage.field4)
}

// optional .mpcomm.TestMessage field5 = 5;
inline bool TestMessage::has_field5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestMessage::set_has_field5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestMessage::clear_has_field5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestMessage::clear_field5() {
  if (field5_ != NULL) field5_->::mpcomm::TestMessage::Clear();
  clear_has_field5();
}
inline const ::mpcomm::TestMessage& TestMessage::field5() const {
  // @@protoc_insertion_point(field_get:mpcomm.TestMessage.field5)
  return field5_ != NULL ? *field5_ : *default_instance_->field5_;
}
inline ::mpcomm::TestMessage* TestMessage::mutable_field5() {
  set_has_field5();
  if (field5_ == NULL) field5_ = new ::mpcomm::TestMessage;
  // @@protoc_insertion_point(field_mutable:mpcomm.TestMessage.field5)
  return field5_;
}
inline ::mpcomm::TestMessage* TestMessage::release_field5() {
  clear_has_field5();
  ::mpcomm::TestMessage* temp = field5_;
  field5_ = NULL;
  return temp;
}
inline void TestMessage::set_allocated_field5(::mpcomm::TestMessage* field5) {
  delete field5_;
  field5_ = field5;
  if (field5) {
    set_has_field5();
  } else {
    clear_has_field5();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TestMessage.field5)
}

// -------------------------------------------------------------------

// TokenReq

// optional string grant_type = 1 [default = "client_credential"];
inline bool TokenReq::has_grant_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenReq::set_has_grant_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TokenReq::clear_has_grant_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TokenReq::clear_grant_type() {
  if (grant_type_ != _default_grant_type_) {
    grant_type_->assign(*_default_grant_type_);
  }
  clear_has_grant_type();
}
inline const ::std::string& TokenReq::grant_type() const {
  // @@protoc_insertion_point(field_get:mpcomm.TokenReq.grant_type)
  return *grant_type_;
}
inline void TokenReq::set_grant_type(const ::std::string& value) {
  set_has_grant_type();
  if (grant_type_ == _default_grant_type_) {
    grant_type_ = new ::std::string;
  }
  grant_type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TokenReq.grant_type)
}
inline void TokenReq::set_grant_type(const char* value) {
  set_has_grant_type();
  if (grant_type_ == _default_grant_type_) {
    grant_type_ = new ::std::string;
  }
  grant_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TokenReq.grant_type)
}
inline void TokenReq::set_grant_type(const char* value, size_t size) {
  set_has_grant_type();
  if (grant_type_ == _default_grant_type_) {
    grant_type_ = new ::std::string;
  }
  grant_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TokenReq.grant_type)
}
inline ::std::string* TokenReq::mutable_grant_type() {
  set_has_grant_type();
  if (grant_type_ == _default_grant_type_) {
    grant_type_ = new ::std::string(*_default_grant_type_);
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TokenReq.grant_type)
  return grant_type_;
}
inline ::std::string* TokenReq::release_grant_type() {
  clear_has_grant_type();
  if (grant_type_ == _default_grant_type_) {
    return NULL;
  } else {
    ::std::string* temp = grant_type_;
    grant_type_ = const_cast< ::std::string*>(_default_grant_type_);
    return temp;
  }
}
inline void TokenReq::set_allocated_grant_type(::std::string* grant_type) {
  if (grant_type_ != _default_grant_type_) {
    delete grant_type_;
  }
  if (grant_type) {
    set_has_grant_type();
    grant_type_ = grant_type;
  } else {
    clear_has_grant_type();
    grant_type_ = const_cast< ::std::string*>(_default_grant_type_);
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TokenReq.grant_type)
}

// optional string appid = 2;
inline bool TokenReq::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TokenReq::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TokenReq::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TokenReq::clear_appid() {
  if (appid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& TokenReq::appid() const {
  // @@protoc_insertion_point(field_get:mpcomm.TokenReq.appid)
  return *appid_;
}
inline void TokenReq::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TokenReq.appid)
}
inline void TokenReq::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TokenReq.appid)
}
inline void TokenReq::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TokenReq.appid)
}
inline ::std::string* TokenReq::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    appid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TokenReq.appid)
  return appid_;
}
inline ::std::string* TokenReq::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TokenReq::set_allocated_appid(::std::string* appid) {
  if (appid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete appid_;
  }
  if (appid) {
    set_has_appid();
    appid_ = appid;
  } else {
    clear_has_appid();
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TokenReq.appid)
}

// optional string secret = 3;
inline bool TokenReq::has_secret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TokenReq::set_has_secret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TokenReq::clear_has_secret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TokenReq::clear_secret() {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_->clear();
  }
  clear_has_secret();
}
inline const ::std::string& TokenReq::secret() const {
  // @@protoc_insertion_point(field_get:mpcomm.TokenReq.secret)
  return *secret_;
}
inline void TokenReq::set_secret(const ::std::string& value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TokenReq.secret)
}
inline void TokenReq::set_secret(const char* value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TokenReq.secret)
}
inline void TokenReq::set_secret(const char* value, size_t size) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TokenReq.secret)
}
inline ::std::string* TokenReq::mutable_secret() {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TokenReq.secret)
  return secret_;
}
inline ::std::string* TokenReq::release_secret() {
  clear_has_secret();
  if (secret_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secret_;
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TokenReq::set_allocated_secret(::std::string* secret) {
  if (secret_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secret_;
  }
  if (secret) {
    set_has_secret();
    secret_ = secret;
  } else {
    clear_has_secret();
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TokenReq.secret)
}

// -------------------------------------------------------------------

// TokenResp

// optional int64 errcode = 1;
inline bool TokenResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TokenResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TokenResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 TokenResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.TokenResp.errcode)
  return errcode_;
}
inline void TokenResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.TokenResp.errcode)
}

// optional string errmsg = 2;
inline bool TokenResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TokenResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TokenResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TokenResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& TokenResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.TokenResp.errmsg)
  return *errmsg_;
}
inline void TokenResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TokenResp.errmsg)
}
inline void TokenResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TokenResp.errmsg)
}
inline void TokenResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TokenResp.errmsg)
}
inline ::std::string* TokenResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TokenResp.errmsg)
  return errmsg_;
}
inline ::std::string* TokenResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TokenResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TokenResp.errmsg)
}

// optional string access_token = 3;
inline bool TokenResp::has_access_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TokenResp::set_has_access_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TokenResp::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TokenResp::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& TokenResp::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.TokenResp.access_token)
  return *access_token_;
}
inline void TokenResp::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TokenResp.access_token)
}
inline void TokenResp::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TokenResp.access_token)
}
inline void TokenResp::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TokenResp.access_token)
}
inline ::std::string* TokenResp::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TokenResp.access_token)
  return access_token_;
}
inline ::std::string* TokenResp::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TokenResp::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TokenResp.access_token)
}

// optional uint64 expires_in = 4;
inline bool TokenResp::has_expires_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TokenResp::set_has_expires_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TokenResp::clear_has_expires_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TokenResp::clear_expires_in() {
  expires_in_ = GOOGLE_ULONGLONG(0);
  clear_has_expires_in();
}
inline ::google::protobuf::uint64 TokenResp::expires_in() const {
  // @@protoc_insertion_point(field_get:mpcomm.TokenResp.expires_in)
  return expires_in_;
}
inline void TokenResp::set_expires_in(::google::protobuf::uint64 value) {
  set_has_expires_in();
  expires_in_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.TokenResp.expires_in)
}

// -------------------------------------------------------------------

// GetCallbackIPReq

// optional string access_token = 1;
inline bool GetCallbackIPReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCallbackIPReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCallbackIPReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCallbackIPReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetCallbackIPReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCallbackIPReq.access_token)
  return *access_token_;
}
inline void GetCallbackIPReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetCallbackIPReq.access_token)
}
inline void GetCallbackIPReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetCallbackIPReq.access_token)
}
inline void GetCallbackIPReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetCallbackIPReq.access_token)
}
inline ::std::string* GetCallbackIPReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCallbackIPReq.access_token)
  return access_token_;
}
inline ::std::string* GetCallbackIPReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCallbackIPReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCallbackIPReq.access_token)
}

// -------------------------------------------------------------------

// GetCallbackIPResp

// optional int64 errcode = 1;
inline bool GetCallbackIPResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCallbackIPResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCallbackIPResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCallbackIPResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetCallbackIPResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCallbackIPResp.errcode)
  return errcode_;
}
inline void GetCallbackIPResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetCallbackIPResp.errcode)
}

// optional string errmsg = 2;
inline bool GetCallbackIPResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCallbackIPResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCallbackIPResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCallbackIPResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetCallbackIPResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCallbackIPResp.errmsg)
  return *errmsg_;
}
inline void GetCallbackIPResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetCallbackIPResp.errmsg)
}
inline void GetCallbackIPResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetCallbackIPResp.errmsg)
}
inline void GetCallbackIPResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetCallbackIPResp.errmsg)
}
inline ::std::string* GetCallbackIPResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCallbackIPResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetCallbackIPResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCallbackIPResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCallbackIPResp.errmsg)
}

// repeated string ip_list = 3;
inline int GetCallbackIPResp::ip_list_size() const {
  return ip_list_.size();
}
inline void GetCallbackIPResp::clear_ip_list() {
  ip_list_.Clear();
}
inline const ::std::string& GetCallbackIPResp::ip_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCallbackIPResp.ip_list)
  return ip_list_.Get(index);
}
inline ::std::string* GetCallbackIPResp::mutable_ip_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCallbackIPResp.ip_list)
  return ip_list_.Mutable(index);
}
inline void GetCallbackIPResp::set_ip_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mpcomm.GetCallbackIPResp.ip_list)
  ip_list_.Mutable(index)->assign(value);
}
inline void GetCallbackIPResp::set_ip_list(int index, const char* value) {
  ip_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetCallbackIPResp.ip_list)
}
inline void GetCallbackIPResp::set_ip_list(int index, const char* value, size_t size) {
  ip_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetCallbackIPResp.ip_list)
}
inline ::std::string* GetCallbackIPResp::add_ip_list() {
  return ip_list_.Add();
}
inline void GetCallbackIPResp::add_ip_list(const ::std::string& value) {
  ip_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mpcomm.GetCallbackIPResp.ip_list)
}
inline void GetCallbackIPResp::add_ip_list(const char* value) {
  ip_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mpcomm.GetCallbackIPResp.ip_list)
}
inline void GetCallbackIPResp::add_ip_list(const char* value, size_t size) {
  ip_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mpcomm.GetCallbackIPResp.ip_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetCallbackIPResp::ip_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.GetCallbackIPResp.ip_list)
  return ip_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetCallbackIPResp::mutable_ip_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.GetCallbackIPResp.ip_list)
  return &ip_list_;
}

// -------------------------------------------------------------------

// MenuButton

// optional string type = 1;
inline bool MenuButton::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MenuButton::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MenuButton::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MenuButton::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& MenuButton::type() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuButton.type)
  return *type_;
}
inline void MenuButton::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuButton.type)
}
inline void MenuButton::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuButton.type)
}
inline void MenuButton::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuButton.type)
}
inline ::std::string* MenuButton::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuButton.type)
  return type_;
}
inline ::std::string* MenuButton::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuButton::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuButton.type)
}

// optional string name = 2;
inline bool MenuButton::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MenuButton::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MenuButton::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MenuButton::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MenuButton::name() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuButton.name)
  return *name_;
}
inline void MenuButton::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuButton.name)
}
inline void MenuButton::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuButton.name)
}
inline void MenuButton::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuButton.name)
}
inline ::std::string* MenuButton::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuButton.name)
  return name_;
}
inline ::std::string* MenuButton::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuButton::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuButton.name)
}

// optional string key = 3;
inline bool MenuButton::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MenuButton::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MenuButton::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MenuButton::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& MenuButton::key() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuButton.key)
  return *key_;
}
inline void MenuButton::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuButton.key)
}
inline void MenuButton::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuButton.key)
}
inline void MenuButton::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuButton.key)
}
inline ::std::string* MenuButton::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuButton.key)
  return key_;
}
inline ::std::string* MenuButton::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuButton::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuButton.key)
}

// optional string url = 4;
inline bool MenuButton::has_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MenuButton::set_has_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MenuButton::clear_has_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MenuButton::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& MenuButton::url() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuButton.url)
  return *url_;
}
inline void MenuButton::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuButton.url)
}
inline void MenuButton::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuButton.url)
}
inline void MenuButton::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuButton.url)
}
inline ::std::string* MenuButton::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuButton.url)
  return url_;
}
inline ::std::string* MenuButton::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuButton::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuButton.url)
}

// repeated .mpcomm.MenuButton sub_button = 5;
inline int MenuButton::sub_button_size() const {
  return sub_button_.size();
}
inline void MenuButton::clear_sub_button() {
  sub_button_.Clear();
}
inline const ::mpcomm::MenuButton& MenuButton::sub_button(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuButton.sub_button)
  return sub_button_.Get(index);
}
inline ::mpcomm::MenuButton* MenuButton::mutable_sub_button(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuButton.sub_button)
  return sub_button_.Mutable(index);
}
inline ::mpcomm::MenuButton* MenuButton::add_sub_button() {
  // @@protoc_insertion_point(field_add:mpcomm.MenuButton.sub_button)
  return sub_button_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
MenuButton::sub_button() const {
  // @@protoc_insertion_point(field_list:mpcomm.MenuButton.sub_button)
  return sub_button_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
MenuButton::mutable_sub_button() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.MenuButton.sub_button)
  return &sub_button_;
}

// optional string media_id = 6;
inline bool MenuButton::has_media_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MenuButton::set_has_media_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MenuButton::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MenuButton::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& MenuButton::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuButton.media_id)
  return *media_id_;
}
inline void MenuButton::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuButton.media_id)
}
inline void MenuButton::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuButton.media_id)
}
inline void MenuButton::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuButton.media_id)
}
inline ::std::string* MenuButton::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuButton.media_id)
  return media_id_;
}
inline ::std::string* MenuButton::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuButton::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuButton.media_id)
}

// -------------------------------------------------------------------

// MenuMatchRule

// optional string tag_id = 1;
inline bool MenuMatchRule::has_tag_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MenuMatchRule::set_has_tag_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MenuMatchRule::clear_has_tag_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MenuMatchRule::clear_tag_id() {
  if (tag_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_id_->clear();
  }
  clear_has_tag_id();
}
inline const ::std::string& MenuMatchRule::tag_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuMatchRule.tag_id)
  return *tag_id_;
}
inline void MenuMatchRule::set_tag_id(const ::std::string& value) {
  set_has_tag_id();
  if (tag_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_id_ = new ::std::string;
  }
  tag_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuMatchRule.tag_id)
}
inline void MenuMatchRule::set_tag_id(const char* value) {
  set_has_tag_id();
  if (tag_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_id_ = new ::std::string;
  }
  tag_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuMatchRule.tag_id)
}
inline void MenuMatchRule::set_tag_id(const char* value, size_t size) {
  set_has_tag_id();
  if (tag_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_id_ = new ::std::string;
  }
  tag_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuMatchRule.tag_id)
}
inline ::std::string* MenuMatchRule::mutable_tag_id() {
  set_has_tag_id();
  if (tag_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuMatchRule.tag_id)
  return tag_id_;
}
inline ::std::string* MenuMatchRule::release_tag_id() {
  clear_has_tag_id();
  if (tag_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_id_;
    tag_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuMatchRule::set_allocated_tag_id(::std::string* tag_id) {
  if (tag_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_id_;
  }
  if (tag_id) {
    set_has_tag_id();
    tag_id_ = tag_id;
  } else {
    clear_has_tag_id();
    tag_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuMatchRule.tag_id)
}

// optional string group_id = 8;
inline bool MenuMatchRule::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MenuMatchRule::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MenuMatchRule::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MenuMatchRule::clear_group_id() {
  if (group_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_->clear();
  }
  clear_has_group_id();
}
inline const ::std::string& MenuMatchRule::group_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuMatchRule.group_id)
  return *group_id_;
}
inline void MenuMatchRule::set_group_id(const ::std::string& value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuMatchRule.group_id)
}
inline void MenuMatchRule::set_group_id(const char* value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuMatchRule.group_id)
}
inline void MenuMatchRule::set_group_id(const char* value, size_t size) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuMatchRule.group_id)
}
inline ::std::string* MenuMatchRule::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuMatchRule.group_id)
  return group_id_;
}
inline ::std::string* MenuMatchRule::release_group_id() {
  clear_has_group_id();
  if (group_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_id_;
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuMatchRule::set_allocated_group_id(::std::string* group_id) {
  if (group_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_id_;
  }
  if (group_id) {
    set_has_group_id();
    group_id_ = group_id;
  } else {
    clear_has_group_id();
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuMatchRule.group_id)
}

// optional string sex = 2;
inline bool MenuMatchRule::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MenuMatchRule::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MenuMatchRule::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MenuMatchRule::clear_sex() {
  if (sex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_->clear();
  }
  clear_has_sex();
}
inline const ::std::string& MenuMatchRule::sex() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuMatchRule.sex)
  return *sex_;
}
inline void MenuMatchRule::set_sex(const ::std::string& value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuMatchRule.sex)
}
inline void MenuMatchRule::set_sex(const char* value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuMatchRule.sex)
}
inline void MenuMatchRule::set_sex(const char* value, size_t size) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuMatchRule.sex)
}
inline ::std::string* MenuMatchRule::mutable_sex() {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuMatchRule.sex)
  return sex_;
}
inline ::std::string* MenuMatchRule::release_sex() {
  clear_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sex_;
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuMatchRule::set_allocated_sex(::std::string* sex) {
  if (sex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sex_;
  }
  if (sex) {
    set_has_sex();
    sex_ = sex;
  } else {
    clear_has_sex();
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuMatchRule.sex)
}

// optional string client_platform_type = 3;
inline bool MenuMatchRule::has_client_platform_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MenuMatchRule::set_has_client_platform_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MenuMatchRule::clear_has_client_platform_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MenuMatchRule::clear_client_platform_type() {
  if (client_platform_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_platform_type_->clear();
  }
  clear_has_client_platform_type();
}
inline const ::std::string& MenuMatchRule::client_platform_type() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuMatchRule.client_platform_type)
  return *client_platform_type_;
}
inline void MenuMatchRule::set_client_platform_type(const ::std::string& value) {
  set_has_client_platform_type();
  if (client_platform_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_platform_type_ = new ::std::string;
  }
  client_platform_type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuMatchRule.client_platform_type)
}
inline void MenuMatchRule::set_client_platform_type(const char* value) {
  set_has_client_platform_type();
  if (client_platform_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_platform_type_ = new ::std::string;
  }
  client_platform_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuMatchRule.client_platform_type)
}
inline void MenuMatchRule::set_client_platform_type(const char* value, size_t size) {
  set_has_client_platform_type();
  if (client_platform_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_platform_type_ = new ::std::string;
  }
  client_platform_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuMatchRule.client_platform_type)
}
inline ::std::string* MenuMatchRule::mutable_client_platform_type() {
  set_has_client_platform_type();
  if (client_platform_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_platform_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuMatchRule.client_platform_type)
  return client_platform_type_;
}
inline ::std::string* MenuMatchRule::release_client_platform_type() {
  clear_has_client_platform_type();
  if (client_platform_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_platform_type_;
    client_platform_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuMatchRule::set_allocated_client_platform_type(::std::string* client_platform_type) {
  if (client_platform_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_platform_type_;
  }
  if (client_platform_type) {
    set_has_client_platform_type();
    client_platform_type_ = client_platform_type;
  } else {
    clear_has_client_platform_type();
    client_platform_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuMatchRule.client_platform_type)
}

// optional string country = 4;
inline bool MenuMatchRule::has_country() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MenuMatchRule::set_has_country() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MenuMatchRule::clear_has_country() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MenuMatchRule::clear_country() {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& MenuMatchRule::country() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuMatchRule.country)
  return *country_;
}
inline void MenuMatchRule::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuMatchRule.country)
}
inline void MenuMatchRule::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuMatchRule.country)
}
inline void MenuMatchRule::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuMatchRule.country)
}
inline ::std::string* MenuMatchRule::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuMatchRule.country)
  return country_;
}
inline ::std::string* MenuMatchRule::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuMatchRule::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuMatchRule.country)
}

// optional string province = 5;
inline bool MenuMatchRule::has_province() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MenuMatchRule::set_has_province() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MenuMatchRule::clear_has_province() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MenuMatchRule::clear_province() {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& MenuMatchRule::province() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuMatchRule.province)
  return *province_;
}
inline void MenuMatchRule::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuMatchRule.province)
}
inline void MenuMatchRule::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuMatchRule.province)
}
inline void MenuMatchRule::set_province(const char* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuMatchRule.province)
}
inline ::std::string* MenuMatchRule::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuMatchRule.province)
  return province_;
}
inline ::std::string* MenuMatchRule::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuMatchRule::set_allocated_province(::std::string* province) {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete province_;
  }
  if (province) {
    set_has_province();
    province_ = province;
  } else {
    clear_has_province();
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuMatchRule.province)
}

// optional string city = 6;
inline bool MenuMatchRule::has_city() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MenuMatchRule::set_has_city() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MenuMatchRule::clear_has_city() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MenuMatchRule::clear_city() {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& MenuMatchRule::city() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuMatchRule.city)
  return *city_;
}
inline void MenuMatchRule::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuMatchRule.city)
}
inline void MenuMatchRule::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuMatchRule.city)
}
inline void MenuMatchRule::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuMatchRule.city)
}
inline ::std::string* MenuMatchRule::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuMatchRule.city)
  return city_;
}
inline ::std::string* MenuMatchRule::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuMatchRule::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuMatchRule.city)
}

// optional string language = 7;
inline bool MenuMatchRule::has_language() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MenuMatchRule::set_has_language() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MenuMatchRule::clear_has_language() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MenuMatchRule::clear_language() {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& MenuMatchRule::language() const {
  // @@protoc_insertion_point(field_get:mpcomm.MenuMatchRule.language)
  return *language_;
}
inline void MenuMatchRule::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MenuMatchRule.language)
}
inline void MenuMatchRule::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MenuMatchRule.language)
}
inline void MenuMatchRule::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MenuMatchRule.language)
}
inline ::std::string* MenuMatchRule::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MenuMatchRule.language)
  return language_;
}
inline ::std::string* MenuMatchRule::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MenuMatchRule::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MenuMatchRule.language)
}

// -------------------------------------------------------------------

// Menu

// repeated .mpcomm.MenuButton button = 1;
inline int Menu::button_size() const {
  return button_.size();
}
inline void Menu::clear_button() {
  button_.Clear();
}
inline const ::mpcomm::MenuButton& Menu::button(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.Menu.button)
  return button_.Get(index);
}
inline ::mpcomm::MenuButton* Menu::mutable_button(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.Menu.button)
  return button_.Mutable(index);
}
inline ::mpcomm::MenuButton* Menu::add_button() {
  // @@protoc_insertion_point(field_add:mpcomm.Menu.button)
  return button_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
Menu::button() const {
  // @@protoc_insertion_point(field_list:mpcomm.Menu.button)
  return button_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
Menu::mutable_button() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.Menu.button)
  return &button_;
}

// optional .mpcomm.MenuMatchRule matchrule = 2;
inline bool Menu::has_matchrule() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Menu::set_has_matchrule() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Menu::clear_has_matchrule() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Menu::clear_matchrule() {
  if (matchrule_ != NULL) matchrule_->::mpcomm::MenuMatchRule::Clear();
  clear_has_matchrule();
}
inline const ::mpcomm::MenuMatchRule& Menu::matchrule() const {
  // @@protoc_insertion_point(field_get:mpcomm.Menu.matchrule)
  return matchrule_ != NULL ? *matchrule_ : *default_instance_->matchrule_;
}
inline ::mpcomm::MenuMatchRule* Menu::mutable_matchrule() {
  set_has_matchrule();
  if (matchrule_ == NULL) matchrule_ = new ::mpcomm::MenuMatchRule;
  // @@protoc_insertion_point(field_mutable:mpcomm.Menu.matchrule)
  return matchrule_;
}
inline ::mpcomm::MenuMatchRule* Menu::release_matchrule() {
  clear_has_matchrule();
  ::mpcomm::MenuMatchRule* temp = matchrule_;
  matchrule_ = NULL;
  return temp;
}
inline void Menu::set_allocated_matchrule(::mpcomm::MenuMatchRule* matchrule) {
  delete matchrule_;
  matchrule_ = matchrule;
  if (matchrule) {
    set_has_matchrule();
  } else {
    clear_has_matchrule();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Menu.matchrule)
}

// optional uint64 menuid = 3;
inline bool Menu::has_menuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Menu::set_has_menuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Menu::clear_has_menuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Menu::clear_menuid() {
  menuid_ = GOOGLE_ULONGLONG(0);
  clear_has_menuid();
}
inline ::google::protobuf::uint64 Menu::menuid() const {
  // @@protoc_insertion_point(field_get:mpcomm.Menu.menuid)
  return menuid_;
}
inline void Menu::set_menuid(::google::protobuf::uint64 value) {
  set_has_menuid();
  menuid_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.Menu.menuid)
}

// -------------------------------------------------------------------

// CreateMenuReq

// optional string access_token = 1;
inline bool CreateMenuReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateMenuReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateMenuReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateMenuReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& CreateMenuReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.CreateMenuReq.access_token)
  return *access_token_;
}
inline void CreateMenuReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CreateMenuReq.access_token)
}
inline void CreateMenuReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CreateMenuReq.access_token)
}
inline void CreateMenuReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CreateMenuReq.access_token)
}
inline ::std::string* CreateMenuReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CreateMenuReq.access_token)
  return access_token_;
}
inline ::std::string* CreateMenuReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateMenuReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CreateMenuReq.access_token)
}

// repeated .mpcomm.MenuButton button = 2;
inline int CreateMenuReq::button_size() const {
  return button_.size();
}
inline void CreateMenuReq::clear_button() {
  button_.Clear();
}
inline const ::mpcomm::MenuButton& CreateMenuReq::button(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.CreateMenuReq.button)
  return button_.Get(index);
}
inline ::mpcomm::MenuButton* CreateMenuReq::mutable_button(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.CreateMenuReq.button)
  return button_.Mutable(index);
}
inline ::mpcomm::MenuButton* CreateMenuReq::add_button() {
  // @@protoc_insertion_point(field_add:mpcomm.CreateMenuReq.button)
  return button_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
CreateMenuReq::button() const {
  // @@protoc_insertion_point(field_list:mpcomm.CreateMenuReq.button)
  return button_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
CreateMenuReq::mutable_button() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.CreateMenuReq.button)
  return &button_;
}

// -------------------------------------------------------------------

// CreateMenuResp

// optional int64 errcode = 1;
inline bool CreateMenuResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateMenuResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateMenuResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateMenuResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 CreateMenuResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.CreateMenuResp.errcode)
  return errcode_;
}
inline void CreateMenuResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.CreateMenuResp.errcode)
}

// optional string errmsg = 2;
inline bool CreateMenuResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateMenuResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateMenuResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateMenuResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& CreateMenuResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.CreateMenuResp.errmsg)
  return *errmsg_;
}
inline void CreateMenuResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CreateMenuResp.errmsg)
}
inline void CreateMenuResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CreateMenuResp.errmsg)
}
inline void CreateMenuResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CreateMenuResp.errmsg)
}
inline ::std::string* CreateMenuResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CreateMenuResp.errmsg)
  return errmsg_;
}
inline ::std::string* CreateMenuResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateMenuResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CreateMenuResp.errmsg)
}

// -------------------------------------------------------------------

// GetMenuReq

// optional string access_token = 1;
inline bool GetMenuReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMenuReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMenuReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMenuReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetMenuReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMenuReq.access_token)
  return *access_token_;
}
inline void GetMenuReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMenuReq.access_token)
}
inline void GetMenuReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMenuReq.access_token)
}
inline void GetMenuReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMenuReq.access_token)
}
inline ::std::string* GetMenuReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMenuReq.access_token)
  return access_token_;
}
inline ::std::string* GetMenuReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMenuReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMenuReq.access_token)
}

// -------------------------------------------------------------------

// GetMenuResp

// optional int64 errcode = 1;
inline bool GetMenuResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMenuResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMenuResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMenuResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetMenuResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMenuResp.errcode)
  return errcode_;
}
inline void GetMenuResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetMenuResp.errcode)
}

// optional string errmsg = 2;
inline bool GetMenuResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMenuResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMenuResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMenuResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetMenuResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMenuResp.errmsg)
  return *errmsg_;
}
inline void GetMenuResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMenuResp.errmsg)
}
inline void GetMenuResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMenuResp.errmsg)
}
inline void GetMenuResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMenuResp.errmsg)
}
inline ::std::string* GetMenuResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMenuResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetMenuResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMenuResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMenuResp.errmsg)
}

// optional .mpcomm.Menu menu = 3;
inline bool GetMenuResp::has_menu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetMenuResp::set_has_menu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetMenuResp::clear_has_menu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetMenuResp::clear_menu() {
  if (menu_ != NULL) menu_->::mpcomm::Menu::Clear();
  clear_has_menu();
}
inline const ::mpcomm::Menu& GetMenuResp::menu() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMenuResp.menu)
  return menu_ != NULL ? *menu_ : *default_instance_->menu_;
}
inline ::mpcomm::Menu* GetMenuResp::mutable_menu() {
  set_has_menu();
  if (menu_ == NULL) menu_ = new ::mpcomm::Menu;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMenuResp.menu)
  return menu_;
}
inline ::mpcomm::Menu* GetMenuResp::release_menu() {
  clear_has_menu();
  ::mpcomm::Menu* temp = menu_;
  menu_ = NULL;
  return temp;
}
inline void GetMenuResp::set_allocated_menu(::mpcomm::Menu* menu) {
  delete menu_;
  menu_ = menu;
  if (menu) {
    set_has_menu();
  } else {
    clear_has_menu();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMenuResp.menu)
}

// repeated .mpcomm.Menu conditionalmenu = 4;
inline int GetMenuResp::conditionalmenu_size() const {
  return conditionalmenu_.size();
}
inline void GetMenuResp::clear_conditionalmenu() {
  conditionalmenu_.Clear();
}
inline const ::mpcomm::Menu& GetMenuResp::conditionalmenu(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMenuResp.conditionalmenu)
  return conditionalmenu_.Get(index);
}
inline ::mpcomm::Menu* GetMenuResp::mutable_conditionalmenu(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMenuResp.conditionalmenu)
  return conditionalmenu_.Mutable(index);
}
inline ::mpcomm::Menu* GetMenuResp::add_conditionalmenu() {
  // @@protoc_insertion_point(field_add:mpcomm.GetMenuResp.conditionalmenu)
  return conditionalmenu_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::Menu >&
GetMenuResp::conditionalmenu() const {
  // @@protoc_insertion_point(field_list:mpcomm.GetMenuResp.conditionalmenu)
  return conditionalmenu_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::Menu >*
GetMenuResp::mutable_conditionalmenu() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.GetMenuResp.conditionalmenu)
  return &conditionalmenu_;
}

// -------------------------------------------------------------------

// DeleteMenuReq

// optional string access_token = 1;
inline bool DeleteMenuReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteMenuReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteMenuReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteMenuReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& DeleteMenuReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.DeleteMenuReq.access_token)
  return *access_token_;
}
inline void DeleteMenuReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DeleteMenuReq.access_token)
}
inline void DeleteMenuReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DeleteMenuReq.access_token)
}
inline void DeleteMenuReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DeleteMenuReq.access_token)
}
inline ::std::string* DeleteMenuReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DeleteMenuReq.access_token)
  return access_token_;
}
inline ::std::string* DeleteMenuReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteMenuReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DeleteMenuReq.access_token)
}

// -------------------------------------------------------------------

// DeleteMenuResp

// optional int64 errcode = 1;
inline bool DeleteMenuResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteMenuResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteMenuResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteMenuResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 DeleteMenuResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.DeleteMenuResp.errcode)
  return errcode_;
}
inline void DeleteMenuResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.DeleteMenuResp.errcode)
}

// optional string errmsg = 2;
inline bool DeleteMenuResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteMenuResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteMenuResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteMenuResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& DeleteMenuResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.DeleteMenuResp.errmsg)
  return *errmsg_;
}
inline void DeleteMenuResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DeleteMenuResp.errmsg)
}
inline void DeleteMenuResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DeleteMenuResp.errmsg)
}
inline void DeleteMenuResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DeleteMenuResp.errmsg)
}
inline ::std::string* DeleteMenuResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DeleteMenuResp.errmsg)
  return errmsg_;
}
inline ::std::string* DeleteMenuResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteMenuResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DeleteMenuResp.errmsg)
}

// -------------------------------------------------------------------

// AddConditionalMenuReq

// optional string access_token = 1;
inline bool AddConditionalMenuReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddConditionalMenuReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddConditionalMenuReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddConditionalMenuReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& AddConditionalMenuReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddConditionalMenuReq.access_token)
  return *access_token_;
}
inline void AddConditionalMenuReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddConditionalMenuReq.access_token)
}
inline void AddConditionalMenuReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddConditionalMenuReq.access_token)
}
inline void AddConditionalMenuReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddConditionalMenuReq.access_token)
}
inline ::std::string* AddConditionalMenuReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddConditionalMenuReq.access_token)
  return access_token_;
}
inline ::std::string* AddConditionalMenuReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddConditionalMenuReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddConditionalMenuReq.access_token)
}

// repeated .mpcomm.MenuButton button = 2;
inline int AddConditionalMenuReq::button_size() const {
  return button_.size();
}
inline void AddConditionalMenuReq::clear_button() {
  button_.Clear();
}
inline const ::mpcomm::MenuButton& AddConditionalMenuReq::button(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.AddConditionalMenuReq.button)
  return button_.Get(index);
}
inline ::mpcomm::MenuButton* AddConditionalMenuReq::mutable_button(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.AddConditionalMenuReq.button)
  return button_.Mutable(index);
}
inline ::mpcomm::MenuButton* AddConditionalMenuReq::add_button() {
  // @@protoc_insertion_point(field_add:mpcomm.AddConditionalMenuReq.button)
  return button_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
AddConditionalMenuReq::button() const {
  // @@protoc_insertion_point(field_list:mpcomm.AddConditionalMenuReq.button)
  return button_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
AddConditionalMenuReq::mutable_button() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.AddConditionalMenuReq.button)
  return &button_;
}

// optional .mpcomm.MenuMatchRule matchrule = 3;
inline bool AddConditionalMenuReq::has_matchrule() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddConditionalMenuReq::set_has_matchrule() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddConditionalMenuReq::clear_has_matchrule() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddConditionalMenuReq::clear_matchrule() {
  if (matchrule_ != NULL) matchrule_->::mpcomm::MenuMatchRule::Clear();
  clear_has_matchrule();
}
inline const ::mpcomm::MenuMatchRule& AddConditionalMenuReq::matchrule() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddConditionalMenuReq.matchrule)
  return matchrule_ != NULL ? *matchrule_ : *default_instance_->matchrule_;
}
inline ::mpcomm::MenuMatchRule* AddConditionalMenuReq::mutable_matchrule() {
  set_has_matchrule();
  if (matchrule_ == NULL) matchrule_ = new ::mpcomm::MenuMatchRule;
  // @@protoc_insertion_point(field_mutable:mpcomm.AddConditionalMenuReq.matchrule)
  return matchrule_;
}
inline ::mpcomm::MenuMatchRule* AddConditionalMenuReq::release_matchrule() {
  clear_has_matchrule();
  ::mpcomm::MenuMatchRule* temp = matchrule_;
  matchrule_ = NULL;
  return temp;
}
inline void AddConditionalMenuReq::set_allocated_matchrule(::mpcomm::MenuMatchRule* matchrule) {
  delete matchrule_;
  matchrule_ = matchrule;
  if (matchrule) {
    set_has_matchrule();
  } else {
    clear_has_matchrule();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddConditionalMenuReq.matchrule)
}

// -------------------------------------------------------------------

// AddConditionalMenuResp

// optional int64 errcode = 1;
inline bool AddConditionalMenuResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddConditionalMenuResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddConditionalMenuResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddConditionalMenuResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 AddConditionalMenuResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddConditionalMenuResp.errcode)
  return errcode_;
}
inline void AddConditionalMenuResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.AddConditionalMenuResp.errcode)
}

// optional string errmsg = 2;
inline bool AddConditionalMenuResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddConditionalMenuResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddConditionalMenuResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddConditionalMenuResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& AddConditionalMenuResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddConditionalMenuResp.errmsg)
  return *errmsg_;
}
inline void AddConditionalMenuResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddConditionalMenuResp.errmsg)
}
inline void AddConditionalMenuResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddConditionalMenuResp.errmsg)
}
inline void AddConditionalMenuResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddConditionalMenuResp.errmsg)
}
inline ::std::string* AddConditionalMenuResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddConditionalMenuResp.errmsg)
  return errmsg_;
}
inline ::std::string* AddConditionalMenuResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddConditionalMenuResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddConditionalMenuResp.errmsg)
}

// optional uint64 menuid = 3;
inline bool AddConditionalMenuResp::has_menuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddConditionalMenuResp::set_has_menuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddConditionalMenuResp::clear_has_menuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddConditionalMenuResp::clear_menuid() {
  menuid_ = GOOGLE_ULONGLONG(0);
  clear_has_menuid();
}
inline ::google::protobuf::uint64 AddConditionalMenuResp::menuid() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddConditionalMenuResp.menuid)
  return menuid_;
}
inline void AddConditionalMenuResp::set_menuid(::google::protobuf::uint64 value) {
  set_has_menuid();
  menuid_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.AddConditionalMenuResp.menuid)
}

// -------------------------------------------------------------------

// DelConditionalMenuReq

// optional string access_token = 1;
inline bool DelConditionalMenuReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelConditionalMenuReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelConditionalMenuReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelConditionalMenuReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& DelConditionalMenuReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelConditionalMenuReq.access_token)
  return *access_token_;
}
inline void DelConditionalMenuReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DelConditionalMenuReq.access_token)
}
inline void DelConditionalMenuReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DelConditionalMenuReq.access_token)
}
inline void DelConditionalMenuReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DelConditionalMenuReq.access_token)
}
inline ::std::string* DelConditionalMenuReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DelConditionalMenuReq.access_token)
  return access_token_;
}
inline ::std::string* DelConditionalMenuReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DelConditionalMenuReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DelConditionalMenuReq.access_token)
}

// optional uint64 menuid = 2;
inline bool DelConditionalMenuReq::has_menuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelConditionalMenuReq::set_has_menuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelConditionalMenuReq::clear_has_menuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelConditionalMenuReq::clear_menuid() {
  menuid_ = GOOGLE_ULONGLONG(0);
  clear_has_menuid();
}
inline ::google::protobuf::uint64 DelConditionalMenuReq::menuid() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelConditionalMenuReq.menuid)
  return menuid_;
}
inline void DelConditionalMenuReq::set_menuid(::google::protobuf::uint64 value) {
  set_has_menuid();
  menuid_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.DelConditionalMenuReq.menuid)
}

// -------------------------------------------------------------------

// DelConditionalMenuResp

// optional int64 errcode = 1;
inline bool DelConditionalMenuResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelConditionalMenuResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelConditionalMenuResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelConditionalMenuResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 DelConditionalMenuResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelConditionalMenuResp.errcode)
  return errcode_;
}
inline void DelConditionalMenuResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.DelConditionalMenuResp.errcode)
}

// optional string errmsg = 2;
inline bool DelConditionalMenuResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelConditionalMenuResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelConditionalMenuResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelConditionalMenuResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& DelConditionalMenuResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelConditionalMenuResp.errmsg)
  return *errmsg_;
}
inline void DelConditionalMenuResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DelConditionalMenuResp.errmsg)
}
inline void DelConditionalMenuResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DelConditionalMenuResp.errmsg)
}
inline void DelConditionalMenuResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DelConditionalMenuResp.errmsg)
}
inline ::std::string* DelConditionalMenuResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DelConditionalMenuResp.errmsg)
  return errmsg_;
}
inline ::std::string* DelConditionalMenuResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DelConditionalMenuResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DelConditionalMenuResp.errmsg)
}

// -------------------------------------------------------------------

// TryMatchMenuReq

// optional string access_token = 1;
inline bool TryMatchMenuReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TryMatchMenuReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TryMatchMenuReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TryMatchMenuReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& TryMatchMenuReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.TryMatchMenuReq.access_token)
  return *access_token_;
}
inline void TryMatchMenuReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TryMatchMenuReq.access_token)
}
inline void TryMatchMenuReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TryMatchMenuReq.access_token)
}
inline void TryMatchMenuReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TryMatchMenuReq.access_token)
}
inline ::std::string* TryMatchMenuReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TryMatchMenuReq.access_token)
  return access_token_;
}
inline ::std::string* TryMatchMenuReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TryMatchMenuReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TryMatchMenuReq.access_token)
}

// optional string user_id = 2;
inline bool TryMatchMenuReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TryMatchMenuReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TryMatchMenuReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TryMatchMenuReq::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& TryMatchMenuReq::user_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.TryMatchMenuReq.user_id)
  return *user_id_;
}
inline void TryMatchMenuReq::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TryMatchMenuReq.user_id)
}
inline void TryMatchMenuReq::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TryMatchMenuReq.user_id)
}
inline void TryMatchMenuReq::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TryMatchMenuReq.user_id)
}
inline ::std::string* TryMatchMenuReq::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TryMatchMenuReq.user_id)
  return user_id_;
}
inline ::std::string* TryMatchMenuReq::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TryMatchMenuReq::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TryMatchMenuReq.user_id)
}

// -------------------------------------------------------------------

// TryMatchMenuResp

// optional int64 errcode = 1;
inline bool TryMatchMenuResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TryMatchMenuResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TryMatchMenuResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TryMatchMenuResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 TryMatchMenuResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.TryMatchMenuResp.errcode)
  return errcode_;
}
inline void TryMatchMenuResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.TryMatchMenuResp.errcode)
}

// optional string errmsg = 2;
inline bool TryMatchMenuResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TryMatchMenuResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TryMatchMenuResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TryMatchMenuResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& TryMatchMenuResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.TryMatchMenuResp.errmsg)
  return *errmsg_;
}
inline void TryMatchMenuResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.TryMatchMenuResp.errmsg)
}
inline void TryMatchMenuResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TryMatchMenuResp.errmsg)
}
inline void TryMatchMenuResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TryMatchMenuResp.errmsg)
}
inline ::std::string* TryMatchMenuResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.TryMatchMenuResp.errmsg)
  return errmsg_;
}
inline ::std::string* TryMatchMenuResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TryMatchMenuResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.TryMatchMenuResp.errmsg)
}

// repeated .mpcomm.MenuButton button = 3;
inline int TryMatchMenuResp::button_size() const {
  return button_.size();
}
inline void TryMatchMenuResp::clear_button() {
  button_.Clear();
}
inline const ::mpcomm::MenuButton& TryMatchMenuResp::button(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.TryMatchMenuResp.button)
  return button_.Get(index);
}
inline ::mpcomm::MenuButton* TryMatchMenuResp::mutable_button(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.TryMatchMenuResp.button)
  return button_.Mutable(index);
}
inline ::mpcomm::MenuButton* TryMatchMenuResp::add_button() {
  // @@protoc_insertion_point(field_add:mpcomm.TryMatchMenuResp.button)
  return button_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >&
TryMatchMenuResp::button() const {
  // @@protoc_insertion_point(field_list:mpcomm.TryMatchMenuResp.button)
  return button_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MenuButton >*
TryMatchMenuResp::mutable_button() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.TryMatchMenuResp.button)
  return &button_;
}

// -------------------------------------------------------------------

// GetCurrentSelfMenuInfoReq

// optional string access_token = 1;
inline bool GetCurrentSelfMenuInfoReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCurrentSelfMenuInfoReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCurrentSelfMenuInfoReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCurrentSelfMenuInfoReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetCurrentSelfMenuInfoReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentSelfMenuInfoReq.access_token)
  return *access_token_;
}
inline void GetCurrentSelfMenuInfoReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetCurrentSelfMenuInfoReq.access_token)
}
inline void GetCurrentSelfMenuInfoReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetCurrentSelfMenuInfoReq.access_token)
}
inline void GetCurrentSelfMenuInfoReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetCurrentSelfMenuInfoReq.access_token)
}
inline ::std::string* GetCurrentSelfMenuInfoReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCurrentSelfMenuInfoReq.access_token)
  return access_token_;
}
inline ::std::string* GetCurrentSelfMenuInfoReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCurrentSelfMenuInfoReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCurrentSelfMenuInfoReq.access_token)
}

// -------------------------------------------------------------------

// RespNews

// optional string title = 1;
inline bool RespNews::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespNews::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespNews::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespNews::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& RespNews::title() const {
  // @@protoc_insertion_point(field_get:mpcomm.RespNews.title)
  return *title_;
}
inline void RespNews::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.RespNews.title)
}
inline void RespNews::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.RespNews.title)
}
inline void RespNews::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.RespNews.title)
}
inline ::std::string* RespNews::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.RespNews.title)
  return title_;
}
inline ::std::string* RespNews::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespNews::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.RespNews.title)
}

// optional string author = 2;
inline bool RespNews::has_author() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespNews::set_has_author() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespNews::clear_has_author() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespNews::clear_author() {
  if (author_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_->clear();
  }
  clear_has_author();
}
inline const ::std::string& RespNews::author() const {
  // @@protoc_insertion_point(field_get:mpcomm.RespNews.author)
  return *author_;
}
inline void RespNews::set_author(const ::std::string& value) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  author_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.RespNews.author)
}
inline void RespNews::set_author(const char* value) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  author_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.RespNews.author)
}
inline void RespNews::set_author(const char* value, size_t size) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  author_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.RespNews.author)
}
inline ::std::string* RespNews::mutable_author() {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.RespNews.author)
  return author_;
}
inline ::std::string* RespNews::release_author() {
  clear_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = author_;
    author_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespNews::set_allocated_author(::std::string* author) {
  if (author_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete author_;
  }
  if (author) {
    set_has_author();
    author_ = author;
  } else {
    clear_has_author();
    author_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.RespNews.author)
}

// optional string digest = 3;
inline bool RespNews::has_digest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespNews::set_has_digest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespNews::clear_has_digest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespNews::clear_digest() {
  if (digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_->clear();
  }
  clear_has_digest();
}
inline const ::std::string& RespNews::digest() const {
  // @@protoc_insertion_point(field_get:mpcomm.RespNews.digest)
  return *digest_;
}
inline void RespNews::set_digest(const ::std::string& value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.RespNews.digest)
}
inline void RespNews::set_digest(const char* value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.RespNews.digest)
}
inline void RespNews::set_digest(const char* value, size_t size) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  digest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.RespNews.digest)
}
inline ::std::string* RespNews::mutable_digest() {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.RespNews.digest)
  return digest_;
}
inline ::std::string* RespNews::release_digest() {
  clear_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = digest_;
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespNews::set_allocated_digest(::std::string* digest) {
  if (digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete digest_;
  }
  if (digest) {
    set_has_digest();
    digest_ = digest;
  } else {
    clear_has_digest();
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.RespNews.digest)
}

// optional uint64 show_cover = 4;
inline bool RespNews::has_show_cover() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RespNews::set_has_show_cover() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RespNews::clear_has_show_cover() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RespNews::clear_show_cover() {
  show_cover_ = GOOGLE_ULONGLONG(0);
  clear_has_show_cover();
}
inline ::google::protobuf::uint64 RespNews::show_cover() const {
  // @@protoc_insertion_point(field_get:mpcomm.RespNews.show_cover)
  return show_cover_;
}
inline void RespNews::set_show_cover(::google::protobuf::uint64 value) {
  set_has_show_cover();
  show_cover_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.RespNews.show_cover)
}

// optional string cover_url = 5;
inline bool RespNews::has_cover_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RespNews::set_has_cover_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RespNews::clear_has_cover_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RespNews::clear_cover_url() {
  if (cover_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_url_->clear();
  }
  clear_has_cover_url();
}
inline const ::std::string& RespNews::cover_url() const {
  // @@protoc_insertion_point(field_get:mpcomm.RespNews.cover_url)
  return *cover_url_;
}
inline void RespNews::set_cover_url(const ::std::string& value) {
  set_has_cover_url();
  if (cover_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_url_ = new ::std::string;
  }
  cover_url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.RespNews.cover_url)
}
inline void RespNews::set_cover_url(const char* value) {
  set_has_cover_url();
  if (cover_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_url_ = new ::std::string;
  }
  cover_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.RespNews.cover_url)
}
inline void RespNews::set_cover_url(const char* value, size_t size) {
  set_has_cover_url();
  if (cover_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_url_ = new ::std::string;
  }
  cover_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.RespNews.cover_url)
}
inline ::std::string* RespNews::mutable_cover_url() {
  set_has_cover_url();
  if (cover_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cover_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.RespNews.cover_url)
  return cover_url_;
}
inline ::std::string* RespNews::release_cover_url() {
  clear_has_cover_url();
  if (cover_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cover_url_;
    cover_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespNews::set_allocated_cover_url(::std::string* cover_url) {
  if (cover_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cover_url_;
  }
  if (cover_url) {
    set_has_cover_url();
    cover_url_ = cover_url;
  } else {
    clear_has_cover_url();
    cover_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.RespNews.cover_url)
}

// optional string content_url = 6;
inline bool RespNews::has_content_url() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RespNews::set_has_content_url() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RespNews::clear_has_content_url() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RespNews::clear_content_url() {
  if (content_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_url_->clear();
  }
  clear_has_content_url();
}
inline const ::std::string& RespNews::content_url() const {
  // @@protoc_insertion_point(field_get:mpcomm.RespNews.content_url)
  return *content_url_;
}
inline void RespNews::set_content_url(const ::std::string& value) {
  set_has_content_url();
  if (content_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_url_ = new ::std::string;
  }
  content_url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.RespNews.content_url)
}
inline void RespNews::set_content_url(const char* value) {
  set_has_content_url();
  if (content_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_url_ = new ::std::string;
  }
  content_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.RespNews.content_url)
}
inline void RespNews::set_content_url(const char* value, size_t size) {
  set_has_content_url();
  if (content_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_url_ = new ::std::string;
  }
  content_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.RespNews.content_url)
}
inline ::std::string* RespNews::mutable_content_url() {
  set_has_content_url();
  if (content_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.RespNews.content_url)
  return content_url_;
}
inline ::std::string* RespNews::release_content_url() {
  clear_has_content_url();
  if (content_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_url_;
    content_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespNews::set_allocated_content_url(::std::string* content_url) {
  if (content_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_url_;
  }
  if (content_url) {
    set_has_content_url();
    content_url_ = content_url;
  } else {
    clear_has_content_url();
    content_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.RespNews.content_url)
}

// optional string source_url = 7;
inline bool RespNews::has_source_url() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RespNews::set_has_source_url() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RespNews::clear_has_source_url() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RespNews::clear_source_url() {
  if (source_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_url_->clear();
  }
  clear_has_source_url();
}
inline const ::std::string& RespNews::source_url() const {
  // @@protoc_insertion_point(field_get:mpcomm.RespNews.source_url)
  return *source_url_;
}
inline void RespNews::set_source_url(const ::std::string& value) {
  set_has_source_url();
  if (source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_url_ = new ::std::string;
  }
  source_url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.RespNews.source_url)
}
inline void RespNews::set_source_url(const char* value) {
  set_has_source_url();
  if (source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_url_ = new ::std::string;
  }
  source_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.RespNews.source_url)
}
inline void RespNews::set_source_url(const char* value, size_t size) {
  set_has_source_url();
  if (source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_url_ = new ::std::string;
  }
  source_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.RespNews.source_url)
}
inline ::std::string* RespNews::mutable_source_url() {
  set_has_source_url();
  if (source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.RespNews.source_url)
  return source_url_;
}
inline ::std::string* RespNews::release_source_url() {
  clear_has_source_url();
  if (source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_url_;
    source_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespNews::set_allocated_source_url(::std::string* source_url) {
  if (source_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_url_;
  }
  if (source_url) {
    set_has_source_url();
    source_url_ = source_url;
  } else {
    clear_has_source_url();
    source_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.RespNews.source_url)
}

// -------------------------------------------------------------------

// RespNewsList

// repeated .mpcomm.RespNews list = 1;
inline int RespNewsList::list_size() const {
  return list_.size();
}
inline void RespNewsList::clear_list() {
  list_.Clear();
}
inline const ::mpcomm::RespNews& RespNewsList::list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.RespNewsList.list)
  return list_.Get(index);
}
inline ::mpcomm::RespNews* RespNewsList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.RespNewsList.list)
  return list_.Mutable(index);
}
inline ::mpcomm::RespNews* RespNewsList::add_list() {
  // @@protoc_insertion_point(field_add:mpcomm.RespNewsList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::RespNews >&
RespNewsList::list() const {
  // @@protoc_insertion_point(field_list:mpcomm.RespNewsList.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::RespNews >*
RespNewsList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.RespNewsList.list)
  return &list_;
}

// -------------------------------------------------------------------

// CurrentSelfMenuButton

// optional string type = 1;
inline bool CurrentSelfMenuButton::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrentSelfMenuButton::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrentSelfMenuButton::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrentSelfMenuButton::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& CurrentSelfMenuButton::type() const {
  // @@protoc_insertion_point(field_get:mpcomm.CurrentSelfMenuButton.type)
  return *type_;
}
inline void CurrentSelfMenuButton::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CurrentSelfMenuButton.type)
}
inline void CurrentSelfMenuButton::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CurrentSelfMenuButton.type)
}
inline void CurrentSelfMenuButton::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CurrentSelfMenuButton.type)
}
inline ::std::string* CurrentSelfMenuButton::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CurrentSelfMenuButton.type)
  return type_;
}
inline ::std::string* CurrentSelfMenuButton::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CurrentSelfMenuButton::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CurrentSelfMenuButton.type)
}

// optional string name = 2;
inline bool CurrentSelfMenuButton::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrentSelfMenuButton::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrentSelfMenuButton::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrentSelfMenuButton::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CurrentSelfMenuButton::name() const {
  // @@protoc_insertion_point(field_get:mpcomm.CurrentSelfMenuButton.name)
  return *name_;
}
inline void CurrentSelfMenuButton::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CurrentSelfMenuButton.name)
}
inline void CurrentSelfMenuButton::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CurrentSelfMenuButton.name)
}
inline void CurrentSelfMenuButton::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CurrentSelfMenuButton.name)
}
inline ::std::string* CurrentSelfMenuButton::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CurrentSelfMenuButton.name)
  return name_;
}
inline ::std::string* CurrentSelfMenuButton::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CurrentSelfMenuButton::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CurrentSelfMenuButton.name)
}

// optional string key = 3;
inline bool CurrentSelfMenuButton::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CurrentSelfMenuButton::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CurrentSelfMenuButton::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CurrentSelfMenuButton::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CurrentSelfMenuButton::key() const {
  // @@protoc_insertion_point(field_get:mpcomm.CurrentSelfMenuButton.key)
  return *key_;
}
inline void CurrentSelfMenuButton::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CurrentSelfMenuButton.key)
}
inline void CurrentSelfMenuButton::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CurrentSelfMenuButton.key)
}
inline void CurrentSelfMenuButton::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CurrentSelfMenuButton.key)
}
inline ::std::string* CurrentSelfMenuButton::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CurrentSelfMenuButton.key)
  return key_;
}
inline ::std::string* CurrentSelfMenuButton::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CurrentSelfMenuButton::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CurrentSelfMenuButton.key)
}

// optional string url = 4;
inline bool CurrentSelfMenuButton::has_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CurrentSelfMenuButton::set_has_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CurrentSelfMenuButton::clear_has_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CurrentSelfMenuButton::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& CurrentSelfMenuButton::url() const {
  // @@protoc_insertion_point(field_get:mpcomm.CurrentSelfMenuButton.url)
  return *url_;
}
inline void CurrentSelfMenuButton::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CurrentSelfMenuButton.url)
}
inline void CurrentSelfMenuButton::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CurrentSelfMenuButton.url)
}
inline void CurrentSelfMenuButton::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CurrentSelfMenuButton.url)
}
inline ::std::string* CurrentSelfMenuButton::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CurrentSelfMenuButton.url)
  return url_;
}
inline ::std::string* CurrentSelfMenuButton::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CurrentSelfMenuButton::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CurrentSelfMenuButton.url)
}

// optional string value = 5;
inline bool CurrentSelfMenuButton::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CurrentSelfMenuButton::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CurrentSelfMenuButton::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CurrentSelfMenuButton::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CurrentSelfMenuButton::value() const {
  // @@protoc_insertion_point(field_get:mpcomm.CurrentSelfMenuButton.value)
  return *value_;
}
inline void CurrentSelfMenuButton::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CurrentSelfMenuButton.value)
}
inline void CurrentSelfMenuButton::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CurrentSelfMenuButton.value)
}
inline void CurrentSelfMenuButton::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CurrentSelfMenuButton.value)
}
inline ::std::string* CurrentSelfMenuButton::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CurrentSelfMenuButton.value)
  return value_;
}
inline ::std::string* CurrentSelfMenuButton::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CurrentSelfMenuButton::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CurrentSelfMenuButton.value)
}

// optional .mpcomm.RespNewsList news_info = 6;
inline bool CurrentSelfMenuButton::has_news_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CurrentSelfMenuButton::set_has_news_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CurrentSelfMenuButton::clear_has_news_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CurrentSelfMenuButton::clear_news_info() {
  if (news_info_ != NULL) news_info_->::mpcomm::RespNewsList::Clear();
  clear_has_news_info();
}
inline const ::mpcomm::RespNewsList& CurrentSelfMenuButton::news_info() const {
  // @@protoc_insertion_point(field_get:mpcomm.CurrentSelfMenuButton.news_info)
  return news_info_ != NULL ? *news_info_ : *default_instance_->news_info_;
}
inline ::mpcomm::RespNewsList* CurrentSelfMenuButton::mutable_news_info() {
  set_has_news_info();
  if (news_info_ == NULL) news_info_ = new ::mpcomm::RespNewsList;
  // @@protoc_insertion_point(field_mutable:mpcomm.CurrentSelfMenuButton.news_info)
  return news_info_;
}
inline ::mpcomm::RespNewsList* CurrentSelfMenuButton::release_news_info() {
  clear_has_news_info();
  ::mpcomm::RespNewsList* temp = news_info_;
  news_info_ = NULL;
  return temp;
}
inline void CurrentSelfMenuButton::set_allocated_news_info(::mpcomm::RespNewsList* news_info) {
  delete news_info_;
  news_info_ = news_info;
  if (news_info) {
    set_has_news_info();
  } else {
    clear_has_news_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CurrentSelfMenuButton.news_info)
}

// optional .mpcomm.CurrentSelfMenuButtonList sub_button = 7;
inline bool CurrentSelfMenuButton::has_sub_button() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CurrentSelfMenuButton::set_has_sub_button() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CurrentSelfMenuButton::clear_has_sub_button() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CurrentSelfMenuButton::clear_sub_button() {
  if (sub_button_ != NULL) sub_button_->::mpcomm::CurrentSelfMenuButtonList::Clear();
  clear_has_sub_button();
}
inline const ::mpcomm::CurrentSelfMenuButtonList& CurrentSelfMenuButton::sub_button() const {
  // @@protoc_insertion_point(field_get:mpcomm.CurrentSelfMenuButton.sub_button)
  return sub_button_ != NULL ? *sub_button_ : *default_instance_->sub_button_;
}
inline ::mpcomm::CurrentSelfMenuButtonList* CurrentSelfMenuButton::mutable_sub_button() {
  set_has_sub_button();
  if (sub_button_ == NULL) sub_button_ = new ::mpcomm::CurrentSelfMenuButtonList;
  // @@protoc_insertion_point(field_mutable:mpcomm.CurrentSelfMenuButton.sub_button)
  return sub_button_;
}
inline ::mpcomm::CurrentSelfMenuButtonList* CurrentSelfMenuButton::release_sub_button() {
  clear_has_sub_button();
  ::mpcomm::CurrentSelfMenuButtonList* temp = sub_button_;
  sub_button_ = NULL;
  return temp;
}
inline void CurrentSelfMenuButton::set_allocated_sub_button(::mpcomm::CurrentSelfMenuButtonList* sub_button) {
  delete sub_button_;
  sub_button_ = sub_button;
  if (sub_button) {
    set_has_sub_button();
  } else {
    clear_has_sub_button();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CurrentSelfMenuButton.sub_button)
}

// -------------------------------------------------------------------

// CurrentSelfMenuButtonList

// repeated .mpcomm.CurrentSelfMenuButton list = 1;
inline int CurrentSelfMenuButtonList::list_size() const {
  return list_.size();
}
inline void CurrentSelfMenuButtonList::clear_list() {
  list_.Clear();
}
inline const ::mpcomm::CurrentSelfMenuButton& CurrentSelfMenuButtonList::list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.CurrentSelfMenuButtonList.list)
  return list_.Get(index);
}
inline ::mpcomm::CurrentSelfMenuButton* CurrentSelfMenuButtonList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.CurrentSelfMenuButtonList.list)
  return list_.Mutable(index);
}
inline ::mpcomm::CurrentSelfMenuButton* CurrentSelfMenuButtonList::add_list() {
  // @@protoc_insertion_point(field_add:mpcomm.CurrentSelfMenuButtonList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton >&
CurrentSelfMenuButtonList::list() const {
  // @@protoc_insertion_point(field_list:mpcomm.CurrentSelfMenuButtonList.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton >*
CurrentSelfMenuButtonList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.CurrentSelfMenuButtonList.list)
  return &list_;
}

// -------------------------------------------------------------------

// CurrentSelfMenu

// repeated .mpcomm.CurrentSelfMenuButton button = 1;
inline int CurrentSelfMenu::button_size() const {
  return button_.size();
}
inline void CurrentSelfMenu::clear_button() {
  button_.Clear();
}
inline const ::mpcomm::CurrentSelfMenuButton& CurrentSelfMenu::button(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.CurrentSelfMenu.button)
  return button_.Get(index);
}
inline ::mpcomm::CurrentSelfMenuButton* CurrentSelfMenu::mutable_button(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.CurrentSelfMenu.button)
  return button_.Mutable(index);
}
inline ::mpcomm::CurrentSelfMenuButton* CurrentSelfMenu::add_button() {
  // @@protoc_insertion_point(field_add:mpcomm.CurrentSelfMenu.button)
  return button_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton >&
CurrentSelfMenu::button() const {
  // @@protoc_insertion_point(field_list:mpcomm.CurrentSelfMenu.button)
  return button_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::CurrentSelfMenuButton >*
CurrentSelfMenu::mutable_button() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.CurrentSelfMenu.button)
  return &button_;
}

// -------------------------------------------------------------------

// GetCurrentSelfMenuInfoResp

// optional int64 errcode = 1;
inline bool GetCurrentSelfMenuInfoResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCurrentSelfMenuInfoResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCurrentSelfMenuInfoResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCurrentSelfMenuInfoResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetCurrentSelfMenuInfoResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentSelfMenuInfoResp.errcode)
  return errcode_;
}
inline void GetCurrentSelfMenuInfoResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetCurrentSelfMenuInfoResp.errcode)
}

// optional string errmsg = 2;
inline bool GetCurrentSelfMenuInfoResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCurrentSelfMenuInfoResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCurrentSelfMenuInfoResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCurrentSelfMenuInfoResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetCurrentSelfMenuInfoResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentSelfMenuInfoResp.errmsg)
  return *errmsg_;
}
inline void GetCurrentSelfMenuInfoResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetCurrentSelfMenuInfoResp.errmsg)
}
inline void GetCurrentSelfMenuInfoResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetCurrentSelfMenuInfoResp.errmsg)
}
inline void GetCurrentSelfMenuInfoResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetCurrentSelfMenuInfoResp.errmsg)
}
inline ::std::string* GetCurrentSelfMenuInfoResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCurrentSelfMenuInfoResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetCurrentSelfMenuInfoResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCurrentSelfMenuInfoResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCurrentSelfMenuInfoResp.errmsg)
}

// optional uint64 is_menu_open = 3;
inline bool GetCurrentSelfMenuInfoResp::has_is_menu_open() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetCurrentSelfMenuInfoResp::set_has_is_menu_open() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetCurrentSelfMenuInfoResp::clear_has_is_menu_open() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetCurrentSelfMenuInfoResp::clear_is_menu_open() {
  is_menu_open_ = GOOGLE_ULONGLONG(0);
  clear_has_is_menu_open();
}
inline ::google::protobuf::uint64 GetCurrentSelfMenuInfoResp::is_menu_open() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentSelfMenuInfoResp.is_menu_open)
  return is_menu_open_;
}
inline void GetCurrentSelfMenuInfoResp::set_is_menu_open(::google::protobuf::uint64 value) {
  set_has_is_menu_open();
  is_menu_open_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetCurrentSelfMenuInfoResp.is_menu_open)
}

// optional .mpcomm.CurrentSelfMenu selfmenu_info = 4;
inline bool GetCurrentSelfMenuInfoResp::has_selfmenu_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetCurrentSelfMenuInfoResp::set_has_selfmenu_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetCurrentSelfMenuInfoResp::clear_has_selfmenu_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetCurrentSelfMenuInfoResp::clear_selfmenu_info() {
  if (selfmenu_info_ != NULL) selfmenu_info_->::mpcomm::CurrentSelfMenu::Clear();
  clear_has_selfmenu_info();
}
inline const ::mpcomm::CurrentSelfMenu& GetCurrentSelfMenuInfoResp::selfmenu_info() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentSelfMenuInfoResp.selfmenu_info)
  return selfmenu_info_ != NULL ? *selfmenu_info_ : *default_instance_->selfmenu_info_;
}
inline ::mpcomm::CurrentSelfMenu* GetCurrentSelfMenuInfoResp::mutable_selfmenu_info() {
  set_has_selfmenu_info();
  if (selfmenu_info_ == NULL) selfmenu_info_ = new ::mpcomm::CurrentSelfMenu;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCurrentSelfMenuInfoResp.selfmenu_info)
  return selfmenu_info_;
}
inline ::mpcomm::CurrentSelfMenu* GetCurrentSelfMenuInfoResp::release_selfmenu_info() {
  clear_has_selfmenu_info();
  ::mpcomm::CurrentSelfMenu* temp = selfmenu_info_;
  selfmenu_info_ = NULL;
  return temp;
}
inline void GetCurrentSelfMenuInfoResp::set_allocated_selfmenu_info(::mpcomm::CurrentSelfMenu* selfmenu_info) {
  delete selfmenu_info_;
  selfmenu_info_ = selfmenu_info;
  if (selfmenu_info) {
    set_has_selfmenu_info();
  } else {
    clear_has_selfmenu_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCurrentSelfMenuInfoResp.selfmenu_info)
}

// -------------------------------------------------------------------

// ReplyItem

// optional string type = 1;
inline bool ReplyItem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplyItem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplyItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplyItem::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ReplyItem::type() const {
  // @@protoc_insertion_point(field_get:mpcomm.ReplyItem.type)
  return *type_;
}
inline void ReplyItem::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.ReplyItem.type)
}
inline void ReplyItem::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.ReplyItem.type)
}
inline void ReplyItem::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.ReplyItem.type)
}
inline ::std::string* ReplyItem::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.ReplyItem.type)
  return type_;
}
inline ::std::string* ReplyItem::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReplyItem::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.ReplyItem.type)
}

// optional string content = 2;
inline bool ReplyItem::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplyItem::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplyItem::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplyItem::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ReplyItem::content() const {
  // @@protoc_insertion_point(field_get:mpcomm.ReplyItem.content)
  return *content_;
}
inline void ReplyItem::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.ReplyItem.content)
}
inline void ReplyItem::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.ReplyItem.content)
}
inline void ReplyItem::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.ReplyItem.content)
}
inline ::std::string* ReplyItem::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.ReplyItem.content)
  return content_;
}
inline ::std::string* ReplyItem::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReplyItem::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.ReplyItem.content)
}

// optional .mpcomm.RespNewsList news_info = 3;
inline bool ReplyItem::has_news_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplyItem::set_has_news_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReplyItem::clear_has_news_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReplyItem::clear_news_info() {
  if (news_info_ != NULL) news_info_->::mpcomm::RespNewsList::Clear();
  clear_has_news_info();
}
inline const ::mpcomm::RespNewsList& ReplyItem::news_info() const {
  // @@protoc_insertion_point(field_get:mpcomm.ReplyItem.news_info)
  return news_info_ != NULL ? *news_info_ : *default_instance_->news_info_;
}
inline ::mpcomm::RespNewsList* ReplyItem::mutable_news_info() {
  set_has_news_info();
  if (news_info_ == NULL) news_info_ = new ::mpcomm::RespNewsList;
  // @@protoc_insertion_point(field_mutable:mpcomm.ReplyItem.news_info)
  return news_info_;
}
inline ::mpcomm::RespNewsList* ReplyItem::release_news_info() {
  clear_has_news_info();
  ::mpcomm::RespNewsList* temp = news_info_;
  news_info_ = NULL;
  return temp;
}
inline void ReplyItem::set_allocated_news_info(::mpcomm::RespNewsList* news_info) {
  delete news_info_;
  news_info_ = news_info;
  if (news_info) {
    set_has_news_info();
  } else {
    clear_has_news_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.ReplyItem.news_info)
}

// -------------------------------------------------------------------

// KeyWordItem

// optional string type = 1;
inline bool KeyWordItem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyWordItem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyWordItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyWordItem::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& KeyWordItem::type() const {
  // @@protoc_insertion_point(field_get:mpcomm.KeyWordItem.type)
  return *type_;
}
inline void KeyWordItem::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.KeyWordItem.type)
}
inline void KeyWordItem::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.KeyWordItem.type)
}
inline void KeyWordItem::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.KeyWordItem.type)
}
inline ::std::string* KeyWordItem::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.KeyWordItem.type)
  return type_;
}
inline ::std::string* KeyWordItem::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyWordItem::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.KeyWordItem.type)
}

// optional string match_mode = 2;
inline bool KeyWordItem::has_match_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyWordItem::set_has_match_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyWordItem::clear_has_match_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyWordItem::clear_match_mode() {
  if (match_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    match_mode_->clear();
  }
  clear_has_match_mode();
}
inline const ::std::string& KeyWordItem::match_mode() const {
  // @@protoc_insertion_point(field_get:mpcomm.KeyWordItem.match_mode)
  return *match_mode_;
}
inline void KeyWordItem::set_match_mode(const ::std::string& value) {
  set_has_match_mode();
  if (match_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    match_mode_ = new ::std::string;
  }
  match_mode_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.KeyWordItem.match_mode)
}
inline void KeyWordItem::set_match_mode(const char* value) {
  set_has_match_mode();
  if (match_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    match_mode_ = new ::std::string;
  }
  match_mode_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.KeyWordItem.match_mode)
}
inline void KeyWordItem::set_match_mode(const char* value, size_t size) {
  set_has_match_mode();
  if (match_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    match_mode_ = new ::std::string;
  }
  match_mode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.KeyWordItem.match_mode)
}
inline ::std::string* KeyWordItem::mutable_match_mode() {
  set_has_match_mode();
  if (match_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    match_mode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.KeyWordItem.match_mode)
  return match_mode_;
}
inline ::std::string* KeyWordItem::release_match_mode() {
  clear_has_match_mode();
  if (match_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = match_mode_;
    match_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyWordItem::set_allocated_match_mode(::std::string* match_mode) {
  if (match_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete match_mode_;
  }
  if (match_mode) {
    set_has_match_mode();
    match_mode_ = match_mode;
  } else {
    clear_has_match_mode();
    match_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.KeyWordItem.match_mode)
}

// optional string content = 3;
inline bool KeyWordItem::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyWordItem::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyWordItem::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyWordItem::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& KeyWordItem::content() const {
  // @@protoc_insertion_point(field_get:mpcomm.KeyWordItem.content)
  return *content_;
}
inline void KeyWordItem::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.KeyWordItem.content)
}
inline void KeyWordItem::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.KeyWordItem.content)
}
inline void KeyWordItem::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.KeyWordItem.content)
}
inline ::std::string* KeyWordItem::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.KeyWordItem.content)
  return content_;
}
inline ::std::string* KeyWordItem::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyWordItem::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.KeyWordItem.content)
}

// -------------------------------------------------------------------

// AutoReplyRule

// optional string rule_name = 1;
inline bool AutoReplyRule::has_rule_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoReplyRule::set_has_rule_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoReplyRule::clear_has_rule_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoReplyRule::clear_rule_name() {
  if (rule_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rule_name_->clear();
  }
  clear_has_rule_name();
}
inline const ::std::string& AutoReplyRule::rule_name() const {
  // @@protoc_insertion_point(field_get:mpcomm.AutoReplyRule.rule_name)
  return *rule_name_;
}
inline void AutoReplyRule::set_rule_name(const ::std::string& value) {
  set_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rule_name_ = new ::std::string;
  }
  rule_name_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AutoReplyRule.rule_name)
}
inline void AutoReplyRule::set_rule_name(const char* value) {
  set_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rule_name_ = new ::std::string;
  }
  rule_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AutoReplyRule.rule_name)
}
inline void AutoReplyRule::set_rule_name(const char* value, size_t size) {
  set_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rule_name_ = new ::std::string;
  }
  rule_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AutoReplyRule.rule_name)
}
inline ::std::string* AutoReplyRule::mutable_rule_name() {
  set_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rule_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AutoReplyRule.rule_name)
  return rule_name_;
}
inline ::std::string* AutoReplyRule::release_rule_name() {
  clear_has_rule_name();
  if (rule_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rule_name_;
    rule_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AutoReplyRule::set_allocated_rule_name(::std::string* rule_name) {
  if (rule_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rule_name_;
  }
  if (rule_name) {
    set_has_rule_name();
    rule_name_ = rule_name;
  } else {
    clear_has_rule_name();
    rule_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AutoReplyRule.rule_name)
}

// optional uint64 create_time = 2;
inline bool AutoReplyRule::has_create_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutoReplyRule::set_has_create_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutoReplyRule::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutoReplyRule::clear_create_time() {
  create_time_ = GOOGLE_ULONGLONG(0);
  clear_has_create_time();
}
inline ::google::protobuf::uint64 AutoReplyRule::create_time() const {
  // @@protoc_insertion_point(field_get:mpcomm.AutoReplyRule.create_time)
  return create_time_;
}
inline void AutoReplyRule::set_create_time(::google::protobuf::uint64 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.AutoReplyRule.create_time)
}

// optional string reply_mode = 3;
inline bool AutoReplyRule::has_reply_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutoReplyRule::set_has_reply_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AutoReplyRule::clear_has_reply_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AutoReplyRule::clear_reply_mode() {
  if (reply_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_mode_->clear();
  }
  clear_has_reply_mode();
}
inline const ::std::string& AutoReplyRule::reply_mode() const {
  // @@protoc_insertion_point(field_get:mpcomm.AutoReplyRule.reply_mode)
  return *reply_mode_;
}
inline void AutoReplyRule::set_reply_mode(const ::std::string& value) {
  set_has_reply_mode();
  if (reply_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_mode_ = new ::std::string;
  }
  reply_mode_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AutoReplyRule.reply_mode)
}
inline void AutoReplyRule::set_reply_mode(const char* value) {
  set_has_reply_mode();
  if (reply_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_mode_ = new ::std::string;
  }
  reply_mode_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AutoReplyRule.reply_mode)
}
inline void AutoReplyRule::set_reply_mode(const char* value, size_t size) {
  set_has_reply_mode();
  if (reply_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_mode_ = new ::std::string;
  }
  reply_mode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AutoReplyRule.reply_mode)
}
inline ::std::string* AutoReplyRule::mutable_reply_mode() {
  set_has_reply_mode();
  if (reply_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_mode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AutoReplyRule.reply_mode)
  return reply_mode_;
}
inline ::std::string* AutoReplyRule::release_reply_mode() {
  clear_has_reply_mode();
  if (reply_mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reply_mode_;
    reply_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AutoReplyRule::set_allocated_reply_mode(::std::string* reply_mode) {
  if (reply_mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reply_mode_;
  }
  if (reply_mode) {
    set_has_reply_mode();
    reply_mode_ = reply_mode;
  } else {
    clear_has_reply_mode();
    reply_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AutoReplyRule.reply_mode)
}

// repeated .mpcomm.KeyWordItem keyword_list_info = 4;
inline int AutoReplyRule::keyword_list_info_size() const {
  return keyword_list_info_.size();
}
inline void AutoReplyRule::clear_keyword_list_info() {
  keyword_list_info_.Clear();
}
inline const ::mpcomm::KeyWordItem& AutoReplyRule::keyword_list_info(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.AutoReplyRule.keyword_list_info)
  return keyword_list_info_.Get(index);
}
inline ::mpcomm::KeyWordItem* AutoReplyRule::mutable_keyword_list_info(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.AutoReplyRule.keyword_list_info)
  return keyword_list_info_.Mutable(index);
}
inline ::mpcomm::KeyWordItem* AutoReplyRule::add_keyword_list_info() {
  // @@protoc_insertion_point(field_add:mpcomm.AutoReplyRule.keyword_list_info)
  return keyword_list_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::KeyWordItem >&
AutoReplyRule::keyword_list_info() const {
  // @@protoc_insertion_point(field_list:mpcomm.AutoReplyRule.keyword_list_info)
  return keyword_list_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::KeyWordItem >*
AutoReplyRule::mutable_keyword_list_info() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.AutoReplyRule.keyword_list_info)
  return &keyword_list_info_;
}

// repeated .mpcomm.ReplyItem reply_list_info = 5;
inline int AutoReplyRule::reply_list_info_size() const {
  return reply_list_info_.size();
}
inline void AutoReplyRule::clear_reply_list_info() {
  reply_list_info_.Clear();
}
inline const ::mpcomm::ReplyItem& AutoReplyRule::reply_list_info(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.AutoReplyRule.reply_list_info)
  return reply_list_info_.Get(index);
}
inline ::mpcomm::ReplyItem* AutoReplyRule::mutable_reply_list_info(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.AutoReplyRule.reply_list_info)
  return reply_list_info_.Mutable(index);
}
inline ::mpcomm::ReplyItem* AutoReplyRule::add_reply_list_info() {
  // @@protoc_insertion_point(field_add:mpcomm.AutoReplyRule.reply_list_info)
  return reply_list_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::ReplyItem >&
AutoReplyRule::reply_list_info() const {
  // @@protoc_insertion_point(field_list:mpcomm.AutoReplyRule.reply_list_info)
  return reply_list_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::ReplyItem >*
AutoReplyRule::mutable_reply_list_info() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.AutoReplyRule.reply_list_info)
  return &reply_list_info_;
}

// -------------------------------------------------------------------

// AutoReplyRuleList

// repeated .mpcomm.AutoReplyRule list = 1;
inline int AutoReplyRuleList::list_size() const {
  return list_.size();
}
inline void AutoReplyRuleList::clear_list() {
  list_.Clear();
}
inline const ::mpcomm::AutoReplyRule& AutoReplyRuleList::list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.AutoReplyRuleList.list)
  return list_.Get(index);
}
inline ::mpcomm::AutoReplyRule* AutoReplyRuleList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.AutoReplyRuleList.list)
  return list_.Mutable(index);
}
inline ::mpcomm::AutoReplyRule* AutoReplyRuleList::add_list() {
  // @@protoc_insertion_point(field_add:mpcomm.AutoReplyRuleList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::AutoReplyRule >&
AutoReplyRuleList::list() const {
  // @@protoc_insertion_point(field_list:mpcomm.AutoReplyRuleList.list)
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::AutoReplyRule >*
AutoReplyRuleList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.AutoReplyRuleList.list)
  return &list_;
}

// -------------------------------------------------------------------

// GetCurrentAutoReplyInfoReq

// optional string access_token = 1;
inline bool GetCurrentAutoReplyInfoReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCurrentAutoReplyInfoReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCurrentAutoReplyInfoReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCurrentAutoReplyInfoReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetCurrentAutoReplyInfoReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentAutoReplyInfoReq.access_token)
  return *access_token_;
}
inline void GetCurrentAutoReplyInfoReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetCurrentAutoReplyInfoReq.access_token)
}
inline void GetCurrentAutoReplyInfoReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetCurrentAutoReplyInfoReq.access_token)
}
inline void GetCurrentAutoReplyInfoReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetCurrentAutoReplyInfoReq.access_token)
}
inline ::std::string* GetCurrentAutoReplyInfoReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCurrentAutoReplyInfoReq.access_token)
  return access_token_;
}
inline ::std::string* GetCurrentAutoReplyInfoReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCurrentAutoReplyInfoReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCurrentAutoReplyInfoReq.access_token)
}

// -------------------------------------------------------------------

// GetCurrentAutoReplyInfoResp

// optional int64 errcode = 1;
inline bool GetCurrentAutoReplyInfoResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCurrentAutoReplyInfoResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCurrentAutoReplyInfoResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCurrentAutoReplyInfoResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetCurrentAutoReplyInfoResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentAutoReplyInfoResp.errcode)
  return errcode_;
}
inline void GetCurrentAutoReplyInfoResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetCurrentAutoReplyInfoResp.errcode)
}

// optional string errmsg = 2;
inline bool GetCurrentAutoReplyInfoResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCurrentAutoReplyInfoResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCurrentAutoReplyInfoResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCurrentAutoReplyInfoResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetCurrentAutoReplyInfoResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentAutoReplyInfoResp.errmsg)
  return *errmsg_;
}
inline void GetCurrentAutoReplyInfoResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetCurrentAutoReplyInfoResp.errmsg)
}
inline void GetCurrentAutoReplyInfoResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetCurrentAutoReplyInfoResp.errmsg)
}
inline void GetCurrentAutoReplyInfoResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetCurrentAutoReplyInfoResp.errmsg)
}
inline ::std::string* GetCurrentAutoReplyInfoResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCurrentAutoReplyInfoResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetCurrentAutoReplyInfoResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCurrentAutoReplyInfoResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCurrentAutoReplyInfoResp.errmsg)
}

// optional uint64 is_add_friend_reply_open = 3;
inline bool GetCurrentAutoReplyInfoResp::has_is_add_friend_reply_open() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetCurrentAutoReplyInfoResp::set_has_is_add_friend_reply_open() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetCurrentAutoReplyInfoResp::clear_has_is_add_friend_reply_open() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetCurrentAutoReplyInfoResp::clear_is_add_friend_reply_open() {
  is_add_friend_reply_open_ = GOOGLE_ULONGLONG(0);
  clear_has_is_add_friend_reply_open();
}
inline ::google::protobuf::uint64 GetCurrentAutoReplyInfoResp::is_add_friend_reply_open() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentAutoReplyInfoResp.is_add_friend_reply_open)
  return is_add_friend_reply_open_;
}
inline void GetCurrentAutoReplyInfoResp::set_is_add_friend_reply_open(::google::protobuf::uint64 value) {
  set_has_is_add_friend_reply_open();
  is_add_friend_reply_open_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetCurrentAutoReplyInfoResp.is_add_friend_reply_open)
}

// optional uint64 is_autoreply_open = 4;
inline bool GetCurrentAutoReplyInfoResp::has_is_autoreply_open() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetCurrentAutoReplyInfoResp::set_has_is_autoreply_open() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetCurrentAutoReplyInfoResp::clear_has_is_autoreply_open() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetCurrentAutoReplyInfoResp::clear_is_autoreply_open() {
  is_autoreply_open_ = GOOGLE_ULONGLONG(0);
  clear_has_is_autoreply_open();
}
inline ::google::protobuf::uint64 GetCurrentAutoReplyInfoResp::is_autoreply_open() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentAutoReplyInfoResp.is_autoreply_open)
  return is_autoreply_open_;
}
inline void GetCurrentAutoReplyInfoResp::set_is_autoreply_open(::google::protobuf::uint64 value) {
  set_has_is_autoreply_open();
  is_autoreply_open_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetCurrentAutoReplyInfoResp.is_autoreply_open)
}

// optional .mpcomm.ReplyItem add_friend_autoreply_info = 5;
inline bool GetCurrentAutoReplyInfoResp::has_add_friend_autoreply_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetCurrentAutoReplyInfoResp::set_has_add_friend_autoreply_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetCurrentAutoReplyInfoResp::clear_has_add_friend_autoreply_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetCurrentAutoReplyInfoResp::clear_add_friend_autoreply_info() {
  if (add_friend_autoreply_info_ != NULL) add_friend_autoreply_info_->::mpcomm::ReplyItem::Clear();
  clear_has_add_friend_autoreply_info();
}
inline const ::mpcomm::ReplyItem& GetCurrentAutoReplyInfoResp::add_friend_autoreply_info() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentAutoReplyInfoResp.add_friend_autoreply_info)
  return add_friend_autoreply_info_ != NULL ? *add_friend_autoreply_info_ : *default_instance_->add_friend_autoreply_info_;
}
inline ::mpcomm::ReplyItem* GetCurrentAutoReplyInfoResp::mutable_add_friend_autoreply_info() {
  set_has_add_friend_autoreply_info();
  if (add_friend_autoreply_info_ == NULL) add_friend_autoreply_info_ = new ::mpcomm::ReplyItem;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCurrentAutoReplyInfoResp.add_friend_autoreply_info)
  return add_friend_autoreply_info_;
}
inline ::mpcomm::ReplyItem* GetCurrentAutoReplyInfoResp::release_add_friend_autoreply_info() {
  clear_has_add_friend_autoreply_info();
  ::mpcomm::ReplyItem* temp = add_friend_autoreply_info_;
  add_friend_autoreply_info_ = NULL;
  return temp;
}
inline void GetCurrentAutoReplyInfoResp::set_allocated_add_friend_autoreply_info(::mpcomm::ReplyItem* add_friend_autoreply_info) {
  delete add_friend_autoreply_info_;
  add_friend_autoreply_info_ = add_friend_autoreply_info;
  if (add_friend_autoreply_info) {
    set_has_add_friend_autoreply_info();
  } else {
    clear_has_add_friend_autoreply_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCurrentAutoReplyInfoResp.add_friend_autoreply_info)
}

// optional .mpcomm.ReplyItem message_default_autoreply_info = 6;
inline bool GetCurrentAutoReplyInfoResp::has_message_default_autoreply_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetCurrentAutoReplyInfoResp::set_has_message_default_autoreply_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetCurrentAutoReplyInfoResp::clear_has_message_default_autoreply_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetCurrentAutoReplyInfoResp::clear_message_default_autoreply_info() {
  if (message_default_autoreply_info_ != NULL) message_default_autoreply_info_->::mpcomm::ReplyItem::Clear();
  clear_has_message_default_autoreply_info();
}
inline const ::mpcomm::ReplyItem& GetCurrentAutoReplyInfoResp::message_default_autoreply_info() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentAutoReplyInfoResp.message_default_autoreply_info)
  return message_default_autoreply_info_ != NULL ? *message_default_autoreply_info_ : *default_instance_->message_default_autoreply_info_;
}
inline ::mpcomm::ReplyItem* GetCurrentAutoReplyInfoResp::mutable_message_default_autoreply_info() {
  set_has_message_default_autoreply_info();
  if (message_default_autoreply_info_ == NULL) message_default_autoreply_info_ = new ::mpcomm::ReplyItem;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCurrentAutoReplyInfoResp.message_default_autoreply_info)
  return message_default_autoreply_info_;
}
inline ::mpcomm::ReplyItem* GetCurrentAutoReplyInfoResp::release_message_default_autoreply_info() {
  clear_has_message_default_autoreply_info();
  ::mpcomm::ReplyItem* temp = message_default_autoreply_info_;
  message_default_autoreply_info_ = NULL;
  return temp;
}
inline void GetCurrentAutoReplyInfoResp::set_allocated_message_default_autoreply_info(::mpcomm::ReplyItem* message_default_autoreply_info) {
  delete message_default_autoreply_info_;
  message_default_autoreply_info_ = message_default_autoreply_info;
  if (message_default_autoreply_info) {
    set_has_message_default_autoreply_info();
  } else {
    clear_has_message_default_autoreply_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCurrentAutoReplyInfoResp.message_default_autoreply_info)
}

// optional .mpcomm.AutoReplyRuleList keyword_autoreply_info = 7;
inline bool GetCurrentAutoReplyInfoResp::has_keyword_autoreply_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetCurrentAutoReplyInfoResp::set_has_keyword_autoreply_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetCurrentAutoReplyInfoResp::clear_has_keyword_autoreply_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetCurrentAutoReplyInfoResp::clear_keyword_autoreply_info() {
  if (keyword_autoreply_info_ != NULL) keyword_autoreply_info_->::mpcomm::AutoReplyRuleList::Clear();
  clear_has_keyword_autoreply_info();
}
inline const ::mpcomm::AutoReplyRuleList& GetCurrentAutoReplyInfoResp::keyword_autoreply_info() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetCurrentAutoReplyInfoResp.keyword_autoreply_info)
  return keyword_autoreply_info_ != NULL ? *keyword_autoreply_info_ : *default_instance_->keyword_autoreply_info_;
}
inline ::mpcomm::AutoReplyRuleList* GetCurrentAutoReplyInfoResp::mutable_keyword_autoreply_info() {
  set_has_keyword_autoreply_info();
  if (keyword_autoreply_info_ == NULL) keyword_autoreply_info_ = new ::mpcomm::AutoReplyRuleList;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetCurrentAutoReplyInfoResp.keyword_autoreply_info)
  return keyword_autoreply_info_;
}
inline ::mpcomm::AutoReplyRuleList* GetCurrentAutoReplyInfoResp::release_keyword_autoreply_info() {
  clear_has_keyword_autoreply_info();
  ::mpcomm::AutoReplyRuleList* temp = keyword_autoreply_info_;
  keyword_autoreply_info_ = NULL;
  return temp;
}
inline void GetCurrentAutoReplyInfoResp::set_allocated_keyword_autoreply_info(::mpcomm::AutoReplyRuleList* keyword_autoreply_info) {
  delete keyword_autoreply_info_;
  keyword_autoreply_info_ = keyword_autoreply_info;
  if (keyword_autoreply_info) {
    set_has_keyword_autoreply_info();
  } else {
    clear_has_keyword_autoreply_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetCurrentAutoReplyInfoResp.keyword_autoreply_info)
}

// -------------------------------------------------------------------

// Text

// optional string content = 1;
inline bool Text::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Text::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Text::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Text::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Text::content() const {
  // @@protoc_insertion_point(field_get:mpcomm.Text.content)
  return *content_;
}
inline void Text::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Text.content)
}
inline void Text::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Text.content)
}
inline void Text::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Text.content)
}
inline ::std::string* Text::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Text.content)
  return content_;
}
inline ::std::string* Text::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Text::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Text.content)
}

// -------------------------------------------------------------------

// Image

// optional string media_id = 1;
inline bool Image::has_media_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_media_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& Image::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.Image.media_id)
  return *media_id_;
}
inline void Image::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Image.media_id)
}
inline void Image::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Image.media_id)
}
inline void Image::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Image.media_id)
}
inline ::std::string* Image::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Image.media_id)
  return media_id_;
}
inline ::std::string* Image::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Image::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Image.media_id)
}

// -------------------------------------------------------------------

// Voice

// optional string media_id = 1;
inline bool Voice::has_media_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Voice::set_has_media_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Voice::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Voice::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& Voice::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.Voice.media_id)
  return *media_id_;
}
inline void Voice::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Voice.media_id)
}
inline void Voice::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Voice.media_id)
}
inline void Voice::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Voice.media_id)
}
inline ::std::string* Voice::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Voice.media_id)
  return media_id_;
}
inline ::std::string* Voice::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Voice::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Voice.media_id)
}

// -------------------------------------------------------------------

// Video

// optional string media_id = 1;
inline bool Video::has_media_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Video::set_has_media_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Video::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Video::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& Video::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.Video.media_id)
  return *media_id_;
}
inline void Video::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Video.media_id)
}
inline void Video::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Video.media_id)
}
inline void Video::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Video.media_id)
}
inline ::std::string* Video::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Video.media_id)
  return media_id_;
}
inline ::std::string* Video::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Video::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Video.media_id)
}

// optional string thumb_media_id = 2;
inline bool Video::has_thumb_media_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Video::set_has_thumb_media_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Video::clear_has_thumb_media_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Video::clear_thumb_media_id() {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_->clear();
  }
  clear_has_thumb_media_id();
}
inline const ::std::string& Video::thumb_media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.Video.thumb_media_id)
  return *thumb_media_id_;
}
inline void Video::set_thumb_media_id(const ::std::string& value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Video.thumb_media_id)
}
inline void Video::set_thumb_media_id(const char* value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Video.thumb_media_id)
}
inline void Video::set_thumb_media_id(const char* value, size_t size) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Video.thumb_media_id)
}
inline ::std::string* Video::mutable_thumb_media_id() {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Video.thumb_media_id)
  return thumb_media_id_;
}
inline ::std::string* Video::release_thumb_media_id() {
  clear_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thumb_media_id_;
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Video::set_allocated_thumb_media_id(::std::string* thumb_media_id) {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thumb_media_id_;
  }
  if (thumb_media_id) {
    set_has_thumb_media_id();
    thumb_media_id_ = thumb_media_id;
  } else {
    clear_has_thumb_media_id();
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Video.thumb_media_id)
}

// optional string title = 3;
inline bool Video::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Video::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Video::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Video::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Video::title() const {
  // @@protoc_insertion_point(field_get:mpcomm.Video.title)
  return *title_;
}
inline void Video::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Video.title)
}
inline void Video::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Video.title)
}
inline void Video::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Video.title)
}
inline ::std::string* Video::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Video.title)
  return title_;
}
inline ::std::string* Video::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Video::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Video.title)
}

// optional string description = 4;
inline bool Video::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Video::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Video::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Video::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Video::description() const {
  // @@protoc_insertion_point(field_get:mpcomm.Video.description)
  return *description_;
}
inline void Video::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Video.description)
}
inline void Video::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Video.description)
}
inline void Video::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Video.description)
}
inline ::std::string* Video::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Video.description)
  return description_;
}
inline ::std::string* Video::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Video::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Video.description)
}

// -------------------------------------------------------------------

// Link

// optional string title = 1;
inline bool Link::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Link::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Link::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Link::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Link::title() const {
  // @@protoc_insertion_point(field_get:mpcomm.Link.title)
  return *title_;
}
inline void Link::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Link.title)
}
inline void Link::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Link.title)
}
inline void Link::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Link.title)
}
inline ::std::string* Link::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Link.title)
  return title_;
}
inline ::std::string* Link::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Link::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Link.title)
}

// optional string description = 2;
inline bool Link::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Link::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Link::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Link::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Link::description() const {
  // @@protoc_insertion_point(field_get:mpcomm.Link.description)
  return *description_;
}
inline void Link::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Link.description)
}
inline void Link::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Link.description)
}
inline void Link::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Link.description)
}
inline ::std::string* Link::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Link.description)
  return description_;
}
inline ::std::string* Link::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Link::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Link.description)
}

// optional string url = 3;
inline bool Link::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Link::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Link::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Link::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Link::url() const {
  // @@protoc_insertion_point(field_get:mpcomm.Link.url)
  return *url_;
}
inline void Link::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Link.url)
}
inline void Link::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Link.url)
}
inline void Link::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Link.url)
}
inline ::std::string* Link::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Link.url)
  return url_;
}
inline ::std::string* Link::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Link::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Link.url)
}

// optional string thumb_media_id = 4;
inline bool Link::has_thumb_media_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Link::set_has_thumb_media_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Link::clear_has_thumb_media_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Link::clear_thumb_media_id() {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_->clear();
  }
  clear_has_thumb_media_id();
}
inline const ::std::string& Link::thumb_media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.Link.thumb_media_id)
  return *thumb_media_id_;
}
inline void Link::set_thumb_media_id(const ::std::string& value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Link.thumb_media_id)
}
inline void Link::set_thumb_media_id(const char* value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Link.thumb_media_id)
}
inline void Link::set_thumb_media_id(const char* value, size_t size) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Link.thumb_media_id)
}
inline ::std::string* Link::mutable_thumb_media_id() {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Link.thumb_media_id)
  return thumb_media_id_;
}
inline ::std::string* Link::release_thumb_media_id() {
  clear_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thumb_media_id_;
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Link::set_allocated_thumb_media_id(::std::string* thumb_media_id) {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thumb_media_id_;
  }
  if (thumb_media_id) {
    set_has_thumb_media_id();
    thumb_media_id_ = thumb_media_id;
  } else {
    clear_has_thumb_media_id();
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Link.thumb_media_id)
}

// -------------------------------------------------------------------

// Card

// optional string weixin_id = 1;
inline bool Card::has_weixin_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Card::set_has_weixin_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Card::clear_has_weixin_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Card::clear_weixin_id() {
  if (weixin_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixin_id_->clear();
  }
  clear_has_weixin_id();
}
inline const ::std::string& Card::weixin_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.Card.weixin_id)
  return *weixin_id_;
}
inline void Card::set_weixin_id(const ::std::string& value) {
  set_has_weixin_id();
  if (weixin_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixin_id_ = new ::std::string;
  }
  weixin_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Card.weixin_id)
}
inline void Card::set_weixin_id(const char* value) {
  set_has_weixin_id();
  if (weixin_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixin_id_ = new ::std::string;
  }
  weixin_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Card.weixin_id)
}
inline void Card::set_weixin_id(const char* value, size_t size) {
  set_has_weixin_id();
  if (weixin_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixin_id_ = new ::std::string;
  }
  weixin_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Card.weixin_id)
}
inline ::std::string* Card::mutable_weixin_id() {
  set_has_weixin_id();
  if (weixin_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    weixin_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Card.weixin_id)
  return weixin_id_;
}
inline ::std::string* Card::release_weixin_id() {
  clear_has_weixin_id();
  if (weixin_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = weixin_id_;
    weixin_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Card::set_allocated_weixin_id(::std::string* weixin_id) {
  if (weixin_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete weixin_id_;
  }
  if (weixin_id) {
    set_has_weixin_id();
    weixin_id_ = weixin_id;
  } else {
    clear_has_weixin_id();
    weixin_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Card.weixin_id)
}

// -------------------------------------------------------------------

// ArticlesItem

// optional string title = 1;
inline bool ArticlesItem::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArticlesItem::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArticlesItem::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArticlesItem::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& ArticlesItem::title() const {
  // @@protoc_insertion_point(field_get:mpcomm.ArticlesItem.title)
  return *title_;
}
inline void ArticlesItem::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.ArticlesItem.title)
}
inline void ArticlesItem::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.ArticlesItem.title)
}
inline void ArticlesItem::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.ArticlesItem.title)
}
inline ::std::string* ArticlesItem::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.ArticlesItem.title)
  return title_;
}
inline ::std::string* ArticlesItem::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArticlesItem::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.ArticlesItem.title)
}

// optional string description = 2;
inline bool ArticlesItem::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArticlesItem::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArticlesItem::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArticlesItem::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ArticlesItem::description() const {
  // @@protoc_insertion_point(field_get:mpcomm.ArticlesItem.description)
  return *description_;
}
inline void ArticlesItem::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.ArticlesItem.description)
}
inline void ArticlesItem::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.ArticlesItem.description)
}
inline void ArticlesItem::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.ArticlesItem.description)
}
inline ::std::string* ArticlesItem::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.ArticlesItem.description)
  return description_;
}
inline ::std::string* ArticlesItem::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArticlesItem::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.ArticlesItem.description)
}

// optional string picurl = 3;
inline bool ArticlesItem::has_picurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArticlesItem::set_has_picurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArticlesItem::clear_has_picurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArticlesItem::clear_picurl() {
  if (picurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_->clear();
  }
  clear_has_picurl();
}
inline const ::std::string& ArticlesItem::picurl() const {
  // @@protoc_insertion_point(field_get:mpcomm.ArticlesItem.picurl)
  return *picurl_;
}
inline void ArticlesItem::set_picurl(const ::std::string& value) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.ArticlesItem.picurl)
}
inline void ArticlesItem::set_picurl(const char* value) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.ArticlesItem.picurl)
}
inline void ArticlesItem::set_picurl(const char* value, size_t size) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.ArticlesItem.picurl)
}
inline ::std::string* ArticlesItem::mutable_picurl() {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    picurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.ArticlesItem.picurl)
  return picurl_;
}
inline ::std::string* ArticlesItem::release_picurl() {
  clear_has_picurl();
  if (picurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = picurl_;
    picurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArticlesItem::set_allocated_picurl(::std::string* picurl) {
  if (picurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete picurl_;
  }
  if (picurl) {
    set_has_picurl();
    picurl_ = picurl;
  } else {
    clear_has_picurl();
    picurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.ArticlesItem.picurl)
}

// optional string url = 4;
inline bool ArticlesItem::has_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArticlesItem::set_has_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArticlesItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArticlesItem::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ArticlesItem::url() const {
  // @@protoc_insertion_point(field_get:mpcomm.ArticlesItem.url)
  return *url_;
}
inline void ArticlesItem::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.ArticlesItem.url)
}
inline void ArticlesItem::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.ArticlesItem.url)
}
inline void ArticlesItem::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.ArticlesItem.url)
}
inline ::std::string* ArticlesItem::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.ArticlesItem.url)
  return url_;
}
inline ::std::string* ArticlesItem::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArticlesItem::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.ArticlesItem.url)
}

// -------------------------------------------------------------------

// NewsMsg

// repeated .mpcomm.ArticlesItem articles = 1;
inline int NewsMsg::articles_size() const {
  return articles_.size();
}
inline void NewsMsg::clear_articles() {
  articles_.Clear();
}
inline const ::mpcomm::ArticlesItem& NewsMsg::articles(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsMsg.articles)
  return articles_.Get(index);
}
inline ::mpcomm::ArticlesItem* NewsMsg::mutable_articles(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsMsg.articles)
  return articles_.Mutable(index);
}
inline ::mpcomm::ArticlesItem* NewsMsg::add_articles() {
  // @@protoc_insertion_point(field_add:mpcomm.NewsMsg.articles)
  return articles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::ArticlesItem >&
NewsMsg::articles() const {
  // @@protoc_insertion_point(field_list:mpcomm.NewsMsg.articles)
  return articles_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::ArticlesItem >*
NewsMsg::mutable_articles() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.NewsMsg.articles)
  return &articles_;
}

// optional string thumb_media_id = 4;
inline bool NewsMsg::has_thumb_media_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewsMsg::set_has_thumb_media_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewsMsg::clear_has_thumb_media_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewsMsg::clear_thumb_media_id() {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_->clear();
  }
  clear_has_thumb_media_id();
}
inline const ::std::string& NewsMsg::thumb_media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsMsg.thumb_media_id)
  return *thumb_media_id_;
}
inline void NewsMsg::set_thumb_media_id(const ::std::string& value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.NewsMsg.thumb_media_id)
}
inline void NewsMsg::set_thumb_media_id(const char* value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.NewsMsg.thumb_media_id)
}
inline void NewsMsg::set_thumb_media_id(const char* value, size_t size) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.NewsMsg.thumb_media_id)
}
inline ::std::string* NewsMsg::mutable_thumb_media_id() {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsMsg.thumb_media_id)
  return thumb_media_id_;
}
inline ::std::string* NewsMsg::release_thumb_media_id() {
  clear_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thumb_media_id_;
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewsMsg::set_allocated_thumb_media_id(::std::string* thumb_media_id) {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thumb_media_id_;
  }
  if (thumb_media_id) {
    set_has_thumb_media_id();
    thumb_media_id_ = thumb_media_id;
  } else {
    clear_has_thumb_media_id();
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.NewsMsg.thumb_media_id)
}

// -------------------------------------------------------------------

// Music

// optional string title = 1;
inline bool Music::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Music::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Music::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Music::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Music::title() const {
  // @@protoc_insertion_point(field_get:mpcomm.Music.title)
  return *title_;
}
inline void Music::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Music.title)
}
inline void Music::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Music.title)
}
inline void Music::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Music.title)
}
inline ::std::string* Music::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Music.title)
  return title_;
}
inline ::std::string* Music::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Music::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Music.title)
}

// optional string description = 2;
inline bool Music::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Music::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Music::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Music::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Music::description() const {
  // @@protoc_insertion_point(field_get:mpcomm.Music.description)
  return *description_;
}
inline void Music::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Music.description)
}
inline void Music::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Music.description)
}
inline void Music::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Music.description)
}
inline ::std::string* Music::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Music.description)
  return description_;
}
inline ::std::string* Music::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Music::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Music.description)
}

// optional string musicurl = 3;
inline bool Music::has_musicurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Music::set_has_musicurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Music::clear_has_musicurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Music::clear_musicurl() {
  if (musicurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    musicurl_->clear();
  }
  clear_has_musicurl();
}
inline const ::std::string& Music::musicurl() const {
  // @@protoc_insertion_point(field_get:mpcomm.Music.musicurl)
  return *musicurl_;
}
inline void Music::set_musicurl(const ::std::string& value) {
  set_has_musicurl();
  if (musicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    musicurl_ = new ::std::string;
  }
  musicurl_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Music.musicurl)
}
inline void Music::set_musicurl(const char* value) {
  set_has_musicurl();
  if (musicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    musicurl_ = new ::std::string;
  }
  musicurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Music.musicurl)
}
inline void Music::set_musicurl(const char* value, size_t size) {
  set_has_musicurl();
  if (musicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    musicurl_ = new ::std::string;
  }
  musicurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Music.musicurl)
}
inline ::std::string* Music::mutable_musicurl() {
  set_has_musicurl();
  if (musicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    musicurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Music.musicurl)
  return musicurl_;
}
inline ::std::string* Music::release_musicurl() {
  clear_has_musicurl();
  if (musicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = musicurl_;
    musicurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Music::set_allocated_musicurl(::std::string* musicurl) {
  if (musicurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete musicurl_;
  }
  if (musicurl) {
    set_has_musicurl();
    musicurl_ = musicurl;
  } else {
    clear_has_musicurl();
    musicurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Music.musicurl)
}

// optional string hqmusicurl = 4;
inline bool Music::has_hqmusicurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Music::set_has_hqmusicurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Music::clear_has_hqmusicurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Music::clear_hqmusicurl() {
  if (hqmusicurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hqmusicurl_->clear();
  }
  clear_has_hqmusicurl();
}
inline const ::std::string& Music::hqmusicurl() const {
  // @@protoc_insertion_point(field_get:mpcomm.Music.hqmusicurl)
  return *hqmusicurl_;
}
inline void Music::set_hqmusicurl(const ::std::string& value) {
  set_has_hqmusicurl();
  if (hqmusicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hqmusicurl_ = new ::std::string;
  }
  hqmusicurl_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Music.hqmusicurl)
}
inline void Music::set_hqmusicurl(const char* value) {
  set_has_hqmusicurl();
  if (hqmusicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hqmusicurl_ = new ::std::string;
  }
  hqmusicurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Music.hqmusicurl)
}
inline void Music::set_hqmusicurl(const char* value, size_t size) {
  set_has_hqmusicurl();
  if (hqmusicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hqmusicurl_ = new ::std::string;
  }
  hqmusicurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Music.hqmusicurl)
}
inline ::std::string* Music::mutable_hqmusicurl() {
  set_has_hqmusicurl();
  if (hqmusicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hqmusicurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Music.hqmusicurl)
  return hqmusicurl_;
}
inline ::std::string* Music::release_hqmusicurl() {
  clear_has_hqmusicurl();
  if (hqmusicurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hqmusicurl_;
    hqmusicurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Music::set_allocated_hqmusicurl(::std::string* hqmusicurl) {
  if (hqmusicurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hqmusicurl_;
  }
  if (hqmusicurl) {
    set_has_hqmusicurl();
    hqmusicurl_ = hqmusicurl;
  } else {
    clear_has_hqmusicurl();
    hqmusicurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Music.hqmusicurl)
}

// optional string thumb_media_id = 5;
inline bool Music::has_thumb_media_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Music::set_has_thumb_media_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Music::clear_has_thumb_media_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Music::clear_thumb_media_id() {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_->clear();
  }
  clear_has_thumb_media_id();
}
inline const ::std::string& Music::thumb_media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.Music.thumb_media_id)
  return *thumb_media_id_;
}
inline void Music::set_thumb_media_id(const ::std::string& value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Music.thumb_media_id)
}
inline void Music::set_thumb_media_id(const char* value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Music.thumb_media_id)
}
inline void Music::set_thumb_media_id(const char* value, size_t size) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Music.thumb_media_id)
}
inline ::std::string* Music::mutable_thumb_media_id() {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Music.thumb_media_id)
  return thumb_media_id_;
}
inline ::std::string* Music::release_thumb_media_id() {
  clear_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thumb_media_id_;
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Music::set_allocated_thumb_media_id(::std::string* thumb_media_id) {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thumb_media_id_;
  }
  if (thumb_media_id) {
    set_has_thumb_media_id();
    thumb_media_id_ = thumb_media_id;
  } else {
    clear_has_thumb_media_id();
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Music.thumb_media_id)
}

// -------------------------------------------------------------------

// MpNewsMsg

// optional string media_id = 1;
inline bool MpNewsMsg::has_media_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MpNewsMsg::set_has_media_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MpNewsMsg::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MpNewsMsg::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& MpNewsMsg::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MpNewsMsg.media_id)
  return *media_id_;
}
inline void MpNewsMsg::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MpNewsMsg.media_id)
}
inline void MpNewsMsg::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MpNewsMsg.media_id)
}
inline void MpNewsMsg::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MpNewsMsg.media_id)
}
inline ::std::string* MpNewsMsg::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MpNewsMsg.media_id)
  return media_id_;
}
inline ::std::string* MpNewsMsg::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MpNewsMsg::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MpNewsMsg.media_id)
}

// -------------------------------------------------------------------

// MpVideo

// optional string media_id = 1;
inline bool MpVideo::has_media_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MpVideo::set_has_media_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MpVideo::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MpVideo::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& MpVideo::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MpVideo.media_id)
  return *media_id_;
}
inline void MpVideo::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MpVideo.media_id)
}
inline void MpVideo::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MpVideo.media_id)
}
inline void MpVideo::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MpVideo.media_id)
}
inline ::std::string* MpVideo::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MpVideo.media_id)
  return media_id_;
}
inline ::std::string* MpVideo::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MpVideo::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MpVideo.media_id)
}

// -------------------------------------------------------------------

// WxCard

// optional string card_id = 1;
inline bool WxCard::has_card_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WxCard::set_has_card_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WxCard::clear_has_card_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WxCard::clear_card_id() {
  if (card_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_id_->clear();
  }
  clear_has_card_id();
}
inline const ::std::string& WxCard::card_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.WxCard.card_id)
  return *card_id_;
}
inline void WxCard::set_card_id(const ::std::string& value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.WxCard.card_id)
}
inline void WxCard::set_card_id(const char* value) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.WxCard.card_id)
}
inline void WxCard::set_card_id(const char* value, size_t size) {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_id_ = new ::std::string;
  }
  card_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.WxCard.card_id)
}
inline ::std::string* WxCard::mutable_card_id() {
  set_has_card_id();
  if (card_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.WxCard.card_id)
  return card_id_;
}
inline ::std::string* WxCard::release_card_id() {
  clear_has_card_id();
  if (card_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = card_id_;
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WxCard::set_allocated_card_id(::std::string* card_id) {
  if (card_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete card_id_;
  }
  if (card_id) {
    set_has_card_id();
    card_id_ = card_id;
  } else {
    clear_has_card_id();
    card_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.WxCard.card_id)
}

// optional string card_ext = 2;
inline bool WxCard::has_card_ext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WxCard::set_has_card_ext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WxCard::clear_has_card_ext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WxCard::clear_card_ext() {
  if (card_ext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_ext_->clear();
  }
  clear_has_card_ext();
}
inline const ::std::string& WxCard::card_ext() const {
  // @@protoc_insertion_point(field_get:mpcomm.WxCard.card_ext)
  return *card_ext_;
}
inline void WxCard::set_card_ext(const ::std::string& value) {
  set_has_card_ext();
  if (card_ext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_ext_ = new ::std::string;
  }
  card_ext_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.WxCard.card_ext)
}
inline void WxCard::set_card_ext(const char* value) {
  set_has_card_ext();
  if (card_ext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_ext_ = new ::std::string;
  }
  card_ext_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.WxCard.card_ext)
}
inline void WxCard::set_card_ext(const char* value, size_t size) {
  set_has_card_ext();
  if (card_ext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_ext_ = new ::std::string;
  }
  card_ext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.WxCard.card_ext)
}
inline ::std::string* WxCard::mutable_card_ext() {
  set_has_card_ext();
  if (card_ext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    card_ext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.WxCard.card_ext)
  return card_ext_;
}
inline ::std::string* WxCard::release_card_ext() {
  clear_has_card_ext();
  if (card_ext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = card_ext_;
    card_ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WxCard::set_allocated_card_ext(::std::string* card_ext) {
  if (card_ext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete card_ext_;
  }
  if (card_ext) {
    set_has_card_ext();
    card_ext_ = card_ext;
  } else {
    clear_has_card_ext();
    card_ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.WxCard.card_ext)
}

// -------------------------------------------------------------------

// CustomServiceInfo

// optional string kf_account = 1;
inline bool CustomServiceInfo::has_kf_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomServiceInfo::set_has_kf_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomServiceInfo::clear_has_kf_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomServiceInfo::clear_kf_account() {
  if (kf_account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kf_account_->clear();
  }
  clear_has_kf_account();
}
inline const ::std::string& CustomServiceInfo::kf_account() const {
  // @@protoc_insertion_point(field_get:mpcomm.CustomServiceInfo.kf_account)
  return *kf_account_;
}
inline void CustomServiceInfo::set_kf_account(const ::std::string& value) {
  set_has_kf_account();
  if (kf_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kf_account_ = new ::std::string;
  }
  kf_account_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CustomServiceInfo.kf_account)
}
inline void CustomServiceInfo::set_kf_account(const char* value) {
  set_has_kf_account();
  if (kf_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kf_account_ = new ::std::string;
  }
  kf_account_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CustomServiceInfo.kf_account)
}
inline void CustomServiceInfo::set_kf_account(const char* value, size_t size) {
  set_has_kf_account();
  if (kf_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kf_account_ = new ::std::string;
  }
  kf_account_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CustomServiceInfo.kf_account)
}
inline ::std::string* CustomServiceInfo::mutable_kf_account() {
  set_has_kf_account();
  if (kf_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    kf_account_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CustomServiceInfo.kf_account)
  return kf_account_;
}
inline ::std::string* CustomServiceInfo::release_kf_account() {
  clear_has_kf_account();
  if (kf_account_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = kf_account_;
    kf_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CustomServiceInfo::set_allocated_kf_account(::std::string* kf_account) {
  if (kf_account_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete kf_account_;
  }
  if (kf_account) {
    set_has_kf_account();
    kf_account_ = kf_account;
  } else {
    clear_has_kf_account();
    kf_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CustomServiceInfo.kf_account)
}

// -------------------------------------------------------------------

// SendCustomMessageReq

// optional string access_token = 1;
inline bool SendCustomMessageReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendCustomMessageReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendCustomMessageReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendCustomMessageReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& SendCustomMessageReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.access_token)
  return *access_token_;
}
inline void SendCustomMessageReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SendCustomMessageReq.access_token)
}
inline void SendCustomMessageReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SendCustomMessageReq.access_token)
}
inline void SendCustomMessageReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SendCustomMessageReq.access_token)
}
inline ::std::string* SendCustomMessageReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.access_token)
  return access_token_;
}
inline ::std::string* SendCustomMessageReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCustomMessageReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.access_token)
}

// optional string msgtype = 2;
inline bool SendCustomMessageReq::has_msgtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendCustomMessageReq::set_has_msgtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendCustomMessageReq::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendCustomMessageReq::clear_msgtype() {
  if (msgtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_->clear();
  }
  clear_has_msgtype();
}
inline const ::std::string& SendCustomMessageReq::msgtype() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.msgtype)
  return *msgtype_;
}
inline void SendCustomMessageReq::set_msgtype(const ::std::string& value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SendCustomMessageReq.msgtype)
}
inline void SendCustomMessageReq::set_msgtype(const char* value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SendCustomMessageReq.msgtype)
}
inline void SendCustomMessageReq::set_msgtype(const char* value, size_t size) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SendCustomMessageReq.msgtype)
}
inline ::std::string* SendCustomMessageReq::mutable_msgtype() {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.msgtype)
  return msgtype_;
}
inline ::std::string* SendCustomMessageReq::release_msgtype() {
  clear_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgtype_;
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCustomMessageReq::set_allocated_msgtype(::std::string* msgtype) {
  if (msgtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgtype_;
  }
  if (msgtype) {
    set_has_msgtype();
    msgtype_ = msgtype;
  } else {
    clear_has_msgtype();
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.msgtype)
}

// optional string touser = 3;
inline bool SendCustomMessageReq::has_touser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendCustomMessageReq::set_has_touser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendCustomMessageReq::clear_has_touser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendCustomMessageReq::clear_touser() {
  if (touser_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_->clear();
  }
  clear_has_touser();
}
inline const ::std::string& SendCustomMessageReq::touser() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.touser)
  return *touser_;
}
inline void SendCustomMessageReq::set_touser(const ::std::string& value) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  touser_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SendCustomMessageReq.touser)
}
inline void SendCustomMessageReq::set_touser(const char* value) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  touser_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SendCustomMessageReq.touser)
}
inline void SendCustomMessageReq::set_touser(const char* value, size_t size) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  touser_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SendCustomMessageReq.touser)
}
inline ::std::string* SendCustomMessageReq::mutable_touser() {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.touser)
  return touser_;
}
inline ::std::string* SendCustomMessageReq::release_touser() {
  clear_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = touser_;
    touser_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCustomMessageReq::set_allocated_touser(::std::string* touser) {
  if (touser_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete touser_;
  }
  if (touser) {
    set_has_touser();
    touser_ = touser;
  } else {
    clear_has_touser();
    touser_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.touser)
}

// optional .mpcomm.Text text = 4;
inline bool SendCustomMessageReq::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendCustomMessageReq::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendCustomMessageReq::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendCustomMessageReq::clear_text() {
  if (text_ != NULL) text_->::mpcomm::Text::Clear();
  clear_has_text();
}
inline const ::mpcomm::Text& SendCustomMessageReq::text() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.text)
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mpcomm::Text* SendCustomMessageReq::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mpcomm::Text;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.text)
  return text_;
}
inline ::mpcomm::Text* SendCustomMessageReq::release_text() {
  clear_has_text();
  ::mpcomm::Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_text(::mpcomm::Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.text)
}

// optional .mpcomm.Image image = 5;
inline bool SendCustomMessageReq::has_image() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendCustomMessageReq::set_has_image() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendCustomMessageReq::clear_has_image() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendCustomMessageReq::clear_image() {
  if (image_ != NULL) image_->::mpcomm::Image::Clear();
  clear_has_image();
}
inline const ::mpcomm::Image& SendCustomMessageReq::image() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::mpcomm::Image* SendCustomMessageReq::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::mpcomm::Image;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.image)
  return image_;
}
inline ::mpcomm::Image* SendCustomMessageReq::release_image() {
  clear_has_image();
  ::mpcomm::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_image(::mpcomm::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.image)
}

// optional .mpcomm.Voice voice = 6;
inline bool SendCustomMessageReq::has_voice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SendCustomMessageReq::set_has_voice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SendCustomMessageReq::clear_has_voice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SendCustomMessageReq::clear_voice() {
  if (voice_ != NULL) voice_->::mpcomm::Voice::Clear();
  clear_has_voice();
}
inline const ::mpcomm::Voice& SendCustomMessageReq::voice() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.voice)
  return voice_ != NULL ? *voice_ : *default_instance_->voice_;
}
inline ::mpcomm::Voice* SendCustomMessageReq::mutable_voice() {
  set_has_voice();
  if (voice_ == NULL) voice_ = new ::mpcomm::Voice;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.voice)
  return voice_;
}
inline ::mpcomm::Voice* SendCustomMessageReq::release_voice() {
  clear_has_voice();
  ::mpcomm::Voice* temp = voice_;
  voice_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_voice(::mpcomm::Voice* voice) {
  delete voice_;
  voice_ = voice;
  if (voice) {
    set_has_voice();
  } else {
    clear_has_voice();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.voice)
}

// optional .mpcomm.Video video = 7;
inline bool SendCustomMessageReq::has_video() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SendCustomMessageReq::set_has_video() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SendCustomMessageReq::clear_has_video() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SendCustomMessageReq::clear_video() {
  if (video_ != NULL) video_->::mpcomm::Video::Clear();
  clear_has_video();
}
inline const ::mpcomm::Video& SendCustomMessageReq::video() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.video)
  return video_ != NULL ? *video_ : *default_instance_->video_;
}
inline ::mpcomm::Video* SendCustomMessageReq::mutable_video() {
  set_has_video();
  if (video_ == NULL) video_ = new ::mpcomm::Video;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.video)
  return video_;
}
inline ::mpcomm::Video* SendCustomMessageReq::release_video() {
  clear_has_video();
  ::mpcomm::Video* temp = video_;
  video_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_video(::mpcomm::Video* video) {
  delete video_;
  video_ = video;
  if (video) {
    set_has_video();
  } else {
    clear_has_video();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.video)
}

// optional .mpcomm.Music music = 8;
inline bool SendCustomMessageReq::has_music() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SendCustomMessageReq::set_has_music() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SendCustomMessageReq::clear_has_music() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SendCustomMessageReq::clear_music() {
  if (music_ != NULL) music_->::mpcomm::Music::Clear();
  clear_has_music();
}
inline const ::mpcomm::Music& SendCustomMessageReq::music() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.music)
  return music_ != NULL ? *music_ : *default_instance_->music_;
}
inline ::mpcomm::Music* SendCustomMessageReq::mutable_music() {
  set_has_music();
  if (music_ == NULL) music_ = new ::mpcomm::Music;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.music)
  return music_;
}
inline ::mpcomm::Music* SendCustomMessageReq::release_music() {
  clear_has_music();
  ::mpcomm::Music* temp = music_;
  music_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_music(::mpcomm::Music* music) {
  delete music_;
  music_ = music;
  if (music) {
    set_has_music();
  } else {
    clear_has_music();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.music)
}

// optional .mpcomm.NewsMsg news = 9;
inline bool SendCustomMessageReq::has_news() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SendCustomMessageReq::set_has_news() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SendCustomMessageReq::clear_has_news() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SendCustomMessageReq::clear_news() {
  if (news_ != NULL) news_->::mpcomm::NewsMsg::Clear();
  clear_has_news();
}
inline const ::mpcomm::NewsMsg& SendCustomMessageReq::news() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.news)
  return news_ != NULL ? *news_ : *default_instance_->news_;
}
inline ::mpcomm::NewsMsg* SendCustomMessageReq::mutable_news() {
  set_has_news();
  if (news_ == NULL) news_ = new ::mpcomm::NewsMsg;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.news)
  return news_;
}
inline ::mpcomm::NewsMsg* SendCustomMessageReq::release_news() {
  clear_has_news();
  ::mpcomm::NewsMsg* temp = news_;
  news_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_news(::mpcomm::NewsMsg* news) {
  delete news_;
  news_ = news;
  if (news) {
    set_has_news();
  } else {
    clear_has_news();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.news)
}

// optional .mpcomm.MpNewsMsg mpnews = 10;
inline bool SendCustomMessageReq::has_mpnews() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SendCustomMessageReq::set_has_mpnews() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SendCustomMessageReq::clear_has_mpnews() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SendCustomMessageReq::clear_mpnews() {
  if (mpnews_ != NULL) mpnews_->::mpcomm::MpNewsMsg::Clear();
  clear_has_mpnews();
}
inline const ::mpcomm::MpNewsMsg& SendCustomMessageReq::mpnews() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.mpnews)
  return mpnews_ != NULL ? *mpnews_ : *default_instance_->mpnews_;
}
inline ::mpcomm::MpNewsMsg* SendCustomMessageReq::mutable_mpnews() {
  set_has_mpnews();
  if (mpnews_ == NULL) mpnews_ = new ::mpcomm::MpNewsMsg;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.mpnews)
  return mpnews_;
}
inline ::mpcomm::MpNewsMsg* SendCustomMessageReq::release_mpnews() {
  clear_has_mpnews();
  ::mpcomm::MpNewsMsg* temp = mpnews_;
  mpnews_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_mpnews(::mpcomm::MpNewsMsg* mpnews) {
  delete mpnews_;
  mpnews_ = mpnews;
  if (mpnews) {
    set_has_mpnews();
  } else {
    clear_has_mpnews();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.mpnews)
}

// optional .mpcomm.WxCard wxcard = 11;
inline bool SendCustomMessageReq::has_wxcard() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SendCustomMessageReq::set_has_wxcard() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SendCustomMessageReq::clear_has_wxcard() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SendCustomMessageReq::clear_wxcard() {
  if (wxcard_ != NULL) wxcard_->::mpcomm::WxCard::Clear();
  clear_has_wxcard();
}
inline const ::mpcomm::WxCard& SendCustomMessageReq::wxcard() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.wxcard)
  return wxcard_ != NULL ? *wxcard_ : *default_instance_->wxcard_;
}
inline ::mpcomm::WxCard* SendCustomMessageReq::mutable_wxcard() {
  set_has_wxcard();
  if (wxcard_ == NULL) wxcard_ = new ::mpcomm::WxCard;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.wxcard)
  return wxcard_;
}
inline ::mpcomm::WxCard* SendCustomMessageReq::release_wxcard() {
  clear_has_wxcard();
  ::mpcomm::WxCard* temp = wxcard_;
  wxcard_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_wxcard(::mpcomm::WxCard* wxcard) {
  delete wxcard_;
  wxcard_ = wxcard;
  if (wxcard) {
    set_has_wxcard();
  } else {
    clear_has_wxcard();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.wxcard)
}

// optional .mpcomm.CustomServiceInfo customservice = 12;
inline bool SendCustomMessageReq::has_customservice() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SendCustomMessageReq::set_has_customservice() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SendCustomMessageReq::clear_has_customservice() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SendCustomMessageReq::clear_customservice() {
  if (customservice_ != NULL) customservice_->::mpcomm::CustomServiceInfo::Clear();
  clear_has_customservice();
}
inline const ::mpcomm::CustomServiceInfo& SendCustomMessageReq::customservice() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.customservice)
  return customservice_ != NULL ? *customservice_ : *default_instance_->customservice_;
}
inline ::mpcomm::CustomServiceInfo* SendCustomMessageReq::mutable_customservice() {
  set_has_customservice();
  if (customservice_ == NULL) customservice_ = new ::mpcomm::CustomServiceInfo;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.customservice)
  return customservice_;
}
inline ::mpcomm::CustomServiceInfo* SendCustomMessageReq::release_customservice() {
  clear_has_customservice();
  ::mpcomm::CustomServiceInfo* temp = customservice_;
  customservice_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_customservice(::mpcomm::CustomServiceInfo* customservice) {
  delete customservice_;
  customservice_ = customservice;
  if (customservice) {
    set_has_customservice();
  } else {
    clear_has_customservice();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.customservice)
}

// optional .mpcomm.MpVideo mpvideo = 13;
inline bool SendCustomMessageReq::has_mpvideo() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SendCustomMessageReq::set_has_mpvideo() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SendCustomMessageReq::clear_has_mpvideo() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SendCustomMessageReq::clear_mpvideo() {
  if (mpvideo_ != NULL) mpvideo_->::mpcomm::MpVideo::Clear();
  clear_has_mpvideo();
}
inline const ::mpcomm::MpVideo& SendCustomMessageReq::mpvideo() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageReq.mpvideo)
  return mpvideo_ != NULL ? *mpvideo_ : *default_instance_->mpvideo_;
}
inline ::mpcomm::MpVideo* SendCustomMessageReq::mutable_mpvideo() {
  set_has_mpvideo();
  if (mpvideo_ == NULL) mpvideo_ = new ::mpcomm::MpVideo;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageReq.mpvideo)
  return mpvideo_;
}
inline ::mpcomm::MpVideo* SendCustomMessageReq::release_mpvideo() {
  clear_has_mpvideo();
  ::mpcomm::MpVideo* temp = mpvideo_;
  mpvideo_ = NULL;
  return temp;
}
inline void SendCustomMessageReq::set_allocated_mpvideo(::mpcomm::MpVideo* mpvideo) {
  delete mpvideo_;
  mpvideo_ = mpvideo;
  if (mpvideo) {
    set_has_mpvideo();
  } else {
    clear_has_mpvideo();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageReq.mpvideo)
}

// -------------------------------------------------------------------

// SendCustomMessageResp

// optional int64 errcode = 1;
inline bool SendCustomMessageResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendCustomMessageResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendCustomMessageResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendCustomMessageResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 SendCustomMessageResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageResp.errcode)
  return errcode_;
}
inline void SendCustomMessageResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.SendCustomMessageResp.errcode)
}

// optional string errmsg = 2;
inline bool SendCustomMessageResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendCustomMessageResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendCustomMessageResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendCustomMessageResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& SendCustomMessageResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendCustomMessageResp.errmsg)
  return *errmsg_;
}
inline void SendCustomMessageResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SendCustomMessageResp.errmsg)
}
inline void SendCustomMessageResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SendCustomMessageResp.errmsg)
}
inline void SendCustomMessageResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SendCustomMessageResp.errmsg)
}
inline ::std::string* SendCustomMessageResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SendCustomMessageResp.errmsg)
  return errmsg_;
}
inline ::std::string* SendCustomMessageResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendCustomMessageResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendCustomMessageResp.errmsg)
}

// -------------------------------------------------------------------

// SendFilter

// optional bool is_to_all = 1;
inline bool SendFilter::has_is_to_all() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendFilter::set_has_is_to_all() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendFilter::clear_has_is_to_all() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendFilter::clear_is_to_all() {
  is_to_all_ = false;
  clear_has_is_to_all();
}
inline bool SendFilter::is_to_all() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendFilter.is_to_all)
  return is_to_all_;
}
inline void SendFilter::set_is_to_all(bool value) {
  set_has_is_to_all();
  is_to_all_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.SendFilter.is_to_all)
}

// optional uint64 tag_id = 2;
inline bool SendFilter::has_tag_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendFilter::set_has_tag_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendFilter::clear_has_tag_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendFilter::clear_tag_id() {
  tag_id_ = GOOGLE_ULONGLONG(0);
  clear_has_tag_id();
}
inline ::google::protobuf::uint64 SendFilter::tag_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendFilter.tag_id)
  return tag_id_;
}
inline void SendFilter::set_tag_id(::google::protobuf::uint64 value) {
  set_has_tag_id();
  tag_id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.SendFilter.tag_id)
}

// -------------------------------------------------------------------

// MassSendAllReq

// optional string access_token = 1;
inline bool MassSendAllReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassSendAllReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassSendAllReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassSendAllReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& MassSendAllReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllReq.access_token)
  return *access_token_;
}
inline void MassSendAllReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassSendAllReq.access_token)
}
inline void MassSendAllReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassSendAllReq.access_token)
}
inline void MassSendAllReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassSendAllReq.access_token)
}
inline ::std::string* MassSendAllReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllReq.access_token)
  return access_token_;
}
inline ::std::string* MassSendAllReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassSendAllReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllReq.access_token)
}

// optional .mpcomm.SendFilter filter = 2;
inline bool MassSendAllReq::has_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassSendAllReq::set_has_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassSendAllReq::clear_has_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassSendAllReq::clear_filter() {
  if (filter_ != NULL) filter_->::mpcomm::SendFilter::Clear();
  clear_has_filter();
}
inline const ::mpcomm::SendFilter& MassSendAllReq::filter() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllReq.filter)
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::mpcomm::SendFilter* MassSendAllReq::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::mpcomm::SendFilter;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllReq.filter)
  return filter_;
}
inline ::mpcomm::SendFilter* MassSendAllReq::release_filter() {
  clear_has_filter();
  ::mpcomm::SendFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void MassSendAllReq::set_allocated_filter(::mpcomm::SendFilter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllReq.filter)
}

// optional string msgtype = 3;
inline bool MassSendAllReq::has_msgtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MassSendAllReq::set_has_msgtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MassSendAllReq::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MassSendAllReq::clear_msgtype() {
  if (msgtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_->clear();
  }
  clear_has_msgtype();
}
inline const ::std::string& MassSendAllReq::msgtype() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllReq.msgtype)
  return *msgtype_;
}
inline void MassSendAllReq::set_msgtype(const ::std::string& value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassSendAllReq.msgtype)
}
inline void MassSendAllReq::set_msgtype(const char* value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassSendAllReq.msgtype)
}
inline void MassSendAllReq::set_msgtype(const char* value, size_t size) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassSendAllReq.msgtype)
}
inline ::std::string* MassSendAllReq::mutable_msgtype() {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllReq.msgtype)
  return msgtype_;
}
inline ::std::string* MassSendAllReq::release_msgtype() {
  clear_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgtype_;
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassSendAllReq::set_allocated_msgtype(::std::string* msgtype) {
  if (msgtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgtype_;
  }
  if (msgtype) {
    set_has_msgtype();
    msgtype_ = msgtype;
  } else {
    clear_has_msgtype();
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllReq.msgtype)
}

// optional .mpcomm.Text text = 4;
inline bool MassSendAllReq::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MassSendAllReq::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MassSendAllReq::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MassSendAllReq::clear_text() {
  if (text_ != NULL) text_->::mpcomm::Text::Clear();
  clear_has_text();
}
inline const ::mpcomm::Text& MassSendAllReq::text() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllReq.text)
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mpcomm::Text* MassSendAllReq::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mpcomm::Text;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllReq.text)
  return text_;
}
inline ::mpcomm::Text* MassSendAllReq::release_text() {
  clear_has_text();
  ::mpcomm::Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void MassSendAllReq::set_allocated_text(::mpcomm::Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllReq.text)
}

// optional .mpcomm.Image image = 5;
inline bool MassSendAllReq::has_image() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MassSendAllReq::set_has_image() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MassSendAllReq::clear_has_image() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MassSendAllReq::clear_image() {
  if (image_ != NULL) image_->::mpcomm::Image::Clear();
  clear_has_image();
}
inline const ::mpcomm::Image& MassSendAllReq::image() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllReq.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::mpcomm::Image* MassSendAllReq::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::mpcomm::Image;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllReq.image)
  return image_;
}
inline ::mpcomm::Image* MassSendAllReq::release_image() {
  clear_has_image();
  ::mpcomm::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void MassSendAllReq::set_allocated_image(::mpcomm::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllReq.image)
}

// optional .mpcomm.Voice voice = 6;
inline bool MassSendAllReq::has_voice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MassSendAllReq::set_has_voice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MassSendAllReq::clear_has_voice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MassSendAllReq::clear_voice() {
  if (voice_ != NULL) voice_->::mpcomm::Voice::Clear();
  clear_has_voice();
}
inline const ::mpcomm::Voice& MassSendAllReq::voice() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllReq.voice)
  return voice_ != NULL ? *voice_ : *default_instance_->voice_;
}
inline ::mpcomm::Voice* MassSendAllReq::mutable_voice() {
  set_has_voice();
  if (voice_ == NULL) voice_ = new ::mpcomm::Voice;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllReq.voice)
  return voice_;
}
inline ::mpcomm::Voice* MassSendAllReq::release_voice() {
  clear_has_voice();
  ::mpcomm::Voice* temp = voice_;
  voice_ = NULL;
  return temp;
}
inline void MassSendAllReq::set_allocated_voice(::mpcomm::Voice* voice) {
  delete voice_;
  voice_ = voice;
  if (voice) {
    set_has_voice();
  } else {
    clear_has_voice();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllReq.voice)
}

// optional .mpcomm.MpVideo mpvideo = 7;
inline bool MassSendAllReq::has_mpvideo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MassSendAllReq::set_has_mpvideo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MassSendAllReq::clear_has_mpvideo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MassSendAllReq::clear_mpvideo() {
  if (mpvideo_ != NULL) mpvideo_->::mpcomm::MpVideo::Clear();
  clear_has_mpvideo();
}
inline const ::mpcomm::MpVideo& MassSendAllReq::mpvideo() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllReq.mpvideo)
  return mpvideo_ != NULL ? *mpvideo_ : *default_instance_->mpvideo_;
}
inline ::mpcomm::MpVideo* MassSendAllReq::mutable_mpvideo() {
  set_has_mpvideo();
  if (mpvideo_ == NULL) mpvideo_ = new ::mpcomm::MpVideo;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllReq.mpvideo)
  return mpvideo_;
}
inline ::mpcomm::MpVideo* MassSendAllReq::release_mpvideo() {
  clear_has_mpvideo();
  ::mpcomm::MpVideo* temp = mpvideo_;
  mpvideo_ = NULL;
  return temp;
}
inline void MassSendAllReq::set_allocated_mpvideo(::mpcomm::MpVideo* mpvideo) {
  delete mpvideo_;
  mpvideo_ = mpvideo;
  if (mpvideo) {
    set_has_mpvideo();
  } else {
    clear_has_mpvideo();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllReq.mpvideo)
}

// optional .mpcomm.MpNewsMsg mpnews = 8;
inline bool MassSendAllReq::has_mpnews() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MassSendAllReq::set_has_mpnews() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MassSendAllReq::clear_has_mpnews() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MassSendAllReq::clear_mpnews() {
  if (mpnews_ != NULL) mpnews_->::mpcomm::MpNewsMsg::Clear();
  clear_has_mpnews();
}
inline const ::mpcomm::MpNewsMsg& MassSendAllReq::mpnews() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllReq.mpnews)
  return mpnews_ != NULL ? *mpnews_ : *default_instance_->mpnews_;
}
inline ::mpcomm::MpNewsMsg* MassSendAllReq::mutable_mpnews() {
  set_has_mpnews();
  if (mpnews_ == NULL) mpnews_ = new ::mpcomm::MpNewsMsg;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllReq.mpnews)
  return mpnews_;
}
inline ::mpcomm::MpNewsMsg* MassSendAllReq::release_mpnews() {
  clear_has_mpnews();
  ::mpcomm::MpNewsMsg* temp = mpnews_;
  mpnews_ = NULL;
  return temp;
}
inline void MassSendAllReq::set_allocated_mpnews(::mpcomm::MpNewsMsg* mpnews) {
  delete mpnews_;
  mpnews_ = mpnews;
  if (mpnews) {
    set_has_mpnews();
  } else {
    clear_has_mpnews();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllReq.mpnews)
}

// optional .mpcomm.WxCard wxcard = 9;
inline bool MassSendAllReq::has_wxcard() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MassSendAllReq::set_has_wxcard() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MassSendAllReq::clear_has_wxcard() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MassSendAllReq::clear_wxcard() {
  if (wxcard_ != NULL) wxcard_->::mpcomm::WxCard::Clear();
  clear_has_wxcard();
}
inline const ::mpcomm::WxCard& MassSendAllReq::wxcard() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllReq.wxcard)
  return wxcard_ != NULL ? *wxcard_ : *default_instance_->wxcard_;
}
inline ::mpcomm::WxCard* MassSendAllReq::mutable_wxcard() {
  set_has_wxcard();
  if (wxcard_ == NULL) wxcard_ = new ::mpcomm::WxCard;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllReq.wxcard)
  return wxcard_;
}
inline ::mpcomm::WxCard* MassSendAllReq::release_wxcard() {
  clear_has_wxcard();
  ::mpcomm::WxCard* temp = wxcard_;
  wxcard_ = NULL;
  return temp;
}
inline void MassSendAllReq::set_allocated_wxcard(::mpcomm::WxCard* wxcard) {
  delete wxcard_;
  wxcard_ = wxcard;
  if (wxcard) {
    set_has_wxcard();
  } else {
    clear_has_wxcard();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllReq.wxcard)
}

// -------------------------------------------------------------------

// MassSendAllResp

// optional int64 errcode = 1;
inline bool MassSendAllResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassSendAllResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassSendAllResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassSendAllResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 MassSendAllResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllResp.errcode)
  return errcode_;
}
inline void MassSendAllResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassSendAllResp.errcode)
}

// optional string errmsg = 2;
inline bool MassSendAllResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassSendAllResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassSendAllResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassSendAllResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& MassSendAllResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllResp.errmsg)
  return *errmsg_;
}
inline void MassSendAllResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassSendAllResp.errmsg)
}
inline void MassSendAllResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassSendAllResp.errmsg)
}
inline void MassSendAllResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassSendAllResp.errmsg)
}
inline ::std::string* MassSendAllResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendAllResp.errmsg)
  return errmsg_;
}
inline ::std::string* MassSendAllResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassSendAllResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendAllResp.errmsg)
}

// optional uint64 msg_id = 3;
inline bool MassSendAllResp::has_msg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MassSendAllResp::set_has_msg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MassSendAllResp::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MassSendAllResp::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 MassSendAllResp::msg_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllResp.msg_id)
  return msg_id_;
}
inline void MassSendAllResp::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassSendAllResp.msg_id)
}

// optional uint64 msg_data_id = 4;
inline bool MassSendAllResp::has_msg_data_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MassSendAllResp::set_has_msg_data_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MassSendAllResp::clear_has_msg_data_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MassSendAllResp::clear_msg_data_id() {
  msg_data_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_data_id();
}
inline ::google::protobuf::uint64 MassSendAllResp::msg_data_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendAllResp.msg_data_id)
  return msg_data_id_;
}
inline void MassSendAllResp::set_msg_data_id(::google::protobuf::uint64 value) {
  set_has_msg_data_id();
  msg_data_id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassSendAllResp.msg_data_id)
}

// -------------------------------------------------------------------

// MassSendReq

// optional string access_token = 1;
inline bool MassSendReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassSendReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassSendReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassSendReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& MassSendReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendReq.access_token)
  return *access_token_;
}
inline void MassSendReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassSendReq.access_token)
}
inline void MassSendReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassSendReq.access_token)
}
inline void MassSendReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassSendReq.access_token)
}
inline ::std::string* MassSendReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendReq.access_token)
  return access_token_;
}
inline ::std::string* MassSendReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassSendReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendReq.access_token)
}

// repeated string touser = 2;
inline int MassSendReq::touser_size() const {
  return touser_.size();
}
inline void MassSendReq::clear_touser() {
  touser_.Clear();
}
inline const ::std::string& MassSendReq::touser(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendReq.touser)
  return touser_.Get(index);
}
inline ::std::string* MassSendReq::mutable_touser(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendReq.touser)
  return touser_.Mutable(index);
}
inline void MassSendReq::set_touser(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mpcomm.MassSendReq.touser)
  touser_.Mutable(index)->assign(value);
}
inline void MassSendReq::set_touser(int index, const char* value) {
  touser_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassSendReq.touser)
}
inline void MassSendReq::set_touser(int index, const char* value, size_t size) {
  touser_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassSendReq.touser)
}
inline ::std::string* MassSendReq::add_touser() {
  return touser_.Add();
}
inline void MassSendReq::add_touser(const ::std::string& value) {
  touser_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mpcomm.MassSendReq.touser)
}
inline void MassSendReq::add_touser(const char* value) {
  touser_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mpcomm.MassSendReq.touser)
}
inline void MassSendReq::add_touser(const char* value, size_t size) {
  touser_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mpcomm.MassSendReq.touser)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MassSendReq::touser() const {
  // @@protoc_insertion_point(field_list:mpcomm.MassSendReq.touser)
  return touser_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MassSendReq::mutable_touser() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.MassSendReq.touser)
  return &touser_;
}

// optional string msgtype = 3;
inline bool MassSendReq::has_msgtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MassSendReq::set_has_msgtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MassSendReq::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MassSendReq::clear_msgtype() {
  if (msgtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_->clear();
  }
  clear_has_msgtype();
}
inline const ::std::string& MassSendReq::msgtype() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendReq.msgtype)
  return *msgtype_;
}
inline void MassSendReq::set_msgtype(const ::std::string& value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassSendReq.msgtype)
}
inline void MassSendReq::set_msgtype(const char* value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassSendReq.msgtype)
}
inline void MassSendReq::set_msgtype(const char* value, size_t size) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassSendReq.msgtype)
}
inline ::std::string* MassSendReq::mutable_msgtype() {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendReq.msgtype)
  return msgtype_;
}
inline ::std::string* MassSendReq::release_msgtype() {
  clear_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgtype_;
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassSendReq::set_allocated_msgtype(::std::string* msgtype) {
  if (msgtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgtype_;
  }
  if (msgtype) {
    set_has_msgtype();
    msgtype_ = msgtype;
  } else {
    clear_has_msgtype();
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendReq.msgtype)
}

// optional .mpcomm.Text text = 4;
inline bool MassSendReq::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MassSendReq::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MassSendReq::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MassSendReq::clear_text() {
  if (text_ != NULL) text_->::mpcomm::Text::Clear();
  clear_has_text();
}
inline const ::mpcomm::Text& MassSendReq::text() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendReq.text)
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mpcomm::Text* MassSendReq::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mpcomm::Text;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendReq.text)
  return text_;
}
inline ::mpcomm::Text* MassSendReq::release_text() {
  clear_has_text();
  ::mpcomm::Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void MassSendReq::set_allocated_text(::mpcomm::Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendReq.text)
}

// optional .mpcomm.Image image = 5;
inline bool MassSendReq::has_image() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MassSendReq::set_has_image() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MassSendReq::clear_has_image() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MassSendReq::clear_image() {
  if (image_ != NULL) image_->::mpcomm::Image::Clear();
  clear_has_image();
}
inline const ::mpcomm::Image& MassSendReq::image() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendReq.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::mpcomm::Image* MassSendReq::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::mpcomm::Image;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendReq.image)
  return image_;
}
inline ::mpcomm::Image* MassSendReq::release_image() {
  clear_has_image();
  ::mpcomm::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void MassSendReq::set_allocated_image(::mpcomm::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendReq.image)
}

// optional .mpcomm.Voice voice = 6;
inline bool MassSendReq::has_voice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MassSendReq::set_has_voice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MassSendReq::clear_has_voice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MassSendReq::clear_voice() {
  if (voice_ != NULL) voice_->::mpcomm::Voice::Clear();
  clear_has_voice();
}
inline const ::mpcomm::Voice& MassSendReq::voice() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendReq.voice)
  return voice_ != NULL ? *voice_ : *default_instance_->voice_;
}
inline ::mpcomm::Voice* MassSendReq::mutable_voice() {
  set_has_voice();
  if (voice_ == NULL) voice_ = new ::mpcomm::Voice;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendReq.voice)
  return voice_;
}
inline ::mpcomm::Voice* MassSendReq::release_voice() {
  clear_has_voice();
  ::mpcomm::Voice* temp = voice_;
  voice_ = NULL;
  return temp;
}
inline void MassSendReq::set_allocated_voice(::mpcomm::Voice* voice) {
  delete voice_;
  voice_ = voice;
  if (voice) {
    set_has_voice();
  } else {
    clear_has_voice();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendReq.voice)
}

// optional .mpcomm.MpNewsMsg mpnews = 8;
inline bool MassSendReq::has_mpnews() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MassSendReq::set_has_mpnews() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MassSendReq::clear_has_mpnews() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MassSendReq::clear_mpnews() {
  if (mpnews_ != NULL) mpnews_->::mpcomm::MpNewsMsg::Clear();
  clear_has_mpnews();
}
inline const ::mpcomm::MpNewsMsg& MassSendReq::mpnews() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendReq.mpnews)
  return mpnews_ != NULL ? *mpnews_ : *default_instance_->mpnews_;
}
inline ::mpcomm::MpNewsMsg* MassSendReq::mutable_mpnews() {
  set_has_mpnews();
  if (mpnews_ == NULL) mpnews_ = new ::mpcomm::MpNewsMsg;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendReq.mpnews)
  return mpnews_;
}
inline ::mpcomm::MpNewsMsg* MassSendReq::release_mpnews() {
  clear_has_mpnews();
  ::mpcomm::MpNewsMsg* temp = mpnews_;
  mpnews_ = NULL;
  return temp;
}
inline void MassSendReq::set_allocated_mpnews(::mpcomm::MpNewsMsg* mpnews) {
  delete mpnews_;
  mpnews_ = mpnews;
  if (mpnews) {
    set_has_mpnews();
  } else {
    clear_has_mpnews();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendReq.mpnews)
}

// optional .mpcomm.WxCard wxcard = 9;
inline bool MassSendReq::has_wxcard() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MassSendReq::set_has_wxcard() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MassSendReq::clear_has_wxcard() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MassSendReq::clear_wxcard() {
  if (wxcard_ != NULL) wxcard_->::mpcomm::WxCard::Clear();
  clear_has_wxcard();
}
inline const ::mpcomm::WxCard& MassSendReq::wxcard() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendReq.wxcard)
  return wxcard_ != NULL ? *wxcard_ : *default_instance_->wxcard_;
}
inline ::mpcomm::WxCard* MassSendReq::mutable_wxcard() {
  set_has_wxcard();
  if (wxcard_ == NULL) wxcard_ = new ::mpcomm::WxCard;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendReq.wxcard)
  return wxcard_;
}
inline ::mpcomm::WxCard* MassSendReq::release_wxcard() {
  clear_has_wxcard();
  ::mpcomm::WxCard* temp = wxcard_;
  wxcard_ = NULL;
  return temp;
}
inline void MassSendReq::set_allocated_wxcard(::mpcomm::WxCard* wxcard) {
  delete wxcard_;
  wxcard_ = wxcard;
  if (wxcard) {
    set_has_wxcard();
  } else {
    clear_has_wxcard();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendReq.wxcard)
}

// optional .mpcomm.MpVideo mpvideo = 10;
inline bool MassSendReq::has_mpvideo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MassSendReq::set_has_mpvideo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MassSendReq::clear_has_mpvideo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MassSendReq::clear_mpvideo() {
  if (mpvideo_ != NULL) mpvideo_->::mpcomm::MpVideo::Clear();
  clear_has_mpvideo();
}
inline const ::mpcomm::MpVideo& MassSendReq::mpvideo() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendReq.mpvideo)
  return mpvideo_ != NULL ? *mpvideo_ : *default_instance_->mpvideo_;
}
inline ::mpcomm::MpVideo* MassSendReq::mutable_mpvideo() {
  set_has_mpvideo();
  if (mpvideo_ == NULL) mpvideo_ = new ::mpcomm::MpVideo;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendReq.mpvideo)
  return mpvideo_;
}
inline ::mpcomm::MpVideo* MassSendReq::release_mpvideo() {
  clear_has_mpvideo();
  ::mpcomm::MpVideo* temp = mpvideo_;
  mpvideo_ = NULL;
  return temp;
}
inline void MassSendReq::set_allocated_mpvideo(::mpcomm::MpVideo* mpvideo) {
  delete mpvideo_;
  mpvideo_ = mpvideo;
  if (mpvideo) {
    set_has_mpvideo();
  } else {
    clear_has_mpvideo();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendReq.mpvideo)
}

// -------------------------------------------------------------------

// MassSendResp

// optional int64 errcode = 1;
inline bool MassSendResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassSendResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassSendResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassSendResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 MassSendResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendResp.errcode)
  return errcode_;
}
inline void MassSendResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassSendResp.errcode)
}

// optional string errmsg = 2;
inline bool MassSendResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassSendResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassSendResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassSendResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& MassSendResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendResp.errmsg)
  return *errmsg_;
}
inline void MassSendResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassSendResp.errmsg)
}
inline void MassSendResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassSendResp.errmsg)
}
inline void MassSendResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassSendResp.errmsg)
}
inline ::std::string* MassSendResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassSendResp.errmsg)
  return errmsg_;
}
inline ::std::string* MassSendResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassSendResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassSendResp.errmsg)
}

// optional uint64 msg_id = 3;
inline bool MassSendResp::has_msg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MassSendResp::set_has_msg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MassSendResp::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MassSendResp::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 MassSendResp::msg_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendResp.msg_id)
  return msg_id_;
}
inline void MassSendResp::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassSendResp.msg_id)
}

// optional uint64 msg_data_id = 4;
inline bool MassSendResp::has_msg_data_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MassSendResp::set_has_msg_data_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MassSendResp::clear_has_msg_data_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MassSendResp::clear_msg_data_id() {
  msg_data_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_data_id();
}
inline ::google::protobuf::uint64 MassSendResp::msg_data_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassSendResp.msg_data_id)
  return msg_data_id_;
}
inline void MassSendResp::set_msg_data_id(::google::protobuf::uint64 value) {
  set_has_msg_data_id();
  msg_data_id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassSendResp.msg_data_id)
}

// -------------------------------------------------------------------

// MassDeleteReq

// optional string access_token = 1;
inline bool MassDeleteReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassDeleteReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassDeleteReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassDeleteReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& MassDeleteReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassDeleteReq.access_token)
  return *access_token_;
}
inline void MassDeleteReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassDeleteReq.access_token)
}
inline void MassDeleteReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassDeleteReq.access_token)
}
inline void MassDeleteReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassDeleteReq.access_token)
}
inline ::std::string* MassDeleteReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassDeleteReq.access_token)
  return access_token_;
}
inline ::std::string* MassDeleteReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassDeleteReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassDeleteReq.access_token)
}

// optional uint64 msg_id = 2;
inline bool MassDeleteReq::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassDeleteReq::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassDeleteReq::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassDeleteReq::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 MassDeleteReq::msg_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassDeleteReq.msg_id)
  return msg_id_;
}
inline void MassDeleteReq::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassDeleteReq.msg_id)
}

// -------------------------------------------------------------------

// MassDeleteResp

// optional int64 errcode = 1;
inline bool MassDeleteResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassDeleteResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassDeleteResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassDeleteResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 MassDeleteResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassDeleteResp.errcode)
  return errcode_;
}
inline void MassDeleteResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassDeleteResp.errcode)
}

// optional string errmsg = 2;
inline bool MassDeleteResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassDeleteResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassDeleteResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassDeleteResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& MassDeleteResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassDeleteResp.errmsg)
  return *errmsg_;
}
inline void MassDeleteResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassDeleteResp.errmsg)
}
inline void MassDeleteResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassDeleteResp.errmsg)
}
inline void MassDeleteResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassDeleteResp.errmsg)
}
inline ::std::string* MassDeleteResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassDeleteResp.errmsg)
  return errmsg_;
}
inline ::std::string* MassDeleteResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassDeleteResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassDeleteResp.errmsg)
}

// optional uint64 msg_id = 3;
inline bool MassDeleteResp::has_msg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MassDeleteResp::set_has_msg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MassDeleteResp::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MassDeleteResp::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 MassDeleteResp::msg_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassDeleteResp.msg_id)
  return msg_id_;
}
inline void MassDeleteResp::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassDeleteResp.msg_id)
}

// -------------------------------------------------------------------

// MassPreviewReq

// optional string access_token = 1;
inline bool MassPreviewReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassPreviewReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassPreviewReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassPreviewReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& MassPreviewReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.access_token)
  return *access_token_;
}
inline void MassPreviewReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassPreviewReq.access_token)
}
inline void MassPreviewReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassPreviewReq.access_token)
}
inline void MassPreviewReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassPreviewReq.access_token)
}
inline ::std::string* MassPreviewReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.access_token)
  return access_token_;
}
inline ::std::string* MassPreviewReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassPreviewReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.access_token)
}

// optional string touser = 2;
inline bool MassPreviewReq::has_touser() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassPreviewReq::set_has_touser() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassPreviewReq::clear_has_touser() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassPreviewReq::clear_touser() {
  if (touser_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_->clear();
  }
  clear_has_touser();
}
inline const ::std::string& MassPreviewReq::touser() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.touser)
  return *touser_;
}
inline void MassPreviewReq::set_touser(const ::std::string& value) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  touser_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassPreviewReq.touser)
}
inline void MassPreviewReq::set_touser(const char* value) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  touser_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassPreviewReq.touser)
}
inline void MassPreviewReq::set_touser(const char* value, size_t size) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  touser_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassPreviewReq.touser)
}
inline ::std::string* MassPreviewReq::mutable_touser() {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.touser)
  return touser_;
}
inline ::std::string* MassPreviewReq::release_touser() {
  clear_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = touser_;
    touser_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassPreviewReq::set_allocated_touser(::std::string* touser) {
  if (touser_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete touser_;
  }
  if (touser) {
    set_has_touser();
    touser_ = touser;
  } else {
    clear_has_touser();
    touser_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.touser)
}

// optional string towxname = 3;
inline bool MassPreviewReq::has_towxname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MassPreviewReq::set_has_towxname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MassPreviewReq::clear_has_towxname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MassPreviewReq::clear_towxname() {
  if (towxname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    towxname_->clear();
  }
  clear_has_towxname();
}
inline const ::std::string& MassPreviewReq::towxname() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.towxname)
  return *towxname_;
}
inline void MassPreviewReq::set_towxname(const ::std::string& value) {
  set_has_towxname();
  if (towxname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    towxname_ = new ::std::string;
  }
  towxname_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassPreviewReq.towxname)
}
inline void MassPreviewReq::set_towxname(const char* value) {
  set_has_towxname();
  if (towxname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    towxname_ = new ::std::string;
  }
  towxname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassPreviewReq.towxname)
}
inline void MassPreviewReq::set_towxname(const char* value, size_t size) {
  set_has_towxname();
  if (towxname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    towxname_ = new ::std::string;
  }
  towxname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassPreviewReq.towxname)
}
inline ::std::string* MassPreviewReq::mutable_towxname() {
  set_has_towxname();
  if (towxname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    towxname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.towxname)
  return towxname_;
}
inline ::std::string* MassPreviewReq::release_towxname() {
  clear_has_towxname();
  if (towxname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = towxname_;
    towxname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassPreviewReq::set_allocated_towxname(::std::string* towxname) {
  if (towxname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete towxname_;
  }
  if (towxname) {
    set_has_towxname();
    towxname_ = towxname;
  } else {
    clear_has_towxname();
    towxname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.towxname)
}

// optional string msgtype = 4;
inline bool MassPreviewReq::has_msgtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MassPreviewReq::set_has_msgtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MassPreviewReq::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MassPreviewReq::clear_msgtype() {
  if (msgtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_->clear();
  }
  clear_has_msgtype();
}
inline const ::std::string& MassPreviewReq::msgtype() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.msgtype)
  return *msgtype_;
}
inline void MassPreviewReq::set_msgtype(const ::std::string& value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassPreviewReq.msgtype)
}
inline void MassPreviewReq::set_msgtype(const char* value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassPreviewReq.msgtype)
}
inline void MassPreviewReq::set_msgtype(const char* value, size_t size) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassPreviewReq.msgtype)
}
inline ::std::string* MassPreviewReq::mutable_msgtype() {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.msgtype)
  return msgtype_;
}
inline ::std::string* MassPreviewReq::release_msgtype() {
  clear_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgtype_;
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassPreviewReq::set_allocated_msgtype(::std::string* msgtype) {
  if (msgtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgtype_;
  }
  if (msgtype) {
    set_has_msgtype();
    msgtype_ = msgtype;
  } else {
    clear_has_msgtype();
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.msgtype)
}

// optional .mpcomm.Text text = 5;
inline bool MassPreviewReq::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MassPreviewReq::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MassPreviewReq::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MassPreviewReq::clear_text() {
  if (text_ != NULL) text_->::mpcomm::Text::Clear();
  clear_has_text();
}
inline const ::mpcomm::Text& MassPreviewReq::text() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.text)
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
inline ::mpcomm::Text* MassPreviewReq::mutable_text() {
  set_has_text();
  if (text_ == NULL) text_ = new ::mpcomm::Text;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.text)
  return text_;
}
inline ::mpcomm::Text* MassPreviewReq::release_text() {
  clear_has_text();
  ::mpcomm::Text* temp = text_;
  text_ = NULL;
  return temp;
}
inline void MassPreviewReq::set_allocated_text(::mpcomm::Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.text)
}

// optional .mpcomm.Image image = 6;
inline bool MassPreviewReq::has_image() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MassPreviewReq::set_has_image() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MassPreviewReq::clear_has_image() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MassPreviewReq::clear_image() {
  if (image_ != NULL) image_->::mpcomm::Image::Clear();
  clear_has_image();
}
inline const ::mpcomm::Image& MassPreviewReq::image() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::mpcomm::Image* MassPreviewReq::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::mpcomm::Image;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.image)
  return image_;
}
inline ::mpcomm::Image* MassPreviewReq::release_image() {
  clear_has_image();
  ::mpcomm::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void MassPreviewReq::set_allocated_image(::mpcomm::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.image)
}

// optional .mpcomm.Voice voice = 7;
inline bool MassPreviewReq::has_voice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MassPreviewReq::set_has_voice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MassPreviewReq::clear_has_voice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MassPreviewReq::clear_voice() {
  if (voice_ != NULL) voice_->::mpcomm::Voice::Clear();
  clear_has_voice();
}
inline const ::mpcomm::Voice& MassPreviewReq::voice() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.voice)
  return voice_ != NULL ? *voice_ : *default_instance_->voice_;
}
inline ::mpcomm::Voice* MassPreviewReq::mutable_voice() {
  set_has_voice();
  if (voice_ == NULL) voice_ = new ::mpcomm::Voice;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.voice)
  return voice_;
}
inline ::mpcomm::Voice* MassPreviewReq::release_voice() {
  clear_has_voice();
  ::mpcomm::Voice* temp = voice_;
  voice_ = NULL;
  return temp;
}
inline void MassPreviewReq::set_allocated_voice(::mpcomm::Voice* voice) {
  delete voice_;
  voice_ = voice;
  if (voice) {
    set_has_voice();
  } else {
    clear_has_voice();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.voice)
}

// optional .mpcomm.MpNewsMsg mpnews = 8;
inline bool MassPreviewReq::has_mpnews() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MassPreviewReq::set_has_mpnews() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MassPreviewReq::clear_has_mpnews() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MassPreviewReq::clear_mpnews() {
  if (mpnews_ != NULL) mpnews_->::mpcomm::MpNewsMsg::Clear();
  clear_has_mpnews();
}
inline const ::mpcomm::MpNewsMsg& MassPreviewReq::mpnews() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.mpnews)
  return mpnews_ != NULL ? *mpnews_ : *default_instance_->mpnews_;
}
inline ::mpcomm::MpNewsMsg* MassPreviewReq::mutable_mpnews() {
  set_has_mpnews();
  if (mpnews_ == NULL) mpnews_ = new ::mpcomm::MpNewsMsg;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.mpnews)
  return mpnews_;
}
inline ::mpcomm::MpNewsMsg* MassPreviewReq::release_mpnews() {
  clear_has_mpnews();
  ::mpcomm::MpNewsMsg* temp = mpnews_;
  mpnews_ = NULL;
  return temp;
}
inline void MassPreviewReq::set_allocated_mpnews(::mpcomm::MpNewsMsg* mpnews) {
  delete mpnews_;
  mpnews_ = mpnews;
  if (mpnews) {
    set_has_mpnews();
  } else {
    clear_has_mpnews();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.mpnews)
}

// optional .mpcomm.WxCard wxcard = 9;
inline bool MassPreviewReq::has_wxcard() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MassPreviewReq::set_has_wxcard() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MassPreviewReq::clear_has_wxcard() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MassPreviewReq::clear_wxcard() {
  if (wxcard_ != NULL) wxcard_->::mpcomm::WxCard::Clear();
  clear_has_wxcard();
}
inline const ::mpcomm::WxCard& MassPreviewReq::wxcard() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.wxcard)
  return wxcard_ != NULL ? *wxcard_ : *default_instance_->wxcard_;
}
inline ::mpcomm::WxCard* MassPreviewReq::mutable_wxcard() {
  set_has_wxcard();
  if (wxcard_ == NULL) wxcard_ = new ::mpcomm::WxCard;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.wxcard)
  return wxcard_;
}
inline ::mpcomm::WxCard* MassPreviewReq::release_wxcard() {
  clear_has_wxcard();
  ::mpcomm::WxCard* temp = wxcard_;
  wxcard_ = NULL;
  return temp;
}
inline void MassPreviewReq::set_allocated_wxcard(::mpcomm::WxCard* wxcard) {
  delete wxcard_;
  wxcard_ = wxcard;
  if (wxcard) {
    set_has_wxcard();
  } else {
    clear_has_wxcard();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.wxcard)
}

// optional .mpcomm.MpVideo mpvideo = 10;
inline bool MassPreviewReq::has_mpvideo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MassPreviewReq::set_has_mpvideo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MassPreviewReq::clear_has_mpvideo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MassPreviewReq::clear_mpvideo() {
  if (mpvideo_ != NULL) mpvideo_->::mpcomm::MpVideo::Clear();
  clear_has_mpvideo();
}
inline const ::mpcomm::MpVideo& MassPreviewReq::mpvideo() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewReq.mpvideo)
  return mpvideo_ != NULL ? *mpvideo_ : *default_instance_->mpvideo_;
}
inline ::mpcomm::MpVideo* MassPreviewReq::mutable_mpvideo() {
  set_has_mpvideo();
  if (mpvideo_ == NULL) mpvideo_ = new ::mpcomm::MpVideo;
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewReq.mpvideo)
  return mpvideo_;
}
inline ::mpcomm::MpVideo* MassPreviewReq::release_mpvideo() {
  clear_has_mpvideo();
  ::mpcomm::MpVideo* temp = mpvideo_;
  mpvideo_ = NULL;
  return temp;
}
inline void MassPreviewReq::set_allocated_mpvideo(::mpcomm::MpVideo* mpvideo) {
  delete mpvideo_;
  mpvideo_ = mpvideo;
  if (mpvideo) {
    set_has_mpvideo();
  } else {
    clear_has_mpvideo();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewReq.mpvideo)
}

// -------------------------------------------------------------------

// MassPreviewResp

// optional int64 errcode = 1;
inline bool MassPreviewResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassPreviewResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassPreviewResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassPreviewResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 MassPreviewResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewResp.errcode)
  return errcode_;
}
inline void MassPreviewResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassPreviewResp.errcode)
}

// optional string errmsg = 2;
inline bool MassPreviewResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassPreviewResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassPreviewResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassPreviewResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& MassPreviewResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassPreviewResp.errmsg)
  return *errmsg_;
}
inline void MassPreviewResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassPreviewResp.errmsg)
}
inline void MassPreviewResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassPreviewResp.errmsg)
}
inline void MassPreviewResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassPreviewResp.errmsg)
}
inline ::std::string* MassPreviewResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassPreviewResp.errmsg)
  return errmsg_;
}
inline ::std::string* MassPreviewResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassPreviewResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassPreviewResp.errmsg)
}

// -------------------------------------------------------------------

// MassGetReq

// optional string access_token = 1;
inline bool MassGetReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassGetReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassGetReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassGetReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& MassGetReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassGetReq.access_token)
  return *access_token_;
}
inline void MassGetReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassGetReq.access_token)
}
inline void MassGetReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassGetReq.access_token)
}
inline void MassGetReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassGetReq.access_token)
}
inline ::std::string* MassGetReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassGetReq.access_token)
  return access_token_;
}
inline ::std::string* MassGetReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassGetReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassGetReq.access_token)
}

// optional uint64 msg_id = 2;
inline bool MassGetReq::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassGetReq::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassGetReq::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassGetReq::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 MassGetReq::msg_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassGetReq.msg_id)
  return msg_id_;
}
inline void MassGetReq::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassGetReq.msg_id)
}

// -------------------------------------------------------------------

// MassGetResp

// optional int64 errcode = 1;
inline bool MassGetResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MassGetResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MassGetResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MassGetResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 MassGetResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassGetResp.errcode)
  return errcode_;
}
inline void MassGetResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassGetResp.errcode)
}

// optional string errmsg = 2;
inline bool MassGetResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MassGetResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MassGetResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MassGetResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& MassGetResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassGetResp.errmsg)
  return *errmsg_;
}
inline void MassGetResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassGetResp.errmsg)
}
inline void MassGetResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassGetResp.errmsg)
}
inline void MassGetResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassGetResp.errmsg)
}
inline ::std::string* MassGetResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassGetResp.errmsg)
  return errmsg_;
}
inline ::std::string* MassGetResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassGetResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassGetResp.errmsg)
}

// optional uint64 msg_id = 3;
inline bool MassGetResp::has_msg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MassGetResp::set_has_msg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MassGetResp::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MassGetResp::clear_msg_id() {
  msg_id_ = GOOGLE_ULONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::uint64 MassGetResp::msg_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassGetResp.msg_id)
  return msg_id_;
}
inline void MassGetResp::set_msg_id(::google::protobuf::uint64 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MassGetResp.msg_id)
}

// optional string msg_status = 4;
inline bool MassGetResp::has_msg_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MassGetResp::set_has_msg_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MassGetResp::clear_has_msg_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MassGetResp::clear_msg_status() {
  if (msg_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_status_->clear();
  }
  clear_has_msg_status();
}
inline const ::std::string& MassGetResp::msg_status() const {
  // @@protoc_insertion_point(field_get:mpcomm.MassGetResp.msg_status)
  return *msg_status_;
}
inline void MassGetResp::set_msg_status(const ::std::string& value) {
  set_has_msg_status();
  if (msg_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_status_ = new ::std::string;
  }
  msg_status_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MassGetResp.msg_status)
}
inline void MassGetResp::set_msg_status(const char* value) {
  set_has_msg_status();
  if (msg_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_status_ = new ::std::string;
  }
  msg_status_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MassGetResp.msg_status)
}
inline void MassGetResp::set_msg_status(const char* value, size_t size) {
  set_has_msg_status();
  if (msg_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_status_ = new ::std::string;
  }
  msg_status_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MassGetResp.msg_status)
}
inline ::std::string* MassGetResp::mutable_msg_status() {
  set_has_msg_status();
  if (msg_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_status_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MassGetResp.msg_status)
  return msg_status_;
}
inline ::std::string* MassGetResp::release_msg_status() {
  clear_has_msg_status();
  if (msg_status_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_status_;
    msg_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MassGetResp::set_allocated_msg_status(::std::string* msg_status) {
  if (msg_status_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_status_;
  }
  if (msg_status) {
    set_has_msg_status();
    msg_status_ = msg_status;
  } else {
    clear_has_msg_status();
    msg_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MassGetResp.msg_status)
}

// -------------------------------------------------------------------

// SetIndustryReq

// optional string access_token = 1;
inline bool SetIndustryReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetIndustryReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetIndustryReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetIndustryReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& SetIndustryReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.SetIndustryReq.access_token)
  return *access_token_;
}
inline void SetIndustryReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SetIndustryReq.access_token)
}
inline void SetIndustryReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SetIndustryReq.access_token)
}
inline void SetIndustryReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SetIndustryReq.access_token)
}
inline ::std::string* SetIndustryReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SetIndustryReq.access_token)
  return access_token_;
}
inline ::std::string* SetIndustryReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetIndustryReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SetIndustryReq.access_token)
}

// optional string industry_id1 = 2;
inline bool SetIndustryReq::has_industry_id1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetIndustryReq::set_has_industry_id1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetIndustryReq::clear_has_industry_id1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetIndustryReq::clear_industry_id1() {
  if (industry_id1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id1_->clear();
  }
  clear_has_industry_id1();
}
inline const ::std::string& SetIndustryReq::industry_id1() const {
  // @@protoc_insertion_point(field_get:mpcomm.SetIndustryReq.industry_id1)
  return *industry_id1_;
}
inline void SetIndustryReq::set_industry_id1(const ::std::string& value) {
  set_has_industry_id1();
  if (industry_id1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id1_ = new ::std::string;
  }
  industry_id1_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SetIndustryReq.industry_id1)
}
inline void SetIndustryReq::set_industry_id1(const char* value) {
  set_has_industry_id1();
  if (industry_id1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id1_ = new ::std::string;
  }
  industry_id1_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SetIndustryReq.industry_id1)
}
inline void SetIndustryReq::set_industry_id1(const char* value, size_t size) {
  set_has_industry_id1();
  if (industry_id1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id1_ = new ::std::string;
  }
  industry_id1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SetIndustryReq.industry_id1)
}
inline ::std::string* SetIndustryReq::mutable_industry_id1() {
  set_has_industry_id1();
  if (industry_id1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SetIndustryReq.industry_id1)
  return industry_id1_;
}
inline ::std::string* SetIndustryReq::release_industry_id1() {
  clear_has_industry_id1();
  if (industry_id1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = industry_id1_;
    industry_id1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetIndustryReq::set_allocated_industry_id1(::std::string* industry_id1) {
  if (industry_id1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete industry_id1_;
  }
  if (industry_id1) {
    set_has_industry_id1();
    industry_id1_ = industry_id1;
  } else {
    clear_has_industry_id1();
    industry_id1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SetIndustryReq.industry_id1)
}

// optional string industry_id2 = 3;
inline bool SetIndustryReq::has_industry_id2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetIndustryReq::set_has_industry_id2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetIndustryReq::clear_has_industry_id2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetIndustryReq::clear_industry_id2() {
  if (industry_id2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id2_->clear();
  }
  clear_has_industry_id2();
}
inline const ::std::string& SetIndustryReq::industry_id2() const {
  // @@protoc_insertion_point(field_get:mpcomm.SetIndustryReq.industry_id2)
  return *industry_id2_;
}
inline void SetIndustryReq::set_industry_id2(const ::std::string& value) {
  set_has_industry_id2();
  if (industry_id2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id2_ = new ::std::string;
  }
  industry_id2_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SetIndustryReq.industry_id2)
}
inline void SetIndustryReq::set_industry_id2(const char* value) {
  set_has_industry_id2();
  if (industry_id2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id2_ = new ::std::string;
  }
  industry_id2_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SetIndustryReq.industry_id2)
}
inline void SetIndustryReq::set_industry_id2(const char* value, size_t size) {
  set_has_industry_id2();
  if (industry_id2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id2_ = new ::std::string;
  }
  industry_id2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SetIndustryReq.industry_id2)
}
inline ::std::string* SetIndustryReq::mutable_industry_id2() {
  set_has_industry_id2();
  if (industry_id2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    industry_id2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SetIndustryReq.industry_id2)
  return industry_id2_;
}
inline ::std::string* SetIndustryReq::release_industry_id2() {
  clear_has_industry_id2();
  if (industry_id2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = industry_id2_;
    industry_id2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetIndustryReq::set_allocated_industry_id2(::std::string* industry_id2) {
  if (industry_id2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete industry_id2_;
  }
  if (industry_id2) {
    set_has_industry_id2();
    industry_id2_ = industry_id2;
  } else {
    clear_has_industry_id2();
    industry_id2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SetIndustryReq.industry_id2)
}

// -------------------------------------------------------------------

// SetIndustryResp

// optional int64 errcode = 1;
inline bool SetIndustryResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetIndustryResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetIndustryResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetIndustryResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 SetIndustryResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.SetIndustryResp.errcode)
  return errcode_;
}
inline void SetIndustryResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.SetIndustryResp.errcode)
}

// optional string errmsg = 2;
inline bool SetIndustryResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetIndustryResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetIndustryResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetIndustryResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& SetIndustryResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.SetIndustryResp.errmsg)
  return *errmsg_;
}
inline void SetIndustryResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SetIndustryResp.errmsg)
}
inline void SetIndustryResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SetIndustryResp.errmsg)
}
inline void SetIndustryResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SetIndustryResp.errmsg)
}
inline ::std::string* SetIndustryResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SetIndustryResp.errmsg)
  return errmsg_;
}
inline ::std::string* SetIndustryResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetIndustryResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SetIndustryResp.errmsg)
}

// -------------------------------------------------------------------

// GetIndustryReq

// optional string access_token = 1;
inline bool GetIndustryReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetIndustryReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetIndustryReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetIndustryReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetIndustryReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetIndustryReq.access_token)
  return *access_token_;
}
inline void GetIndustryReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetIndustryReq.access_token)
}
inline void GetIndustryReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetIndustryReq.access_token)
}
inline void GetIndustryReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetIndustryReq.access_token)
}
inline ::std::string* GetIndustryReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetIndustryReq.access_token)
  return access_token_;
}
inline ::std::string* GetIndustryReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetIndustryReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetIndustryReq.access_token)
}

// -------------------------------------------------------------------

// Industry

// optional string first_class = 1;
inline bool Industry::has_first_class() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Industry::set_has_first_class() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Industry::clear_has_first_class() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Industry::clear_first_class() {
  if (first_class_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_class_->clear();
  }
  clear_has_first_class();
}
inline const ::std::string& Industry::first_class() const {
  // @@protoc_insertion_point(field_get:mpcomm.Industry.first_class)
  return *first_class_;
}
inline void Industry::set_first_class(const ::std::string& value) {
  set_has_first_class();
  if (first_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_class_ = new ::std::string;
  }
  first_class_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Industry.first_class)
}
inline void Industry::set_first_class(const char* value) {
  set_has_first_class();
  if (first_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_class_ = new ::std::string;
  }
  first_class_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Industry.first_class)
}
inline void Industry::set_first_class(const char* value, size_t size) {
  set_has_first_class();
  if (first_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_class_ = new ::std::string;
  }
  first_class_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Industry.first_class)
}
inline ::std::string* Industry::mutable_first_class() {
  set_has_first_class();
  if (first_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    first_class_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Industry.first_class)
  return first_class_;
}
inline ::std::string* Industry::release_first_class() {
  clear_has_first_class();
  if (first_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = first_class_;
    first_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Industry::set_allocated_first_class(::std::string* first_class) {
  if (first_class_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete first_class_;
  }
  if (first_class) {
    set_has_first_class();
    first_class_ = first_class;
  } else {
    clear_has_first_class();
    first_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Industry.first_class)
}

// optional string second_class = 2;
inline bool Industry::has_second_class() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Industry::set_has_second_class() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Industry::clear_has_second_class() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Industry::clear_second_class() {
  if (second_class_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    second_class_->clear();
  }
  clear_has_second_class();
}
inline const ::std::string& Industry::second_class() const {
  // @@protoc_insertion_point(field_get:mpcomm.Industry.second_class)
  return *second_class_;
}
inline void Industry::set_second_class(const ::std::string& value) {
  set_has_second_class();
  if (second_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    second_class_ = new ::std::string;
  }
  second_class_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Industry.second_class)
}
inline void Industry::set_second_class(const char* value) {
  set_has_second_class();
  if (second_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    second_class_ = new ::std::string;
  }
  second_class_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Industry.second_class)
}
inline void Industry::set_second_class(const char* value, size_t size) {
  set_has_second_class();
  if (second_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    second_class_ = new ::std::string;
  }
  second_class_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Industry.second_class)
}
inline ::std::string* Industry::mutable_second_class() {
  set_has_second_class();
  if (second_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    second_class_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Industry.second_class)
  return second_class_;
}
inline ::std::string* Industry::release_second_class() {
  clear_has_second_class();
  if (second_class_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = second_class_;
    second_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Industry::set_allocated_second_class(::std::string* second_class) {
  if (second_class_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete second_class_;
  }
  if (second_class) {
    set_has_second_class();
    second_class_ = second_class;
  } else {
    clear_has_second_class();
    second_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Industry.second_class)
}

// -------------------------------------------------------------------

// GetIndustryResp

// optional int64 errcode = 1;
inline bool GetIndustryResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetIndustryResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetIndustryResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetIndustryResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetIndustryResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetIndustryResp.errcode)
  return errcode_;
}
inline void GetIndustryResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetIndustryResp.errcode)
}

// optional string errmsg = 2;
inline bool GetIndustryResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetIndustryResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetIndustryResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetIndustryResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetIndustryResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetIndustryResp.errmsg)
  return *errmsg_;
}
inline void GetIndustryResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetIndustryResp.errmsg)
}
inline void GetIndustryResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetIndustryResp.errmsg)
}
inline void GetIndustryResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetIndustryResp.errmsg)
}
inline ::std::string* GetIndustryResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetIndustryResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetIndustryResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetIndustryResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetIndustryResp.errmsg)
}

// optional .mpcomm.Industry primary_industry = 3;
inline bool GetIndustryResp::has_primary_industry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetIndustryResp::set_has_primary_industry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetIndustryResp::clear_has_primary_industry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetIndustryResp::clear_primary_industry() {
  if (primary_industry_ != NULL) primary_industry_->::mpcomm::Industry::Clear();
  clear_has_primary_industry();
}
inline const ::mpcomm::Industry& GetIndustryResp::primary_industry() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetIndustryResp.primary_industry)
  return primary_industry_ != NULL ? *primary_industry_ : *default_instance_->primary_industry_;
}
inline ::mpcomm::Industry* GetIndustryResp::mutable_primary_industry() {
  set_has_primary_industry();
  if (primary_industry_ == NULL) primary_industry_ = new ::mpcomm::Industry;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetIndustryResp.primary_industry)
  return primary_industry_;
}
inline ::mpcomm::Industry* GetIndustryResp::release_primary_industry() {
  clear_has_primary_industry();
  ::mpcomm::Industry* temp = primary_industry_;
  primary_industry_ = NULL;
  return temp;
}
inline void GetIndustryResp::set_allocated_primary_industry(::mpcomm::Industry* primary_industry) {
  delete primary_industry_;
  primary_industry_ = primary_industry;
  if (primary_industry) {
    set_has_primary_industry();
  } else {
    clear_has_primary_industry();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetIndustryResp.primary_industry)
}

// optional .mpcomm.Industry secondary_industry = 4;
inline bool GetIndustryResp::has_secondary_industry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetIndustryResp::set_has_secondary_industry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetIndustryResp::clear_has_secondary_industry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetIndustryResp::clear_secondary_industry() {
  if (secondary_industry_ != NULL) secondary_industry_->::mpcomm::Industry::Clear();
  clear_has_secondary_industry();
}
inline const ::mpcomm::Industry& GetIndustryResp::secondary_industry() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetIndustryResp.secondary_industry)
  return secondary_industry_ != NULL ? *secondary_industry_ : *default_instance_->secondary_industry_;
}
inline ::mpcomm::Industry* GetIndustryResp::mutable_secondary_industry() {
  set_has_secondary_industry();
  if (secondary_industry_ == NULL) secondary_industry_ = new ::mpcomm::Industry;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetIndustryResp.secondary_industry)
  return secondary_industry_;
}
inline ::mpcomm::Industry* GetIndustryResp::release_secondary_industry() {
  clear_has_secondary_industry();
  ::mpcomm::Industry* temp = secondary_industry_;
  secondary_industry_ = NULL;
  return temp;
}
inline void GetIndustryResp::set_allocated_secondary_industry(::mpcomm::Industry* secondary_industry) {
  delete secondary_industry_;
  secondary_industry_ = secondary_industry;
  if (secondary_industry) {
    set_has_secondary_industry();
  } else {
    clear_has_secondary_industry();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetIndustryResp.secondary_industry)
}

// -------------------------------------------------------------------

// AddTemplateReq

// optional string access_token = 1;
inline bool AddTemplateReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddTemplateReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddTemplateReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddTemplateReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& AddTemplateReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddTemplateReq.access_token)
  return *access_token_;
}
inline void AddTemplateReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddTemplateReq.access_token)
}
inline void AddTemplateReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddTemplateReq.access_token)
}
inline void AddTemplateReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddTemplateReq.access_token)
}
inline ::std::string* AddTemplateReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddTemplateReq.access_token)
  return access_token_;
}
inline ::std::string* AddTemplateReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddTemplateReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddTemplateReq.access_token)
}

// optional string template_id_short = 2;
inline bool AddTemplateReq::has_template_id_short() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddTemplateReq::set_has_template_id_short() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddTemplateReq::clear_has_template_id_short() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddTemplateReq::clear_template_id_short() {
  if (template_id_short_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_short_->clear();
  }
  clear_has_template_id_short();
}
inline const ::std::string& AddTemplateReq::template_id_short() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddTemplateReq.template_id_short)
  return *template_id_short_;
}
inline void AddTemplateReq::set_template_id_short(const ::std::string& value) {
  set_has_template_id_short();
  if (template_id_short_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_short_ = new ::std::string;
  }
  template_id_short_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddTemplateReq.template_id_short)
}
inline void AddTemplateReq::set_template_id_short(const char* value) {
  set_has_template_id_short();
  if (template_id_short_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_short_ = new ::std::string;
  }
  template_id_short_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddTemplateReq.template_id_short)
}
inline void AddTemplateReq::set_template_id_short(const char* value, size_t size) {
  set_has_template_id_short();
  if (template_id_short_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_short_ = new ::std::string;
  }
  template_id_short_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddTemplateReq.template_id_short)
}
inline ::std::string* AddTemplateReq::mutable_template_id_short() {
  set_has_template_id_short();
  if (template_id_short_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_short_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddTemplateReq.template_id_short)
  return template_id_short_;
}
inline ::std::string* AddTemplateReq::release_template_id_short() {
  clear_has_template_id_short();
  if (template_id_short_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = template_id_short_;
    template_id_short_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddTemplateReq::set_allocated_template_id_short(::std::string* template_id_short) {
  if (template_id_short_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete template_id_short_;
  }
  if (template_id_short) {
    set_has_template_id_short();
    template_id_short_ = template_id_short;
  } else {
    clear_has_template_id_short();
    template_id_short_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddTemplateReq.template_id_short)
}

// -------------------------------------------------------------------

// AddTemplateResp

// optional int64 errcode = 1;
inline bool AddTemplateResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddTemplateResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddTemplateResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddTemplateResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 AddTemplateResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddTemplateResp.errcode)
  return errcode_;
}
inline void AddTemplateResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.AddTemplateResp.errcode)
}

// optional string errmsg = 2;
inline bool AddTemplateResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddTemplateResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddTemplateResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddTemplateResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& AddTemplateResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddTemplateResp.errmsg)
  return *errmsg_;
}
inline void AddTemplateResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddTemplateResp.errmsg)
}
inline void AddTemplateResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddTemplateResp.errmsg)
}
inline void AddTemplateResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddTemplateResp.errmsg)
}
inline ::std::string* AddTemplateResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddTemplateResp.errmsg)
  return errmsg_;
}
inline ::std::string* AddTemplateResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddTemplateResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddTemplateResp.errmsg)
}

// optional string template_id = 3;
inline bool AddTemplateResp::has_template_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddTemplateResp::set_has_template_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddTemplateResp::clear_has_template_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddTemplateResp::clear_template_id() {
  if (template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_->clear();
  }
  clear_has_template_id();
}
inline const ::std::string& AddTemplateResp::template_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddTemplateResp.template_id)
  return *template_id_;
}
inline void AddTemplateResp::set_template_id(const ::std::string& value) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddTemplateResp.template_id)
}
inline void AddTemplateResp::set_template_id(const char* value) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddTemplateResp.template_id)
}
inline void AddTemplateResp::set_template_id(const char* value, size_t size) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddTemplateResp.template_id)
}
inline ::std::string* AddTemplateResp::mutable_template_id() {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddTemplateResp.template_id)
  return template_id_;
}
inline ::std::string* AddTemplateResp::release_template_id() {
  clear_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = template_id_;
    template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddTemplateResp::set_allocated_template_id(::std::string* template_id) {
  if (template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete template_id_;
  }
  if (template_id) {
    set_has_template_id();
    template_id_ = template_id;
  } else {
    clear_has_template_id();
    template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddTemplateResp.template_id)
}

// -------------------------------------------------------------------

// GetAllPrivateTemplateReq

// optional string access_token = 1;
inline bool GetAllPrivateTemplateReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAllPrivateTemplateReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAllPrivateTemplateReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAllPrivateTemplateReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetAllPrivateTemplateReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetAllPrivateTemplateReq.access_token)
  return *access_token_;
}
inline void GetAllPrivateTemplateReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetAllPrivateTemplateReq.access_token)
}
inline void GetAllPrivateTemplateReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetAllPrivateTemplateReq.access_token)
}
inline void GetAllPrivateTemplateReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetAllPrivateTemplateReq.access_token)
}
inline ::std::string* GetAllPrivateTemplateReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetAllPrivateTemplateReq.access_token)
  return access_token_;
}
inline ::std::string* GetAllPrivateTemplateReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAllPrivateTemplateReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetAllPrivateTemplateReq.access_token)
}

// -------------------------------------------------------------------

// PrivateTemplate

// optional string template_id = 1;
inline bool PrivateTemplate::has_template_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrivateTemplate::set_has_template_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrivateTemplate::clear_has_template_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrivateTemplate::clear_template_id() {
  if (template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_->clear();
  }
  clear_has_template_id();
}
inline const ::std::string& PrivateTemplate::template_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.PrivateTemplate.template_id)
  return *template_id_;
}
inline void PrivateTemplate::set_template_id(const ::std::string& value) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.PrivateTemplate.template_id)
}
inline void PrivateTemplate::set_template_id(const char* value) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.PrivateTemplate.template_id)
}
inline void PrivateTemplate::set_template_id(const char* value, size_t size) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.PrivateTemplate.template_id)
}
inline ::std::string* PrivateTemplate::mutable_template_id() {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.PrivateTemplate.template_id)
  return template_id_;
}
inline ::std::string* PrivateTemplate::release_template_id() {
  clear_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = template_id_;
    template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrivateTemplate::set_allocated_template_id(::std::string* template_id) {
  if (template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete template_id_;
  }
  if (template_id) {
    set_has_template_id();
    template_id_ = template_id;
  } else {
    clear_has_template_id();
    template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.PrivateTemplate.template_id)
}

// optional string title = 2;
inline bool PrivateTemplate::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrivateTemplate::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrivateTemplate::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrivateTemplate::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& PrivateTemplate::title() const {
  // @@protoc_insertion_point(field_get:mpcomm.PrivateTemplate.title)
  return *title_;
}
inline void PrivateTemplate::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.PrivateTemplate.title)
}
inline void PrivateTemplate::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.PrivateTemplate.title)
}
inline void PrivateTemplate::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.PrivateTemplate.title)
}
inline ::std::string* PrivateTemplate::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.PrivateTemplate.title)
  return title_;
}
inline ::std::string* PrivateTemplate::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrivateTemplate::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.PrivateTemplate.title)
}

// optional string primary_industry = 3;
inline bool PrivateTemplate::has_primary_industry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrivateTemplate::set_has_primary_industry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrivateTemplate::clear_has_primary_industry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrivateTemplate::clear_primary_industry() {
  if (primary_industry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_industry_->clear();
  }
  clear_has_primary_industry();
}
inline const ::std::string& PrivateTemplate::primary_industry() const {
  // @@protoc_insertion_point(field_get:mpcomm.PrivateTemplate.primary_industry)
  return *primary_industry_;
}
inline void PrivateTemplate::set_primary_industry(const ::std::string& value) {
  set_has_primary_industry();
  if (primary_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_industry_ = new ::std::string;
  }
  primary_industry_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.PrivateTemplate.primary_industry)
}
inline void PrivateTemplate::set_primary_industry(const char* value) {
  set_has_primary_industry();
  if (primary_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_industry_ = new ::std::string;
  }
  primary_industry_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.PrivateTemplate.primary_industry)
}
inline void PrivateTemplate::set_primary_industry(const char* value, size_t size) {
  set_has_primary_industry();
  if (primary_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_industry_ = new ::std::string;
  }
  primary_industry_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.PrivateTemplate.primary_industry)
}
inline ::std::string* PrivateTemplate::mutable_primary_industry() {
  set_has_primary_industry();
  if (primary_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_industry_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.PrivateTemplate.primary_industry)
  return primary_industry_;
}
inline ::std::string* PrivateTemplate::release_primary_industry() {
  clear_has_primary_industry();
  if (primary_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = primary_industry_;
    primary_industry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrivateTemplate::set_allocated_primary_industry(::std::string* primary_industry) {
  if (primary_industry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete primary_industry_;
  }
  if (primary_industry) {
    set_has_primary_industry();
    primary_industry_ = primary_industry;
  } else {
    clear_has_primary_industry();
    primary_industry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.PrivateTemplate.primary_industry)
}

// optional string deputy_industry = 4;
inline bool PrivateTemplate::has_deputy_industry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrivateTemplate::set_has_deputy_industry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrivateTemplate::clear_has_deputy_industry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrivateTemplate::clear_deputy_industry() {
  if (deputy_industry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deputy_industry_->clear();
  }
  clear_has_deputy_industry();
}
inline const ::std::string& PrivateTemplate::deputy_industry() const {
  // @@protoc_insertion_point(field_get:mpcomm.PrivateTemplate.deputy_industry)
  return *deputy_industry_;
}
inline void PrivateTemplate::set_deputy_industry(const ::std::string& value) {
  set_has_deputy_industry();
  if (deputy_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deputy_industry_ = new ::std::string;
  }
  deputy_industry_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.PrivateTemplate.deputy_industry)
}
inline void PrivateTemplate::set_deputy_industry(const char* value) {
  set_has_deputy_industry();
  if (deputy_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deputy_industry_ = new ::std::string;
  }
  deputy_industry_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.PrivateTemplate.deputy_industry)
}
inline void PrivateTemplate::set_deputy_industry(const char* value, size_t size) {
  set_has_deputy_industry();
  if (deputy_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deputy_industry_ = new ::std::string;
  }
  deputy_industry_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.PrivateTemplate.deputy_industry)
}
inline ::std::string* PrivateTemplate::mutable_deputy_industry() {
  set_has_deputy_industry();
  if (deputy_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deputy_industry_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.PrivateTemplate.deputy_industry)
  return deputy_industry_;
}
inline ::std::string* PrivateTemplate::release_deputy_industry() {
  clear_has_deputy_industry();
  if (deputy_industry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deputy_industry_;
    deputy_industry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrivateTemplate::set_allocated_deputy_industry(::std::string* deputy_industry) {
  if (deputy_industry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deputy_industry_;
  }
  if (deputy_industry) {
    set_has_deputy_industry();
    deputy_industry_ = deputy_industry;
  } else {
    clear_has_deputy_industry();
    deputy_industry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.PrivateTemplate.deputy_industry)
}

// optional string content = 5;
inline bool PrivateTemplate::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrivateTemplate::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrivateTemplate::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrivateTemplate::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& PrivateTemplate::content() const {
  // @@protoc_insertion_point(field_get:mpcomm.PrivateTemplate.content)
  return *content_;
}
inline void PrivateTemplate::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.PrivateTemplate.content)
}
inline void PrivateTemplate::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.PrivateTemplate.content)
}
inline void PrivateTemplate::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.PrivateTemplate.content)
}
inline ::std::string* PrivateTemplate::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.PrivateTemplate.content)
  return content_;
}
inline ::std::string* PrivateTemplate::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrivateTemplate::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.PrivateTemplate.content)
}

// optional string example = 6;
inline bool PrivateTemplate::has_example() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PrivateTemplate::set_has_example() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PrivateTemplate::clear_has_example() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PrivateTemplate::clear_example() {
  if (example_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    example_->clear();
  }
  clear_has_example();
}
inline const ::std::string& PrivateTemplate::example() const {
  // @@protoc_insertion_point(field_get:mpcomm.PrivateTemplate.example)
  return *example_;
}
inline void PrivateTemplate::set_example(const ::std::string& value) {
  set_has_example();
  if (example_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    example_ = new ::std::string;
  }
  example_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.PrivateTemplate.example)
}
inline void PrivateTemplate::set_example(const char* value) {
  set_has_example();
  if (example_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    example_ = new ::std::string;
  }
  example_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.PrivateTemplate.example)
}
inline void PrivateTemplate::set_example(const char* value, size_t size) {
  set_has_example();
  if (example_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    example_ = new ::std::string;
  }
  example_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.PrivateTemplate.example)
}
inline ::std::string* PrivateTemplate::mutable_example() {
  set_has_example();
  if (example_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    example_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.PrivateTemplate.example)
  return example_;
}
inline ::std::string* PrivateTemplate::release_example() {
  clear_has_example();
  if (example_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = example_;
    example_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PrivateTemplate::set_allocated_example(::std::string* example) {
  if (example_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete example_;
  }
  if (example) {
    set_has_example();
    example_ = example;
  } else {
    clear_has_example();
    example_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.PrivateTemplate.example)
}

// -------------------------------------------------------------------

// GetAllPrivateTemplateResp

// optional int64 errcode = 1;
inline bool GetAllPrivateTemplateResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAllPrivateTemplateResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAllPrivateTemplateResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAllPrivateTemplateResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetAllPrivateTemplateResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetAllPrivateTemplateResp.errcode)
  return errcode_;
}
inline void GetAllPrivateTemplateResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetAllPrivateTemplateResp.errcode)
}

// optional string errmsg = 2;
inline bool GetAllPrivateTemplateResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAllPrivateTemplateResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAllPrivateTemplateResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAllPrivateTemplateResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetAllPrivateTemplateResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetAllPrivateTemplateResp.errmsg)
  return *errmsg_;
}
inline void GetAllPrivateTemplateResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetAllPrivateTemplateResp.errmsg)
}
inline void GetAllPrivateTemplateResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetAllPrivateTemplateResp.errmsg)
}
inline void GetAllPrivateTemplateResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetAllPrivateTemplateResp.errmsg)
}
inline ::std::string* GetAllPrivateTemplateResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetAllPrivateTemplateResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetAllPrivateTemplateResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetAllPrivateTemplateResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetAllPrivateTemplateResp.errmsg)
}

// repeated .mpcomm.PrivateTemplate template_list = 3;
inline int GetAllPrivateTemplateResp::template_list_size() const {
  return template_list_.size();
}
inline void GetAllPrivateTemplateResp::clear_template_list() {
  template_list_.Clear();
}
inline const ::mpcomm::PrivateTemplate& GetAllPrivateTemplateResp::template_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.GetAllPrivateTemplateResp.template_list)
  return template_list_.Get(index);
}
inline ::mpcomm::PrivateTemplate* GetAllPrivateTemplateResp::mutable_template_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.GetAllPrivateTemplateResp.template_list)
  return template_list_.Mutable(index);
}
inline ::mpcomm::PrivateTemplate* GetAllPrivateTemplateResp::add_template_list() {
  // @@protoc_insertion_point(field_add:mpcomm.GetAllPrivateTemplateResp.template_list)
  return template_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::PrivateTemplate >&
GetAllPrivateTemplateResp::template_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.GetAllPrivateTemplateResp.template_list)
  return template_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::PrivateTemplate >*
GetAllPrivateTemplateResp::mutable_template_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.GetAllPrivateTemplateResp.template_list)
  return &template_list_;
}

// -------------------------------------------------------------------

// DelPrivateTemplateReq

// optional string access_token = 1;
inline bool DelPrivateTemplateReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelPrivateTemplateReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelPrivateTemplateReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelPrivateTemplateReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& DelPrivateTemplateReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelPrivateTemplateReq.access_token)
  return *access_token_;
}
inline void DelPrivateTemplateReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DelPrivateTemplateReq.access_token)
}
inline void DelPrivateTemplateReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DelPrivateTemplateReq.access_token)
}
inline void DelPrivateTemplateReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DelPrivateTemplateReq.access_token)
}
inline ::std::string* DelPrivateTemplateReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DelPrivateTemplateReq.access_token)
  return access_token_;
}
inline ::std::string* DelPrivateTemplateReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DelPrivateTemplateReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DelPrivateTemplateReq.access_token)
}

// optional string template_id = 2;
inline bool DelPrivateTemplateReq::has_template_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelPrivateTemplateReq::set_has_template_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelPrivateTemplateReq::clear_has_template_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelPrivateTemplateReq::clear_template_id() {
  if (template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_->clear();
  }
  clear_has_template_id();
}
inline const ::std::string& DelPrivateTemplateReq::template_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelPrivateTemplateReq.template_id)
  return *template_id_;
}
inline void DelPrivateTemplateReq::set_template_id(const ::std::string& value) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DelPrivateTemplateReq.template_id)
}
inline void DelPrivateTemplateReq::set_template_id(const char* value) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DelPrivateTemplateReq.template_id)
}
inline void DelPrivateTemplateReq::set_template_id(const char* value, size_t size) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DelPrivateTemplateReq.template_id)
}
inline ::std::string* DelPrivateTemplateReq::mutable_template_id() {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DelPrivateTemplateReq.template_id)
  return template_id_;
}
inline ::std::string* DelPrivateTemplateReq::release_template_id() {
  clear_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = template_id_;
    template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DelPrivateTemplateReq::set_allocated_template_id(::std::string* template_id) {
  if (template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete template_id_;
  }
  if (template_id) {
    set_has_template_id();
    template_id_ = template_id;
  } else {
    clear_has_template_id();
    template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DelPrivateTemplateReq.template_id)
}

// -------------------------------------------------------------------

// DelPrivateTemplateResp

// optional int64 errcode = 1;
inline bool DelPrivateTemplateResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelPrivateTemplateResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelPrivateTemplateResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelPrivateTemplateResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 DelPrivateTemplateResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelPrivateTemplateResp.errcode)
  return errcode_;
}
inline void DelPrivateTemplateResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.DelPrivateTemplateResp.errcode)
}

// optional string errmsg = 2;
inline bool DelPrivateTemplateResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelPrivateTemplateResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelPrivateTemplateResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelPrivateTemplateResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& DelPrivateTemplateResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelPrivateTemplateResp.errmsg)
  return *errmsg_;
}
inline void DelPrivateTemplateResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DelPrivateTemplateResp.errmsg)
}
inline void DelPrivateTemplateResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DelPrivateTemplateResp.errmsg)
}
inline void DelPrivateTemplateResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DelPrivateTemplateResp.errmsg)
}
inline ::std::string* DelPrivateTemplateResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DelPrivateTemplateResp.errmsg)
  return errmsg_;
}
inline ::std::string* DelPrivateTemplateResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DelPrivateTemplateResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DelPrivateTemplateResp.errmsg)
}

// -------------------------------------------------------------------

// Json

// optional string content = 1;
inline bool Json::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Json::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Json::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Json::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Json::content() const {
  // @@protoc_insertion_point(field_get:mpcomm.Json.content)
  return *content_;
}
inline void Json::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Json.content)
}
inline void Json::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Json.content)
}
inline void Json::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Json.content)
}
inline ::std::string* Json::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Json.content)
  return content_;
}
inline ::std::string* Json::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Json::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Json.content)
}

// -------------------------------------------------------------------

// SendTemplateMessageReq

// optional string access_token = 1;
inline bool SendTemplateMessageReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendTemplateMessageReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendTemplateMessageReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendTemplateMessageReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& SendTemplateMessageReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendTemplateMessageReq.access_token)
  return *access_token_;
}
inline void SendTemplateMessageReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SendTemplateMessageReq.access_token)
}
inline void SendTemplateMessageReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SendTemplateMessageReq.access_token)
}
inline void SendTemplateMessageReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SendTemplateMessageReq.access_token)
}
inline ::std::string* SendTemplateMessageReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SendTemplateMessageReq.access_token)
  return access_token_;
}
inline ::std::string* SendTemplateMessageReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendTemplateMessageReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendTemplateMessageReq.access_token)
}

// optional string touser = 2;
inline bool SendTemplateMessageReq::has_touser() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendTemplateMessageReq::set_has_touser() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendTemplateMessageReq::clear_has_touser() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendTemplateMessageReq::clear_touser() {
  if (touser_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_->clear();
  }
  clear_has_touser();
}
inline const ::std::string& SendTemplateMessageReq::touser() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendTemplateMessageReq.touser)
  return *touser_;
}
inline void SendTemplateMessageReq::set_touser(const ::std::string& value) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  touser_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SendTemplateMessageReq.touser)
}
inline void SendTemplateMessageReq::set_touser(const char* value) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  touser_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SendTemplateMessageReq.touser)
}
inline void SendTemplateMessageReq::set_touser(const char* value, size_t size) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  touser_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SendTemplateMessageReq.touser)
}
inline ::std::string* SendTemplateMessageReq::mutable_touser() {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    touser_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SendTemplateMessageReq.touser)
  return touser_;
}
inline ::std::string* SendTemplateMessageReq::release_touser() {
  clear_has_touser();
  if (touser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = touser_;
    touser_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendTemplateMessageReq::set_allocated_touser(::std::string* touser) {
  if (touser_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete touser_;
  }
  if (touser) {
    set_has_touser();
    touser_ = touser;
  } else {
    clear_has_touser();
    touser_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendTemplateMessageReq.touser)
}

// optional string template_id = 3;
inline bool SendTemplateMessageReq::has_template_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendTemplateMessageReq::set_has_template_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendTemplateMessageReq::clear_has_template_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendTemplateMessageReq::clear_template_id() {
  if (template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_->clear();
  }
  clear_has_template_id();
}
inline const ::std::string& SendTemplateMessageReq::template_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendTemplateMessageReq.template_id)
  return *template_id_;
}
inline void SendTemplateMessageReq::set_template_id(const ::std::string& value) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SendTemplateMessageReq.template_id)
}
inline void SendTemplateMessageReq::set_template_id(const char* value) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SendTemplateMessageReq.template_id)
}
inline void SendTemplateMessageReq::set_template_id(const char* value, size_t size) {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  template_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SendTemplateMessageReq.template_id)
}
inline ::std::string* SendTemplateMessageReq::mutable_template_id() {
  set_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    template_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SendTemplateMessageReq.template_id)
  return template_id_;
}
inline ::std::string* SendTemplateMessageReq::release_template_id() {
  clear_has_template_id();
  if (template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = template_id_;
    template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendTemplateMessageReq::set_allocated_template_id(::std::string* template_id) {
  if (template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete template_id_;
  }
  if (template_id) {
    set_has_template_id();
    template_id_ = template_id;
  } else {
    clear_has_template_id();
    template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendTemplateMessageReq.template_id)
}

// optional string url = 4;
inline bool SendTemplateMessageReq::has_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendTemplateMessageReq::set_has_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendTemplateMessageReq::clear_has_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendTemplateMessageReq::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& SendTemplateMessageReq::url() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendTemplateMessageReq.url)
  return *url_;
}
inline void SendTemplateMessageReq::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SendTemplateMessageReq.url)
}
inline void SendTemplateMessageReq::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SendTemplateMessageReq.url)
}
inline void SendTemplateMessageReq::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SendTemplateMessageReq.url)
}
inline ::std::string* SendTemplateMessageReq::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SendTemplateMessageReq.url)
  return url_;
}
inline ::std::string* SendTemplateMessageReq::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendTemplateMessageReq::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendTemplateMessageReq.url)
}

// optional .mpcomm.Json data = 5;
inline bool SendTemplateMessageReq::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendTemplateMessageReq::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendTemplateMessageReq::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendTemplateMessageReq::clear_data() {
  if (data_ != NULL) data_->::mpcomm::Json::Clear();
  clear_has_data();
}
inline const ::mpcomm::Json& SendTemplateMessageReq::data() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendTemplateMessageReq.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::mpcomm::Json* SendTemplateMessageReq::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::mpcomm::Json;
  // @@protoc_insertion_point(field_mutable:mpcomm.SendTemplateMessageReq.data)
  return data_;
}
inline ::mpcomm::Json* SendTemplateMessageReq::release_data() {
  clear_has_data();
  ::mpcomm::Json* temp = data_;
  data_ = NULL;
  return temp;
}
inline void SendTemplateMessageReq::set_allocated_data(::mpcomm::Json* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendTemplateMessageReq.data)
}

// -------------------------------------------------------------------

// SendTemplateMessageResp

// optional int64 errcode = 1;
inline bool SendTemplateMessageResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendTemplateMessageResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendTemplateMessageResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendTemplateMessageResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 SendTemplateMessageResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendTemplateMessageResp.errcode)
  return errcode_;
}
inline void SendTemplateMessageResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.SendTemplateMessageResp.errcode)
}

// optional string errmsg = 2;
inline bool SendTemplateMessageResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendTemplateMessageResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendTemplateMessageResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendTemplateMessageResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& SendTemplateMessageResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendTemplateMessageResp.errmsg)
  return *errmsg_;
}
inline void SendTemplateMessageResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.SendTemplateMessageResp.errmsg)
}
inline void SendTemplateMessageResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.SendTemplateMessageResp.errmsg)
}
inline void SendTemplateMessageResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.SendTemplateMessageResp.errmsg)
}
inline ::std::string* SendTemplateMessageResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.SendTemplateMessageResp.errmsg)
  return errmsg_;
}
inline ::std::string* SendTemplateMessageResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendTemplateMessageResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.SendTemplateMessageResp.errmsg)
}

// optional uint64 msgid = 3;
inline bool SendTemplateMessageResp::has_msgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendTemplateMessageResp::set_has_msgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendTemplateMessageResp::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendTemplateMessageResp::clear_msgid() {
  msgid_ = GOOGLE_ULONGLONG(0);
  clear_has_msgid();
}
inline ::google::protobuf::uint64 SendTemplateMessageResp::msgid() const {
  // @@protoc_insertion_point(field_get:mpcomm.SendTemplateMessageResp.msgid)
  return msgid_;
}
inline void SendTemplateMessageResp::set_msgid(::google::protobuf::uint64 value) {
  set_has_msgid();
  msgid_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.SendTemplateMessageResp.msgid)
}

// -------------------------------------------------------------------

// MediaFile

// optional string file_name = 1;
inline bool MediaFile::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MediaFile::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MediaFile::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MediaFile::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& MediaFile::file_name() const {
  // @@protoc_insertion_point(field_get:mpcomm.MediaFile.file_name)
  return *file_name_;
}
inline void MediaFile::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MediaFile.file_name)
}
inline void MediaFile::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MediaFile.file_name)
}
inline void MediaFile::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MediaFile.file_name)
}
inline ::std::string* MediaFile::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MediaFile.file_name)
  return file_name_;
}
inline ::std::string* MediaFile::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MediaFile::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MediaFile.file_name)
}

// optional string buffer = 2;
inline bool MediaFile::has_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MediaFile::set_has_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MediaFile::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MediaFile::clear_buffer() {
  if (buffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffer_->clear();
  }
  clear_has_buffer();
}
inline const ::std::string& MediaFile::buffer() const {
  // @@protoc_insertion_point(field_get:mpcomm.MediaFile.buffer)
  return *buffer_;
}
inline void MediaFile::set_buffer(const ::std::string& value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MediaFile.buffer)
}
inline void MediaFile::set_buffer(const char* value) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MediaFile.buffer)
}
inline void MediaFile::set_buffer(const char* value, size_t size) {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MediaFile.buffer)
}
inline ::std::string* MediaFile::mutable_buffer() {
  set_has_buffer();
  if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    buffer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MediaFile.buffer)
  return buffer_;
}
inline ::std::string* MediaFile::release_buffer() {
  clear_has_buffer();
  if (buffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = buffer_;
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MediaFile::set_allocated_buffer(::std::string* buffer) {
  if (buffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete buffer_;
  }
  if (buffer) {
    set_has_buffer();
    buffer_ = buffer;
  } else {
    clear_has_buffer();
    buffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MediaFile.buffer)
}

// -------------------------------------------------------------------

// NewsItem

// optional string title = 1;
inline bool NewsItem::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewsItem::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewsItem::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewsItem::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& NewsItem::title() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsItem.title)
  return *title_;
}
inline void NewsItem::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.NewsItem.title)
}
inline void NewsItem::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.NewsItem.title)
}
inline void NewsItem::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.NewsItem.title)
}
inline ::std::string* NewsItem::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsItem.title)
  return title_;
}
inline ::std::string* NewsItem::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewsItem::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.NewsItem.title)
}

// optional string author = 2;
inline bool NewsItem::has_author() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewsItem::set_has_author() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewsItem::clear_has_author() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewsItem::clear_author() {
  if (author_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_->clear();
  }
  clear_has_author();
}
inline const ::std::string& NewsItem::author() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsItem.author)
  return *author_;
}
inline void NewsItem::set_author(const ::std::string& value) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  author_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.NewsItem.author)
}
inline void NewsItem::set_author(const char* value) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  author_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.NewsItem.author)
}
inline void NewsItem::set_author(const char* value, size_t size) {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  author_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.NewsItem.author)
}
inline ::std::string* NewsItem::mutable_author() {
  set_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    author_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsItem.author)
  return author_;
}
inline ::std::string* NewsItem::release_author() {
  clear_has_author();
  if (author_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = author_;
    author_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewsItem::set_allocated_author(::std::string* author) {
  if (author_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete author_;
  }
  if (author) {
    set_has_author();
    author_ = author;
  } else {
    clear_has_author();
    author_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.NewsItem.author)
}

// optional string digest = 3;
inline bool NewsItem::has_digest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewsItem::set_has_digest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewsItem::clear_has_digest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewsItem::clear_digest() {
  if (digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_->clear();
  }
  clear_has_digest();
}
inline const ::std::string& NewsItem::digest() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsItem.digest)
  return *digest_;
}
inline void NewsItem::set_digest(const ::std::string& value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.NewsItem.digest)
}
inline void NewsItem::set_digest(const char* value) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  digest_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.NewsItem.digest)
}
inline void NewsItem::set_digest(const char* value, size_t size) {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  digest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.NewsItem.digest)
}
inline ::std::string* NewsItem::mutable_digest() {
  set_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    digest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsItem.digest)
  return digest_;
}
inline ::std::string* NewsItem::release_digest() {
  clear_has_digest();
  if (digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = digest_;
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewsItem::set_allocated_digest(::std::string* digest) {
  if (digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete digest_;
  }
  if (digest) {
    set_has_digest();
    digest_ = digest;
  } else {
    clear_has_digest();
    digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.NewsItem.digest)
}

// optional string content = 4;
inline bool NewsItem::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewsItem::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewsItem::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewsItem::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& NewsItem::content() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsItem.content)
  return *content_;
}
inline void NewsItem::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.NewsItem.content)
}
inline void NewsItem::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.NewsItem.content)
}
inline void NewsItem::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.NewsItem.content)
}
inline ::std::string* NewsItem::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsItem.content)
  return content_;
}
inline ::std::string* NewsItem::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewsItem::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.NewsItem.content)
}

// optional string content_source_url = 5;
inline bool NewsItem::has_content_source_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewsItem::set_has_content_source_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewsItem::clear_has_content_source_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewsItem::clear_content_source_url() {
  if (content_source_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_source_url_->clear();
  }
  clear_has_content_source_url();
}
inline const ::std::string& NewsItem::content_source_url() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsItem.content_source_url)
  return *content_source_url_;
}
inline void NewsItem::set_content_source_url(const ::std::string& value) {
  set_has_content_source_url();
  if (content_source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_source_url_ = new ::std::string;
  }
  content_source_url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.NewsItem.content_source_url)
}
inline void NewsItem::set_content_source_url(const char* value) {
  set_has_content_source_url();
  if (content_source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_source_url_ = new ::std::string;
  }
  content_source_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.NewsItem.content_source_url)
}
inline void NewsItem::set_content_source_url(const char* value, size_t size) {
  set_has_content_source_url();
  if (content_source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_source_url_ = new ::std::string;
  }
  content_source_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.NewsItem.content_source_url)
}
inline ::std::string* NewsItem::mutable_content_source_url() {
  set_has_content_source_url();
  if (content_source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_source_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsItem.content_source_url)
  return content_source_url_;
}
inline ::std::string* NewsItem::release_content_source_url() {
  clear_has_content_source_url();
  if (content_source_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_source_url_;
    content_source_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewsItem::set_allocated_content_source_url(::std::string* content_source_url) {
  if (content_source_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_source_url_;
  }
  if (content_source_url) {
    set_has_content_source_url();
    content_source_url_ = content_source_url;
  } else {
    clear_has_content_source_url();
    content_source_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.NewsItem.content_source_url)
}

// optional string thumb_media_id = 6;
inline bool NewsItem::has_thumb_media_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewsItem::set_has_thumb_media_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewsItem::clear_has_thumb_media_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewsItem::clear_thumb_media_id() {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_->clear();
  }
  clear_has_thumb_media_id();
}
inline const ::std::string& NewsItem::thumb_media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsItem.thumb_media_id)
  return *thumb_media_id_;
}
inline void NewsItem::set_thumb_media_id(const ::std::string& value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.NewsItem.thumb_media_id)
}
inline void NewsItem::set_thumb_media_id(const char* value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.NewsItem.thumb_media_id)
}
inline void NewsItem::set_thumb_media_id(const char* value, size_t size) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.NewsItem.thumb_media_id)
}
inline ::std::string* NewsItem::mutable_thumb_media_id() {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsItem.thumb_media_id)
  return thumb_media_id_;
}
inline ::std::string* NewsItem::release_thumb_media_id() {
  clear_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thumb_media_id_;
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewsItem::set_allocated_thumb_media_id(::std::string* thumb_media_id) {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thumb_media_id_;
  }
  if (thumb_media_id) {
    set_has_thumb_media_id();
    thumb_media_id_ = thumb_media_id;
  } else {
    clear_has_thumb_media_id();
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.NewsItem.thumb_media_id)
}

// optional int64 show_cover_pic = 7;
inline bool NewsItem::has_show_cover_pic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewsItem::set_has_show_cover_pic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewsItem::clear_has_show_cover_pic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewsItem::clear_show_cover_pic() {
  show_cover_pic_ = GOOGLE_LONGLONG(0);
  clear_has_show_cover_pic();
}
inline ::google::protobuf::int64 NewsItem::show_cover_pic() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsItem.show_cover_pic)
  return show_cover_pic_;
}
inline void NewsItem::set_show_cover_pic(::google::protobuf::int64 value) {
  set_has_show_cover_pic();
  show_cover_pic_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.NewsItem.show_cover_pic)
}

// optional string url = 8;
inline bool NewsItem::has_url() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NewsItem::set_has_url() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NewsItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NewsItem::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& NewsItem::url() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsItem.url)
  return *url_;
}
inline void NewsItem::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.NewsItem.url)
}
inline void NewsItem::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.NewsItem.url)
}
inline void NewsItem::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.NewsItem.url)
}
inline ::std::string* NewsItem::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsItem.url)
  return url_;
}
inline ::std::string* NewsItem::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewsItem::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.NewsItem.url)
}

// optional string thumb_url = 9;
inline bool NewsItem::has_thumb_url() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NewsItem::set_has_thumb_url() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NewsItem::clear_has_thumb_url() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NewsItem::clear_thumb_url() {
  if (thumb_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_url_->clear();
  }
  clear_has_thumb_url();
}
inline const ::std::string& NewsItem::thumb_url() const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsItem.thumb_url)
  return *thumb_url_;
}
inline void NewsItem::set_thumb_url(const ::std::string& value) {
  set_has_thumb_url();
  if (thumb_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_url_ = new ::std::string;
  }
  thumb_url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.NewsItem.thumb_url)
}
inline void NewsItem::set_thumb_url(const char* value) {
  set_has_thumb_url();
  if (thumb_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_url_ = new ::std::string;
  }
  thumb_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.NewsItem.thumb_url)
}
inline void NewsItem::set_thumb_url(const char* value, size_t size) {
  set_has_thumb_url();
  if (thumb_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_url_ = new ::std::string;
  }
  thumb_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.NewsItem.thumb_url)
}
inline ::std::string* NewsItem::mutable_thumb_url() {
  set_has_thumb_url();
  if (thumb_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsItem.thumb_url)
  return thumb_url_;
}
inline ::std::string* NewsItem::release_thumb_url() {
  clear_has_thumb_url();
  if (thumb_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thumb_url_;
    thumb_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewsItem::set_allocated_thumb_url(::std::string* thumb_url) {
  if (thumb_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thumb_url_;
  }
  if (thumb_url) {
    set_has_thumb_url();
    thumb_url_ = thumb_url;
  } else {
    clear_has_thumb_url();
    thumb_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.NewsItem.thumb_url)
}

// -------------------------------------------------------------------

// NewsInfo

// repeated .mpcomm.NewsItem news_item = 1;
inline int NewsInfo::news_item_size() const {
  return news_item_.size();
}
inline void NewsInfo::clear_news_item() {
  news_item_.Clear();
}
inline const ::mpcomm::NewsItem& NewsInfo::news_item(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.NewsInfo.news_item)
  return news_item_.Get(index);
}
inline ::mpcomm::NewsItem* NewsInfo::mutable_news_item(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.NewsInfo.news_item)
  return news_item_.Mutable(index);
}
inline ::mpcomm::NewsItem* NewsInfo::add_news_item() {
  // @@protoc_insertion_point(field_add:mpcomm.NewsInfo.news_item)
  return news_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >&
NewsInfo::news_item() const {
  // @@protoc_insertion_point(field_list:mpcomm.NewsInfo.news_item)
  return news_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >*
NewsInfo::mutable_news_item() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.NewsInfo.news_item)
  return &news_item_;
}

// -------------------------------------------------------------------

// UploadImgReq

// optional string access_token = 1;
inline bool UploadImgReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadImgReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadImgReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadImgReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UploadImgReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadImgReq.access_token)
  return *access_token_;
}
inline void UploadImgReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadImgReq.access_token)
}
inline void UploadImgReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadImgReq.access_token)
}
inline void UploadImgReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadImgReq.access_token)
}
inline ::std::string* UploadImgReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadImgReq.access_token)
  return access_token_;
}
inline ::std::string* UploadImgReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadImgReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadImgReq.access_token)
}

// optional .mpcomm.MediaFile media = 2;
inline bool UploadImgReq::has_media() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadImgReq::set_has_media() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadImgReq::clear_has_media() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadImgReq::clear_media() {
  if (media_ != NULL) media_->::mpcomm::MediaFile::Clear();
  clear_has_media();
}
inline const ::mpcomm::MediaFile& UploadImgReq::media() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadImgReq.media)
  return media_ != NULL ? *media_ : *default_instance_->media_;
}
inline ::mpcomm::MediaFile* UploadImgReq::mutable_media() {
  set_has_media();
  if (media_ == NULL) media_ = new ::mpcomm::MediaFile;
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadImgReq.media)
  return media_;
}
inline ::mpcomm::MediaFile* UploadImgReq::release_media() {
  clear_has_media();
  ::mpcomm::MediaFile* temp = media_;
  media_ = NULL;
  return temp;
}
inline void UploadImgReq::set_allocated_media(::mpcomm::MediaFile* media) {
  delete media_;
  media_ = media;
  if (media) {
    set_has_media();
  } else {
    clear_has_media();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadImgReq.media)
}

// -------------------------------------------------------------------

// UploadImgResp

// optional int64 errcode = 1;
inline bool UploadImgResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadImgResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadImgResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadImgResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 UploadImgResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadImgResp.errcode)
  return errcode_;
}
inline void UploadImgResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UploadImgResp.errcode)
}

// optional string errmsg = 2;
inline bool UploadImgResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadImgResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadImgResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadImgResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& UploadImgResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadImgResp.errmsg)
  return *errmsg_;
}
inline void UploadImgResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadImgResp.errmsg)
}
inline void UploadImgResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadImgResp.errmsg)
}
inline void UploadImgResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadImgResp.errmsg)
}
inline ::std::string* UploadImgResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadImgResp.errmsg)
  return errmsg_;
}
inline ::std::string* UploadImgResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadImgResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadImgResp.errmsg)
}

// optional string url = 3;
inline bool UploadImgResp::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UploadImgResp::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UploadImgResp::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UploadImgResp::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& UploadImgResp::url() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadImgResp.url)
  return *url_;
}
inline void UploadImgResp::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadImgResp.url)
}
inline void UploadImgResp::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadImgResp.url)
}
inline void UploadImgResp::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadImgResp.url)
}
inline ::std::string* UploadImgResp::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadImgResp.url)
  return url_;
}
inline ::std::string* UploadImgResp::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadImgResp::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadImgResp.url)
}

// -------------------------------------------------------------------

// UploadNewsReq

// optional string access_token = 1;
inline bool UploadNewsReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadNewsReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadNewsReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadNewsReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UploadNewsReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadNewsReq.access_token)
  return *access_token_;
}
inline void UploadNewsReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadNewsReq.access_token)
}
inline void UploadNewsReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadNewsReq.access_token)
}
inline void UploadNewsReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadNewsReq.access_token)
}
inline ::std::string* UploadNewsReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadNewsReq.access_token)
  return access_token_;
}
inline ::std::string* UploadNewsReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadNewsReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadNewsReq.access_token)
}

// repeated .mpcomm.NewsItem articles = 2;
inline int UploadNewsReq::articles_size() const {
  return articles_.size();
}
inline void UploadNewsReq::clear_articles() {
  articles_.Clear();
}
inline const ::mpcomm::NewsItem& UploadNewsReq::articles(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadNewsReq.articles)
  return articles_.Get(index);
}
inline ::mpcomm::NewsItem* UploadNewsReq::mutable_articles(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadNewsReq.articles)
  return articles_.Mutable(index);
}
inline ::mpcomm::NewsItem* UploadNewsReq::add_articles() {
  // @@protoc_insertion_point(field_add:mpcomm.UploadNewsReq.articles)
  return articles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >&
UploadNewsReq::articles() const {
  // @@protoc_insertion_point(field_list:mpcomm.UploadNewsReq.articles)
  return articles_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >*
UploadNewsReq::mutable_articles() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.UploadNewsReq.articles)
  return &articles_;
}

// -------------------------------------------------------------------

// UploadNewsResp

// optional int64 errcode = 1;
inline bool UploadNewsResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadNewsResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadNewsResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadNewsResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 UploadNewsResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadNewsResp.errcode)
  return errcode_;
}
inline void UploadNewsResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UploadNewsResp.errcode)
}

// optional string errmsg = 2;
inline bool UploadNewsResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadNewsResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadNewsResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadNewsResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& UploadNewsResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadNewsResp.errmsg)
  return *errmsg_;
}
inline void UploadNewsResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadNewsResp.errmsg)
}
inline void UploadNewsResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadNewsResp.errmsg)
}
inline void UploadNewsResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadNewsResp.errmsg)
}
inline ::std::string* UploadNewsResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadNewsResp.errmsg)
  return errmsg_;
}
inline ::std::string* UploadNewsResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadNewsResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadNewsResp.errmsg)
}

// optional string type = 3;
inline bool UploadNewsResp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UploadNewsResp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UploadNewsResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UploadNewsResp::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& UploadNewsResp::type() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadNewsResp.type)
  return *type_;
}
inline void UploadNewsResp::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadNewsResp.type)
}
inline void UploadNewsResp::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadNewsResp.type)
}
inline void UploadNewsResp::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadNewsResp.type)
}
inline ::std::string* UploadNewsResp::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadNewsResp.type)
  return type_;
}
inline ::std::string* UploadNewsResp::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadNewsResp::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadNewsResp.type)
}

// optional string media_id = 4;
inline bool UploadNewsResp::has_media_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UploadNewsResp::set_has_media_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UploadNewsResp::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UploadNewsResp::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& UploadNewsResp::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadNewsResp.media_id)
  return *media_id_;
}
inline void UploadNewsResp::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadNewsResp.media_id)
}
inline void UploadNewsResp::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadNewsResp.media_id)
}
inline void UploadNewsResp::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadNewsResp.media_id)
}
inline ::std::string* UploadNewsResp::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadNewsResp.media_id)
  return media_id_;
}
inline ::std::string* UploadNewsResp::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadNewsResp::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadNewsResp.media_id)
}

// optional uint64 created_at = 5;
inline bool UploadNewsResp::has_created_at() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UploadNewsResp::set_has_created_at() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UploadNewsResp::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UploadNewsResp::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 UploadNewsResp::created_at() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadNewsResp.created_at)
  return created_at_;
}
inline void UploadNewsResp::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UploadNewsResp.created_at)
}

// -------------------------------------------------------------------

// UploadMediaReq

// optional string access_token = 1;
inline bool UploadMediaReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadMediaReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadMediaReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadMediaReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UploadMediaReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadMediaReq.access_token)
  return *access_token_;
}
inline void UploadMediaReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadMediaReq.access_token)
}
inline void UploadMediaReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadMediaReq.access_token)
}
inline void UploadMediaReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadMediaReq.access_token)
}
inline ::std::string* UploadMediaReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadMediaReq.access_token)
  return access_token_;
}
inline ::std::string* UploadMediaReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadMediaReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadMediaReq.access_token)
}

// optional string type = 2;
inline bool UploadMediaReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadMediaReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadMediaReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadMediaReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& UploadMediaReq::type() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadMediaReq.type)
  return *type_;
}
inline void UploadMediaReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadMediaReq.type)
}
inline void UploadMediaReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadMediaReq.type)
}
inline void UploadMediaReq::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadMediaReq.type)
}
inline ::std::string* UploadMediaReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadMediaReq.type)
  return type_;
}
inline ::std::string* UploadMediaReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadMediaReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadMediaReq.type)
}

// optional .mpcomm.MediaFile media = 3;
inline bool UploadMediaReq::has_media() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UploadMediaReq::set_has_media() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UploadMediaReq::clear_has_media() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UploadMediaReq::clear_media() {
  if (media_ != NULL) media_->::mpcomm::MediaFile::Clear();
  clear_has_media();
}
inline const ::mpcomm::MediaFile& UploadMediaReq::media() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadMediaReq.media)
  return media_ != NULL ? *media_ : *default_instance_->media_;
}
inline ::mpcomm::MediaFile* UploadMediaReq::mutable_media() {
  set_has_media();
  if (media_ == NULL) media_ = new ::mpcomm::MediaFile;
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadMediaReq.media)
  return media_;
}
inline ::mpcomm::MediaFile* UploadMediaReq::release_media() {
  clear_has_media();
  ::mpcomm::MediaFile* temp = media_;
  media_ = NULL;
  return temp;
}
inline void UploadMediaReq::set_allocated_media(::mpcomm::MediaFile* media) {
  delete media_;
  media_ = media;
  if (media) {
    set_has_media();
  } else {
    clear_has_media();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadMediaReq.media)
}

// -------------------------------------------------------------------

// UploadMediaResp

// optional int64 errcode = 1;
inline bool UploadMediaResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadMediaResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadMediaResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadMediaResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 UploadMediaResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadMediaResp.errcode)
  return errcode_;
}
inline void UploadMediaResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UploadMediaResp.errcode)
}

// optional string errmsg = 2;
inline bool UploadMediaResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadMediaResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadMediaResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadMediaResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& UploadMediaResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadMediaResp.errmsg)
  return *errmsg_;
}
inline void UploadMediaResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadMediaResp.errmsg)
}
inline void UploadMediaResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadMediaResp.errmsg)
}
inline void UploadMediaResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadMediaResp.errmsg)
}
inline ::std::string* UploadMediaResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadMediaResp.errmsg)
  return errmsg_;
}
inline ::std::string* UploadMediaResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadMediaResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadMediaResp.errmsg)
}

// optional string type = 3;
inline bool UploadMediaResp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UploadMediaResp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UploadMediaResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UploadMediaResp::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& UploadMediaResp::type() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadMediaResp.type)
  return *type_;
}
inline void UploadMediaResp::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadMediaResp.type)
}
inline void UploadMediaResp::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadMediaResp.type)
}
inline void UploadMediaResp::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadMediaResp.type)
}
inline ::std::string* UploadMediaResp::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadMediaResp.type)
  return type_;
}
inline ::std::string* UploadMediaResp::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadMediaResp::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadMediaResp.type)
}

// optional string media_id = 4;
inline bool UploadMediaResp::has_media_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UploadMediaResp::set_has_media_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UploadMediaResp::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UploadMediaResp::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& UploadMediaResp::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadMediaResp.media_id)
  return *media_id_;
}
inline void UploadMediaResp::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadMediaResp.media_id)
}
inline void UploadMediaResp::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadMediaResp.media_id)
}
inline void UploadMediaResp::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadMediaResp.media_id)
}
inline ::std::string* UploadMediaResp::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadMediaResp.media_id)
  return media_id_;
}
inline ::std::string* UploadMediaResp::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadMediaResp::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadMediaResp.media_id)
}

// optional uint64 created_at = 5;
inline bool UploadMediaResp::has_created_at() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UploadMediaResp::set_has_created_at() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UploadMediaResp::clear_has_created_at() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UploadMediaResp::clear_created_at() {
  created_at_ = GOOGLE_ULONGLONG(0);
  clear_has_created_at();
}
inline ::google::protobuf::uint64 UploadMediaResp::created_at() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadMediaResp.created_at)
  return created_at_;
}
inline void UploadMediaResp::set_created_at(::google::protobuf::uint64 value) {
  set_has_created_at();
  created_at_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UploadMediaResp.created_at)
}

// optional string thumb_media_id = 6;
inline bool UploadMediaResp::has_thumb_media_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UploadMediaResp::set_has_thumb_media_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UploadMediaResp::clear_has_thumb_media_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UploadMediaResp::clear_thumb_media_id() {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_->clear();
  }
  clear_has_thumb_media_id();
}
inline const ::std::string& UploadMediaResp::thumb_media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.UploadMediaResp.thumb_media_id)
  return *thumb_media_id_;
}
inline void UploadMediaResp::set_thumb_media_id(const ::std::string& value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UploadMediaResp.thumb_media_id)
}
inline void UploadMediaResp::set_thumb_media_id(const char* value) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UploadMediaResp.thumb_media_id)
}
inline void UploadMediaResp::set_thumb_media_id(const char* value, size_t size) {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  thumb_media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UploadMediaResp.thumb_media_id)
}
inline ::std::string* UploadMediaResp::mutable_thumb_media_id() {
  set_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumb_media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UploadMediaResp.thumb_media_id)
  return thumb_media_id_;
}
inline ::std::string* UploadMediaResp::release_thumb_media_id() {
  clear_has_thumb_media_id();
  if (thumb_media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thumb_media_id_;
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UploadMediaResp::set_allocated_thumb_media_id(::std::string* thumb_media_id) {
  if (thumb_media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thumb_media_id_;
  }
  if (thumb_media_id) {
    set_has_thumb_media_id();
    thumb_media_id_ = thumb_media_id;
  } else {
    clear_has_thumb_media_id();
    thumb_media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UploadMediaResp.thumb_media_id)
}

// -------------------------------------------------------------------

// GetMediaReq

// optional string access_token = 1;
inline bool GetMediaReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMediaReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMediaReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMediaReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetMediaReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMediaReq.access_token)
  return *access_token_;
}
inline void GetMediaReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMediaReq.access_token)
}
inline void GetMediaReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMediaReq.access_token)
}
inline void GetMediaReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMediaReq.access_token)
}
inline ::std::string* GetMediaReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMediaReq.access_token)
  return access_token_;
}
inline ::std::string* GetMediaReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMediaReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMediaReq.access_token)
}

// optional string media_id = 2;
inline bool GetMediaReq::has_media_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMediaReq::set_has_media_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMediaReq::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMediaReq::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& GetMediaReq::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMediaReq.media_id)
  return *media_id_;
}
inline void GetMediaReq::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMediaReq.media_id)
}
inline void GetMediaReq::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMediaReq.media_id)
}
inline void GetMediaReq::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMediaReq.media_id)
}
inline ::std::string* GetMediaReq::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMediaReq.media_id)
  return media_id_;
}
inline ::std::string* GetMediaReq::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMediaReq::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMediaReq.media_id)
}

// -------------------------------------------------------------------

// GetMediaResp

// optional int64 errcode = 1;
inline bool GetMediaResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMediaResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMediaResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMediaResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetMediaResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMediaResp.errcode)
  return errcode_;
}
inline void GetMediaResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetMediaResp.errcode)
}

// optional string errmsg = 2;
inline bool GetMediaResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMediaResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMediaResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMediaResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetMediaResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMediaResp.errmsg)
  return *errmsg_;
}
inline void GetMediaResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMediaResp.errmsg)
}
inline void GetMediaResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMediaResp.errmsg)
}
inline void GetMediaResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMediaResp.errmsg)
}
inline ::std::string* GetMediaResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMediaResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetMediaResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMediaResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMediaResp.errmsg)
}

// optional .mpcomm.MediaFile media = 3;
inline bool GetMediaResp::has_media() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetMediaResp::set_has_media() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetMediaResp::clear_has_media() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetMediaResp::clear_media() {
  if (media_ != NULL) media_->::mpcomm::MediaFile::Clear();
  clear_has_media();
}
inline const ::mpcomm::MediaFile& GetMediaResp::media() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMediaResp.media)
  return media_ != NULL ? *media_ : *default_instance_->media_;
}
inline ::mpcomm::MediaFile* GetMediaResp::mutable_media() {
  set_has_media();
  if (media_ == NULL) media_ = new ::mpcomm::MediaFile;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMediaResp.media)
  return media_;
}
inline ::mpcomm::MediaFile* GetMediaResp::release_media() {
  clear_has_media();
  ::mpcomm::MediaFile* temp = media_;
  media_ = NULL;
  return temp;
}
inline void GetMediaResp::set_allocated_media(::mpcomm::MediaFile* media) {
  delete media_;
  media_ = media;
  if (media) {
    set_has_media();
  } else {
    clear_has_media();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMediaResp.media)
}

// -------------------------------------------------------------------

// MaterialVideoDescription

// optional string title = 1;
inline bool MaterialVideoDescription::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaterialVideoDescription::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaterialVideoDescription::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaterialVideoDescription::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& MaterialVideoDescription::title() const {
  // @@protoc_insertion_point(field_get:mpcomm.MaterialVideoDescription.title)
  return *title_;
}
inline void MaterialVideoDescription::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MaterialVideoDescription.title)
}
inline void MaterialVideoDescription::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MaterialVideoDescription.title)
}
inline void MaterialVideoDescription::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MaterialVideoDescription.title)
}
inline ::std::string* MaterialVideoDescription::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MaterialVideoDescription.title)
  return title_;
}
inline ::std::string* MaterialVideoDescription::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MaterialVideoDescription::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MaterialVideoDescription.title)
}

// optional string introduction = 2;
inline bool MaterialVideoDescription::has_introduction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MaterialVideoDescription::set_has_introduction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MaterialVideoDescription::clear_has_introduction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MaterialVideoDescription::clear_introduction() {
  if (introduction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    introduction_->clear();
  }
  clear_has_introduction();
}
inline const ::std::string& MaterialVideoDescription::introduction() const {
  // @@protoc_insertion_point(field_get:mpcomm.MaterialVideoDescription.introduction)
  return *introduction_;
}
inline void MaterialVideoDescription::set_introduction(const ::std::string& value) {
  set_has_introduction();
  if (introduction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    introduction_ = new ::std::string;
  }
  introduction_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MaterialVideoDescription.introduction)
}
inline void MaterialVideoDescription::set_introduction(const char* value) {
  set_has_introduction();
  if (introduction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    introduction_ = new ::std::string;
  }
  introduction_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MaterialVideoDescription.introduction)
}
inline void MaterialVideoDescription::set_introduction(const char* value, size_t size) {
  set_has_introduction();
  if (introduction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    introduction_ = new ::std::string;
  }
  introduction_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MaterialVideoDescription.introduction)
}
inline ::std::string* MaterialVideoDescription::mutable_introduction() {
  set_has_introduction();
  if (introduction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    introduction_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MaterialVideoDescription.introduction)
  return introduction_;
}
inline ::std::string* MaterialVideoDescription::release_introduction() {
  clear_has_introduction();
  if (introduction_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = introduction_;
    introduction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MaterialVideoDescription::set_allocated_introduction(::std::string* introduction) {
  if (introduction_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete introduction_;
  }
  if (introduction) {
    set_has_introduction();
    introduction_ = introduction;
  } else {
    clear_has_introduction();
    introduction_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MaterialVideoDescription.introduction)
}

// -------------------------------------------------------------------

// AddNewsMaterialReq

// optional string access_token = 1;
inline bool AddNewsMaterialReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddNewsMaterialReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddNewsMaterialReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddNewsMaterialReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& AddNewsMaterialReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddNewsMaterialReq.access_token)
  return *access_token_;
}
inline void AddNewsMaterialReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddNewsMaterialReq.access_token)
}
inline void AddNewsMaterialReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddNewsMaterialReq.access_token)
}
inline void AddNewsMaterialReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddNewsMaterialReq.access_token)
}
inline ::std::string* AddNewsMaterialReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddNewsMaterialReq.access_token)
  return access_token_;
}
inline ::std::string* AddNewsMaterialReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddNewsMaterialReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddNewsMaterialReq.access_token)
}

// repeated .mpcomm.NewsItem articles = 2;
inline int AddNewsMaterialReq::articles_size() const {
  return articles_.size();
}
inline void AddNewsMaterialReq::clear_articles() {
  articles_.Clear();
}
inline const ::mpcomm::NewsItem& AddNewsMaterialReq::articles(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.AddNewsMaterialReq.articles)
  return articles_.Get(index);
}
inline ::mpcomm::NewsItem* AddNewsMaterialReq::mutable_articles(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.AddNewsMaterialReq.articles)
  return articles_.Mutable(index);
}
inline ::mpcomm::NewsItem* AddNewsMaterialReq::add_articles() {
  // @@protoc_insertion_point(field_add:mpcomm.AddNewsMaterialReq.articles)
  return articles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >&
AddNewsMaterialReq::articles() const {
  // @@protoc_insertion_point(field_list:mpcomm.AddNewsMaterialReq.articles)
  return articles_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >*
AddNewsMaterialReq::mutable_articles() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.AddNewsMaterialReq.articles)
  return &articles_;
}

// -------------------------------------------------------------------

// AddNewsMaterialResp

// optional int64 errcode = 1;
inline bool AddNewsMaterialResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddNewsMaterialResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddNewsMaterialResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddNewsMaterialResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 AddNewsMaterialResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddNewsMaterialResp.errcode)
  return errcode_;
}
inline void AddNewsMaterialResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.AddNewsMaterialResp.errcode)
}

// optional string errmsg = 2;
inline bool AddNewsMaterialResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddNewsMaterialResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddNewsMaterialResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddNewsMaterialResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& AddNewsMaterialResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddNewsMaterialResp.errmsg)
  return *errmsg_;
}
inline void AddNewsMaterialResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddNewsMaterialResp.errmsg)
}
inline void AddNewsMaterialResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddNewsMaterialResp.errmsg)
}
inline void AddNewsMaterialResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddNewsMaterialResp.errmsg)
}
inline ::std::string* AddNewsMaterialResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddNewsMaterialResp.errmsg)
  return errmsg_;
}
inline ::std::string* AddNewsMaterialResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddNewsMaterialResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddNewsMaterialResp.errmsg)
}

// optional string media_id = 3;
inline bool AddNewsMaterialResp::has_media_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddNewsMaterialResp::set_has_media_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddNewsMaterialResp::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddNewsMaterialResp::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& AddNewsMaterialResp::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddNewsMaterialResp.media_id)
  return *media_id_;
}
inline void AddNewsMaterialResp::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddNewsMaterialResp.media_id)
}
inline void AddNewsMaterialResp::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddNewsMaterialResp.media_id)
}
inline void AddNewsMaterialResp::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddNewsMaterialResp.media_id)
}
inline ::std::string* AddNewsMaterialResp::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddNewsMaterialResp.media_id)
  return media_id_;
}
inline ::std::string* AddNewsMaterialResp::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddNewsMaterialResp::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddNewsMaterialResp.media_id)
}

// -------------------------------------------------------------------

// AddMaterialReq

// optional string access_token = 1;
inline bool AddMaterialReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddMaterialReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddMaterialReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddMaterialReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& AddMaterialReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddMaterialReq.access_token)
  return *access_token_;
}
inline void AddMaterialReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddMaterialReq.access_token)
}
inline void AddMaterialReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddMaterialReq.access_token)
}
inline void AddMaterialReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddMaterialReq.access_token)
}
inline ::std::string* AddMaterialReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddMaterialReq.access_token)
  return access_token_;
}
inline ::std::string* AddMaterialReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddMaterialReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddMaterialReq.access_token)
}

// optional string type = 2;
inline bool AddMaterialReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddMaterialReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddMaterialReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddMaterialReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& AddMaterialReq::type() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddMaterialReq.type)
  return *type_;
}
inline void AddMaterialReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddMaterialReq.type)
}
inline void AddMaterialReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddMaterialReq.type)
}
inline void AddMaterialReq::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddMaterialReq.type)
}
inline ::std::string* AddMaterialReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddMaterialReq.type)
  return type_;
}
inline ::std::string* AddMaterialReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddMaterialReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddMaterialReq.type)
}

// optional .mpcomm.MediaFile media = 3;
inline bool AddMaterialReq::has_media() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddMaterialReq::set_has_media() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddMaterialReq::clear_has_media() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddMaterialReq::clear_media() {
  if (media_ != NULL) media_->::mpcomm::MediaFile::Clear();
  clear_has_media();
}
inline const ::mpcomm::MediaFile& AddMaterialReq::media() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddMaterialReq.media)
  return media_ != NULL ? *media_ : *default_instance_->media_;
}
inline ::mpcomm::MediaFile* AddMaterialReq::mutable_media() {
  set_has_media();
  if (media_ == NULL) media_ = new ::mpcomm::MediaFile;
  // @@protoc_insertion_point(field_mutable:mpcomm.AddMaterialReq.media)
  return media_;
}
inline ::mpcomm::MediaFile* AddMaterialReq::release_media() {
  clear_has_media();
  ::mpcomm::MediaFile* temp = media_;
  media_ = NULL;
  return temp;
}
inline void AddMaterialReq::set_allocated_media(::mpcomm::MediaFile* media) {
  delete media_;
  media_ = media;
  if (media) {
    set_has_media();
  } else {
    clear_has_media();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddMaterialReq.media)
}

// optional .mpcomm.MaterialVideoDescription description = 4;
inline bool AddMaterialReq::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddMaterialReq::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddMaterialReq::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddMaterialReq::clear_description() {
  if (description_ != NULL) description_->::mpcomm::MaterialVideoDescription::Clear();
  clear_has_description();
}
inline const ::mpcomm::MaterialVideoDescription& AddMaterialReq::description() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddMaterialReq.description)
  return description_ != NULL ? *description_ : *default_instance_->description_;
}
inline ::mpcomm::MaterialVideoDescription* AddMaterialReq::mutable_description() {
  set_has_description();
  if (description_ == NULL) description_ = new ::mpcomm::MaterialVideoDescription;
  // @@protoc_insertion_point(field_mutable:mpcomm.AddMaterialReq.description)
  return description_;
}
inline ::mpcomm::MaterialVideoDescription* AddMaterialReq::release_description() {
  clear_has_description();
  ::mpcomm::MaterialVideoDescription* temp = description_;
  description_ = NULL;
  return temp;
}
inline void AddMaterialReq::set_allocated_description(::mpcomm::MaterialVideoDescription* description) {
  delete description_;
  description_ = description;
  if (description) {
    set_has_description();
  } else {
    clear_has_description();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddMaterialReq.description)
}

// -------------------------------------------------------------------

// AddMaterialResp

// optional int64 errcode = 1;
inline bool AddMaterialResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddMaterialResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddMaterialResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddMaterialResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 AddMaterialResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddMaterialResp.errcode)
  return errcode_;
}
inline void AddMaterialResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.AddMaterialResp.errcode)
}

// optional string errmsg = 2;
inline bool AddMaterialResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddMaterialResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddMaterialResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddMaterialResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& AddMaterialResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddMaterialResp.errmsg)
  return *errmsg_;
}
inline void AddMaterialResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddMaterialResp.errmsg)
}
inline void AddMaterialResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddMaterialResp.errmsg)
}
inline void AddMaterialResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddMaterialResp.errmsg)
}
inline ::std::string* AddMaterialResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddMaterialResp.errmsg)
  return errmsg_;
}
inline ::std::string* AddMaterialResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddMaterialResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddMaterialResp.errmsg)
}

// optional string media_id = 3;
inline bool AddMaterialResp::has_media_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddMaterialResp::set_has_media_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddMaterialResp::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddMaterialResp::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& AddMaterialResp::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddMaterialResp.media_id)
  return *media_id_;
}
inline void AddMaterialResp::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddMaterialResp.media_id)
}
inline void AddMaterialResp::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddMaterialResp.media_id)
}
inline void AddMaterialResp::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddMaterialResp.media_id)
}
inline ::std::string* AddMaterialResp::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddMaterialResp.media_id)
  return media_id_;
}
inline ::std::string* AddMaterialResp::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddMaterialResp::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddMaterialResp.media_id)
}

// optional string url = 4;
inline bool AddMaterialResp::has_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddMaterialResp::set_has_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddMaterialResp::clear_has_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddMaterialResp::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& AddMaterialResp::url() const {
  // @@protoc_insertion_point(field_get:mpcomm.AddMaterialResp.url)
  return *url_;
}
inline void AddMaterialResp::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.AddMaterialResp.url)
}
inline void AddMaterialResp::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.AddMaterialResp.url)
}
inline void AddMaterialResp::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.AddMaterialResp.url)
}
inline ::std::string* AddMaterialResp::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.AddMaterialResp.url)
  return url_;
}
inline ::std::string* AddMaterialResp::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AddMaterialResp::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.AddMaterialResp.url)
}

// -------------------------------------------------------------------

// GetMaterialReq

// optional string access_token = 1;
inline bool GetMaterialReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMaterialReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMaterialReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMaterialReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetMaterialReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialReq.access_token)
  return *access_token_;
}
inline void GetMaterialReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialReq.access_token)
}
inline void GetMaterialReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMaterialReq.access_token)
}
inline void GetMaterialReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMaterialReq.access_token)
}
inline ::std::string* GetMaterialReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialReq.access_token)
  return access_token_;
}
inline ::std::string* GetMaterialReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMaterialReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMaterialReq.access_token)
}

// optional string media_id = 2;
inline bool GetMaterialReq::has_media_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMaterialReq::set_has_media_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMaterialReq::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMaterialReq::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& GetMaterialReq::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialReq.media_id)
  return *media_id_;
}
inline void GetMaterialReq::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialReq.media_id)
}
inline void GetMaterialReq::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMaterialReq.media_id)
}
inline void GetMaterialReq::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMaterialReq.media_id)
}
inline ::std::string* GetMaterialReq::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialReq.media_id)
  return media_id_;
}
inline ::std::string* GetMaterialReq::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMaterialReq::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMaterialReq.media_id)
}

// -------------------------------------------------------------------

// GetMaterialResp

// optional int64 errcode = 1;
inline bool GetMaterialResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMaterialResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMaterialResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMaterialResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetMaterialResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialResp.errcode)
  return errcode_;
}
inline void GetMaterialResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialResp.errcode)
}

// optional string errmsg = 2;
inline bool GetMaterialResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMaterialResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMaterialResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMaterialResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetMaterialResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialResp.errmsg)
  return *errmsg_;
}
inline void GetMaterialResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialResp.errmsg)
}
inline void GetMaterialResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMaterialResp.errmsg)
}
inline void GetMaterialResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMaterialResp.errmsg)
}
inline ::std::string* GetMaterialResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetMaterialResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMaterialResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMaterialResp.errmsg)
}

// repeated .mpcomm.NewsItem news_item = 3;
inline int GetMaterialResp::news_item_size() const {
  return news_item_.size();
}
inline void GetMaterialResp::clear_news_item() {
  news_item_.Clear();
}
inline const ::mpcomm::NewsItem& GetMaterialResp::news_item(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialResp.news_item)
  return news_item_.Get(index);
}
inline ::mpcomm::NewsItem* GetMaterialResp::mutable_news_item(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialResp.news_item)
  return news_item_.Mutable(index);
}
inline ::mpcomm::NewsItem* GetMaterialResp::add_news_item() {
  // @@protoc_insertion_point(field_add:mpcomm.GetMaterialResp.news_item)
  return news_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >&
GetMaterialResp::news_item() const {
  // @@protoc_insertion_point(field_list:mpcomm.GetMaterialResp.news_item)
  return news_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::NewsItem >*
GetMaterialResp::mutable_news_item() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.GetMaterialResp.news_item)
  return &news_item_;
}

// optional string title = 4;
inline bool GetMaterialResp::has_title() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetMaterialResp::set_has_title() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetMaterialResp::clear_has_title() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetMaterialResp::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& GetMaterialResp::title() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialResp.title)
  return *title_;
}
inline void GetMaterialResp::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialResp.title)
}
inline void GetMaterialResp::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMaterialResp.title)
}
inline void GetMaterialResp::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMaterialResp.title)
}
inline ::std::string* GetMaterialResp::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialResp.title)
  return title_;
}
inline ::std::string* GetMaterialResp::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMaterialResp::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMaterialResp.title)
}

// optional string description = 5;
inline bool GetMaterialResp::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetMaterialResp::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetMaterialResp::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetMaterialResp::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& GetMaterialResp::description() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialResp.description)
  return *description_;
}
inline void GetMaterialResp::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialResp.description)
}
inline void GetMaterialResp::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMaterialResp.description)
}
inline void GetMaterialResp::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMaterialResp.description)
}
inline ::std::string* GetMaterialResp::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialResp.description)
  return description_;
}
inline ::std::string* GetMaterialResp::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMaterialResp::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMaterialResp.description)
}

// optional string down_url = 6;
inline bool GetMaterialResp::has_down_url() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetMaterialResp::set_has_down_url() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetMaterialResp::clear_has_down_url() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetMaterialResp::clear_down_url() {
  if (down_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    down_url_->clear();
  }
  clear_has_down_url();
}
inline const ::std::string& GetMaterialResp::down_url() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialResp.down_url)
  return *down_url_;
}
inline void GetMaterialResp::set_down_url(const ::std::string& value) {
  set_has_down_url();
  if (down_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    down_url_ = new ::std::string;
  }
  down_url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialResp.down_url)
}
inline void GetMaterialResp::set_down_url(const char* value) {
  set_has_down_url();
  if (down_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    down_url_ = new ::std::string;
  }
  down_url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMaterialResp.down_url)
}
inline void GetMaterialResp::set_down_url(const char* value, size_t size) {
  set_has_down_url();
  if (down_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    down_url_ = new ::std::string;
  }
  down_url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMaterialResp.down_url)
}
inline ::std::string* GetMaterialResp::mutable_down_url() {
  set_has_down_url();
  if (down_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    down_url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialResp.down_url)
  return down_url_;
}
inline ::std::string* GetMaterialResp::release_down_url() {
  clear_has_down_url();
  if (down_url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = down_url_;
    down_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMaterialResp::set_allocated_down_url(::std::string* down_url) {
  if (down_url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete down_url_;
  }
  if (down_url) {
    set_has_down_url();
    down_url_ = down_url;
  } else {
    clear_has_down_url();
    down_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMaterialResp.down_url)
}

// optional .mpcomm.MediaFile media = 7;
inline bool GetMaterialResp::has_media() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetMaterialResp::set_has_media() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetMaterialResp::clear_has_media() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetMaterialResp::clear_media() {
  if (media_ != NULL) media_->::mpcomm::MediaFile::Clear();
  clear_has_media();
}
inline const ::mpcomm::MediaFile& GetMaterialResp::media() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialResp.media)
  return media_ != NULL ? *media_ : *default_instance_->media_;
}
inline ::mpcomm::MediaFile* GetMaterialResp::mutable_media() {
  set_has_media();
  if (media_ == NULL) media_ = new ::mpcomm::MediaFile;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialResp.media)
  return media_;
}
inline ::mpcomm::MediaFile* GetMaterialResp::release_media() {
  clear_has_media();
  ::mpcomm::MediaFile* temp = media_;
  media_ = NULL;
  return temp;
}
inline void GetMaterialResp::set_allocated_media(::mpcomm::MediaFile* media) {
  delete media_;
  media_ = media;
  if (media) {
    set_has_media();
  } else {
    clear_has_media();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMaterialResp.media)
}

// -------------------------------------------------------------------

// DelMaterialReq

// optional string access_token = 1;
inline bool DelMaterialReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelMaterialReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelMaterialReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelMaterialReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& DelMaterialReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelMaterialReq.access_token)
  return *access_token_;
}
inline void DelMaterialReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DelMaterialReq.access_token)
}
inline void DelMaterialReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DelMaterialReq.access_token)
}
inline void DelMaterialReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DelMaterialReq.access_token)
}
inline ::std::string* DelMaterialReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DelMaterialReq.access_token)
  return access_token_;
}
inline ::std::string* DelMaterialReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DelMaterialReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DelMaterialReq.access_token)
}

// optional string media_id = 2;
inline bool DelMaterialReq::has_media_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelMaterialReq::set_has_media_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelMaterialReq::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelMaterialReq::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& DelMaterialReq::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelMaterialReq.media_id)
  return *media_id_;
}
inline void DelMaterialReq::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DelMaterialReq.media_id)
}
inline void DelMaterialReq::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DelMaterialReq.media_id)
}
inline void DelMaterialReq::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DelMaterialReq.media_id)
}
inline ::std::string* DelMaterialReq::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DelMaterialReq.media_id)
  return media_id_;
}
inline ::std::string* DelMaterialReq::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DelMaterialReq::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DelMaterialReq.media_id)
}

// -------------------------------------------------------------------

// DelMaterialResp

// optional int64 errcode = 1;
inline bool DelMaterialResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelMaterialResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelMaterialResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelMaterialResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 DelMaterialResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelMaterialResp.errcode)
  return errcode_;
}
inline void DelMaterialResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.DelMaterialResp.errcode)
}

// optional string errmsg = 2;
inline bool DelMaterialResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelMaterialResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelMaterialResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelMaterialResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& DelMaterialResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.DelMaterialResp.errmsg)
  return *errmsg_;
}
inline void DelMaterialResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DelMaterialResp.errmsg)
}
inline void DelMaterialResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DelMaterialResp.errmsg)
}
inline void DelMaterialResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DelMaterialResp.errmsg)
}
inline ::std::string* DelMaterialResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DelMaterialResp.errmsg)
  return errmsg_;
}
inline ::std::string* DelMaterialResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DelMaterialResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DelMaterialResp.errmsg)
}

// -------------------------------------------------------------------

// UpdateNewsReq

// optional string access_token = 1;
inline bool UpdateNewsReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateNewsReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateNewsReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateNewsReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UpdateNewsReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateNewsReq.access_token)
  return *access_token_;
}
inline void UpdateNewsReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateNewsReq.access_token)
}
inline void UpdateNewsReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateNewsReq.access_token)
}
inline void UpdateNewsReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateNewsReq.access_token)
}
inline ::std::string* UpdateNewsReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateNewsReq.access_token)
  return access_token_;
}
inline ::std::string* UpdateNewsReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateNewsReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateNewsReq.access_token)
}

// optional string media_id = 2;
inline bool UpdateNewsReq::has_media_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateNewsReq::set_has_media_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateNewsReq::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateNewsReq::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& UpdateNewsReq::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateNewsReq.media_id)
  return *media_id_;
}
inline void UpdateNewsReq::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateNewsReq.media_id)
}
inline void UpdateNewsReq::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateNewsReq.media_id)
}
inline void UpdateNewsReq::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateNewsReq.media_id)
}
inline ::std::string* UpdateNewsReq::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateNewsReq.media_id)
  return media_id_;
}
inline ::std::string* UpdateNewsReq::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateNewsReq::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateNewsReq.media_id)
}

// optional uint64 index = 3;
inline bool UpdateNewsReq::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateNewsReq::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateNewsReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateNewsReq::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 UpdateNewsReq::index() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateNewsReq.index)
  return index_;
}
inline void UpdateNewsReq::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UpdateNewsReq.index)
}

// optional .mpcomm.NewsItem articles = 4;
inline bool UpdateNewsReq::has_articles() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateNewsReq::set_has_articles() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateNewsReq::clear_has_articles() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateNewsReq::clear_articles() {
  if (articles_ != NULL) articles_->::mpcomm::NewsItem::Clear();
  clear_has_articles();
}
inline const ::mpcomm::NewsItem& UpdateNewsReq::articles() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateNewsReq.articles)
  return articles_ != NULL ? *articles_ : *default_instance_->articles_;
}
inline ::mpcomm::NewsItem* UpdateNewsReq::mutable_articles() {
  set_has_articles();
  if (articles_ == NULL) articles_ = new ::mpcomm::NewsItem;
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateNewsReq.articles)
  return articles_;
}
inline ::mpcomm::NewsItem* UpdateNewsReq::release_articles() {
  clear_has_articles();
  ::mpcomm::NewsItem* temp = articles_;
  articles_ = NULL;
  return temp;
}
inline void UpdateNewsReq::set_allocated_articles(::mpcomm::NewsItem* articles) {
  delete articles_;
  articles_ = articles;
  if (articles) {
    set_has_articles();
  } else {
    clear_has_articles();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateNewsReq.articles)
}

// -------------------------------------------------------------------

// UpdateNewsResp

// optional int64 errcode = 1;
inline bool UpdateNewsResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateNewsResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateNewsResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateNewsResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 UpdateNewsResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateNewsResp.errcode)
  return errcode_;
}
inline void UpdateNewsResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UpdateNewsResp.errcode)
}

// optional string errmsg = 2;
inline bool UpdateNewsResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateNewsResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateNewsResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateNewsResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& UpdateNewsResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateNewsResp.errmsg)
  return *errmsg_;
}
inline void UpdateNewsResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateNewsResp.errmsg)
}
inline void UpdateNewsResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateNewsResp.errmsg)
}
inline void UpdateNewsResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateNewsResp.errmsg)
}
inline ::std::string* UpdateNewsResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateNewsResp.errmsg)
  return errmsg_;
}
inline ::std::string* UpdateNewsResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateNewsResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateNewsResp.errmsg)
}

// -------------------------------------------------------------------

// GetMaterialCountReq

// optional string access_token = 1;
inline bool GetMaterialCountReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMaterialCountReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMaterialCountReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMaterialCountReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetMaterialCountReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialCountReq.access_token)
  return *access_token_;
}
inline void GetMaterialCountReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialCountReq.access_token)
}
inline void GetMaterialCountReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMaterialCountReq.access_token)
}
inline void GetMaterialCountReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMaterialCountReq.access_token)
}
inline ::std::string* GetMaterialCountReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialCountReq.access_token)
  return access_token_;
}
inline ::std::string* GetMaterialCountReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMaterialCountReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMaterialCountReq.access_token)
}

// -------------------------------------------------------------------

// GetMaterialCountResp

// optional int64 errcode = 1;
inline bool GetMaterialCountResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMaterialCountResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMaterialCountResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMaterialCountResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetMaterialCountResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialCountResp.errcode)
  return errcode_;
}
inline void GetMaterialCountResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialCountResp.errcode)
}

// optional string errmsg = 2;
inline bool GetMaterialCountResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMaterialCountResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMaterialCountResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMaterialCountResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetMaterialCountResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialCountResp.errmsg)
  return *errmsg_;
}
inline void GetMaterialCountResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialCountResp.errmsg)
}
inline void GetMaterialCountResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetMaterialCountResp.errmsg)
}
inline void GetMaterialCountResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetMaterialCountResp.errmsg)
}
inline ::std::string* GetMaterialCountResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetMaterialCountResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetMaterialCountResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMaterialCountResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetMaterialCountResp.errmsg)
}

// optional uint64 voice_count = 3;
inline bool GetMaterialCountResp::has_voice_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetMaterialCountResp::set_has_voice_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetMaterialCountResp::clear_has_voice_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetMaterialCountResp::clear_voice_count() {
  voice_count_ = GOOGLE_ULONGLONG(0);
  clear_has_voice_count();
}
inline ::google::protobuf::uint64 GetMaterialCountResp::voice_count() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialCountResp.voice_count)
  return voice_count_;
}
inline void GetMaterialCountResp::set_voice_count(::google::protobuf::uint64 value) {
  set_has_voice_count();
  voice_count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialCountResp.voice_count)
}

// optional uint64 video_count = 4;
inline bool GetMaterialCountResp::has_video_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetMaterialCountResp::set_has_video_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetMaterialCountResp::clear_has_video_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetMaterialCountResp::clear_video_count() {
  video_count_ = GOOGLE_ULONGLONG(0);
  clear_has_video_count();
}
inline ::google::protobuf::uint64 GetMaterialCountResp::video_count() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialCountResp.video_count)
  return video_count_;
}
inline void GetMaterialCountResp::set_video_count(::google::protobuf::uint64 value) {
  set_has_video_count();
  video_count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialCountResp.video_count)
}

// optional uint64 image_count = 5;
inline bool GetMaterialCountResp::has_image_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetMaterialCountResp::set_has_image_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetMaterialCountResp::clear_has_image_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetMaterialCountResp::clear_image_count() {
  image_count_ = GOOGLE_ULONGLONG(0);
  clear_has_image_count();
}
inline ::google::protobuf::uint64 GetMaterialCountResp::image_count() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialCountResp.image_count)
  return image_count_;
}
inline void GetMaterialCountResp::set_image_count(::google::protobuf::uint64 value) {
  set_has_image_count();
  image_count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialCountResp.image_count)
}

// optional uint64 news_count = 6;
inline bool GetMaterialCountResp::has_news_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetMaterialCountResp::set_has_news_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetMaterialCountResp::clear_has_news_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetMaterialCountResp::clear_news_count() {
  news_count_ = GOOGLE_ULONGLONG(0);
  clear_has_news_count();
}
inline ::google::protobuf::uint64 GetMaterialCountResp::news_count() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetMaterialCountResp.news_count)
  return news_count_;
}
inline void GetMaterialCountResp::set_news_count(::google::protobuf::uint64 value) {
  set_has_news_count();
  news_count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetMaterialCountResp.news_count)
}

// -------------------------------------------------------------------

// BatchGetMaterialReq

// optional string access_token = 1;
inline bool BatchGetMaterialReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchGetMaterialReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchGetMaterialReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchGetMaterialReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& BatchGetMaterialReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetMaterialReq.access_token)
  return *access_token_;
}
inline void BatchGetMaterialReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetMaterialReq.access_token)
}
inline void BatchGetMaterialReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchGetMaterialReq.access_token)
}
inline void BatchGetMaterialReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchGetMaterialReq.access_token)
}
inline ::std::string* BatchGetMaterialReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetMaterialReq.access_token)
  return access_token_;
}
inline ::std::string* BatchGetMaterialReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchGetMaterialReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchGetMaterialReq.access_token)
}

// optional string type = 2;
inline bool BatchGetMaterialReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchGetMaterialReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchGetMaterialReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchGetMaterialReq::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& BatchGetMaterialReq::type() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetMaterialReq.type)
  return *type_;
}
inline void BatchGetMaterialReq::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetMaterialReq.type)
}
inline void BatchGetMaterialReq::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchGetMaterialReq.type)
}
inline void BatchGetMaterialReq::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchGetMaterialReq.type)
}
inline ::std::string* BatchGetMaterialReq::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetMaterialReq.type)
  return type_;
}
inline ::std::string* BatchGetMaterialReq::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchGetMaterialReq::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchGetMaterialReq.type)
}

// optional uint64 offset = 3;
inline bool BatchGetMaterialReq::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatchGetMaterialReq::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatchGetMaterialReq::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatchGetMaterialReq::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 BatchGetMaterialReq::offset() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetMaterialReq.offset)
  return offset_;
}
inline void BatchGetMaterialReq::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetMaterialReq.offset)
}

// optional uint64 count = 4;
inline bool BatchGetMaterialReq::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BatchGetMaterialReq::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BatchGetMaterialReq::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BatchGetMaterialReq::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::uint64 BatchGetMaterialReq::count() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetMaterialReq.count)
  return count_;
}
inline void BatchGetMaterialReq::set_count(::google::protobuf::uint64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetMaterialReq.count)
}

// -------------------------------------------------------------------

// MaterialItem

// optional string media_id = 1;
inline bool MaterialItem::has_media_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaterialItem::set_has_media_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaterialItem::clear_has_media_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaterialItem::clear_media_id() {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_->clear();
  }
  clear_has_media_id();
}
inline const ::std::string& MaterialItem::media_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MaterialItem.media_id)
  return *media_id_;
}
inline void MaterialItem::set_media_id(const ::std::string& value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MaterialItem.media_id)
}
inline void MaterialItem::set_media_id(const char* value) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MaterialItem.media_id)
}
inline void MaterialItem::set_media_id(const char* value, size_t size) {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  media_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MaterialItem.media_id)
}
inline ::std::string* MaterialItem::mutable_media_id() {
  set_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    media_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MaterialItem.media_id)
  return media_id_;
}
inline ::std::string* MaterialItem::release_media_id() {
  clear_has_media_id();
  if (media_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = media_id_;
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MaterialItem::set_allocated_media_id(::std::string* media_id) {
  if (media_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete media_id_;
  }
  if (media_id) {
    set_has_media_id();
    media_id_ = media_id;
  } else {
    clear_has_media_id();
    media_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MaterialItem.media_id)
}

// optional string name = 2;
inline bool MaterialItem::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MaterialItem::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MaterialItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MaterialItem::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MaterialItem::name() const {
  // @@protoc_insertion_point(field_get:mpcomm.MaterialItem.name)
  return *name_;
}
inline void MaterialItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MaterialItem.name)
}
inline void MaterialItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MaterialItem.name)
}
inline void MaterialItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MaterialItem.name)
}
inline ::std::string* MaterialItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MaterialItem.name)
  return name_;
}
inline ::std::string* MaterialItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MaterialItem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MaterialItem.name)
}

// optional .mpcomm.NewsInfo content = 3;
inline bool MaterialItem::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MaterialItem::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MaterialItem::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MaterialItem::clear_content() {
  if (content_ != NULL) content_->::mpcomm::NewsInfo::Clear();
  clear_has_content();
}
inline const ::mpcomm::NewsInfo& MaterialItem::content() const {
  // @@protoc_insertion_point(field_get:mpcomm.MaterialItem.content)
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::mpcomm::NewsInfo* MaterialItem::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::mpcomm::NewsInfo;
  // @@protoc_insertion_point(field_mutable:mpcomm.MaterialItem.content)
  return content_;
}
inline ::mpcomm::NewsInfo* MaterialItem::release_content() {
  clear_has_content();
  ::mpcomm::NewsInfo* temp = content_;
  content_ = NULL;
  return temp;
}
inline void MaterialItem::set_allocated_content(::mpcomm::NewsInfo* content) {
  delete content_;
  content_ = content;
  if (content) {
    set_has_content();
  } else {
    clear_has_content();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MaterialItem.content)
}

// optional uint64 update_time = 4;
inline bool MaterialItem::has_update_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MaterialItem::set_has_update_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MaterialItem::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MaterialItem::clear_update_time() {
  update_time_ = GOOGLE_ULONGLONG(0);
  clear_has_update_time();
}
inline ::google::protobuf::uint64 MaterialItem::update_time() const {
  // @@protoc_insertion_point(field_get:mpcomm.MaterialItem.update_time)
  return update_time_;
}
inline void MaterialItem::set_update_time(::google::protobuf::uint64 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.MaterialItem.update_time)
}

// optional string bind_template_id = 5;
inline bool MaterialItem::has_bind_template_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MaterialItem::set_has_bind_template_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MaterialItem::clear_has_bind_template_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MaterialItem::clear_bind_template_id() {
  if (bind_template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_template_id_->clear();
  }
  clear_has_bind_template_id();
}
inline const ::std::string& MaterialItem::bind_template_id() const {
  // @@protoc_insertion_point(field_get:mpcomm.MaterialItem.bind_template_id)
  return *bind_template_id_;
}
inline void MaterialItem::set_bind_template_id(const ::std::string& value) {
  set_has_bind_template_id();
  if (bind_template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_template_id_ = new ::std::string;
  }
  bind_template_id_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MaterialItem.bind_template_id)
}
inline void MaterialItem::set_bind_template_id(const char* value) {
  set_has_bind_template_id();
  if (bind_template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_template_id_ = new ::std::string;
  }
  bind_template_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MaterialItem.bind_template_id)
}
inline void MaterialItem::set_bind_template_id(const char* value, size_t size) {
  set_has_bind_template_id();
  if (bind_template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_template_id_ = new ::std::string;
  }
  bind_template_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MaterialItem.bind_template_id)
}
inline ::std::string* MaterialItem::mutable_bind_template_id() {
  set_has_bind_template_id();
  if (bind_template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bind_template_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MaterialItem.bind_template_id)
  return bind_template_id_;
}
inline ::std::string* MaterialItem::release_bind_template_id() {
  clear_has_bind_template_id();
  if (bind_template_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bind_template_id_;
    bind_template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MaterialItem::set_allocated_bind_template_id(::std::string* bind_template_id) {
  if (bind_template_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bind_template_id_;
  }
  if (bind_template_id) {
    set_has_bind_template_id();
    bind_template_id_ = bind_template_id;
  } else {
    clear_has_bind_template_id();
    bind_template_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MaterialItem.bind_template_id)
}

// optional string url = 6;
inline bool MaterialItem::has_url() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MaterialItem::set_has_url() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MaterialItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MaterialItem::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& MaterialItem::url() const {
  // @@protoc_insertion_point(field_get:mpcomm.MaterialItem.url)
  return *url_;
}
inline void MaterialItem::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.MaterialItem.url)
}
inline void MaterialItem::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.MaterialItem.url)
}
inline void MaterialItem::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.MaterialItem.url)
}
inline ::std::string* MaterialItem::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.MaterialItem.url)
  return url_;
}
inline ::std::string* MaterialItem::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MaterialItem::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.MaterialItem.url)
}

// -------------------------------------------------------------------

// BatchGetMaterialResp

// optional int64 errcode = 1;
inline bool BatchGetMaterialResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchGetMaterialResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchGetMaterialResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchGetMaterialResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 BatchGetMaterialResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetMaterialResp.errcode)
  return errcode_;
}
inline void BatchGetMaterialResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetMaterialResp.errcode)
}

// optional string errmsg = 2;
inline bool BatchGetMaterialResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchGetMaterialResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchGetMaterialResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchGetMaterialResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& BatchGetMaterialResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetMaterialResp.errmsg)
  return *errmsg_;
}
inline void BatchGetMaterialResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetMaterialResp.errmsg)
}
inline void BatchGetMaterialResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchGetMaterialResp.errmsg)
}
inline void BatchGetMaterialResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchGetMaterialResp.errmsg)
}
inline ::std::string* BatchGetMaterialResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetMaterialResp.errmsg)
  return errmsg_;
}
inline ::std::string* BatchGetMaterialResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchGetMaterialResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchGetMaterialResp.errmsg)
}

// repeated .mpcomm.MaterialItem item = 3;
inline int BatchGetMaterialResp::item_size() const {
  return item_.size();
}
inline void BatchGetMaterialResp::clear_item() {
  item_.Clear();
}
inline const ::mpcomm::MaterialItem& BatchGetMaterialResp::item(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetMaterialResp.item)
  return item_.Get(index);
}
inline ::mpcomm::MaterialItem* BatchGetMaterialResp::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetMaterialResp.item)
  return item_.Mutable(index);
}
inline ::mpcomm::MaterialItem* BatchGetMaterialResp::add_item() {
  // @@protoc_insertion_point(field_add:mpcomm.BatchGetMaterialResp.item)
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::MaterialItem >&
BatchGetMaterialResp::item() const {
  // @@protoc_insertion_point(field_list:mpcomm.BatchGetMaterialResp.item)
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::MaterialItem >*
BatchGetMaterialResp::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.BatchGetMaterialResp.item)
  return &item_;
}

// optional uint64 total_count = 4;
inline bool BatchGetMaterialResp::has_total_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BatchGetMaterialResp::set_has_total_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BatchGetMaterialResp::clear_has_total_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BatchGetMaterialResp::clear_total_count() {
  total_count_ = GOOGLE_ULONGLONG(0);
  clear_has_total_count();
}
inline ::google::protobuf::uint64 BatchGetMaterialResp::total_count() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetMaterialResp.total_count)
  return total_count_;
}
inline void BatchGetMaterialResp::set_total_count(::google::protobuf::uint64 value) {
  set_has_total_count();
  total_count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetMaterialResp.total_count)
}

// optional uint64 item_count = 5;
inline bool BatchGetMaterialResp::has_item_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BatchGetMaterialResp::set_has_item_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BatchGetMaterialResp::clear_has_item_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BatchGetMaterialResp::clear_item_count() {
  item_count_ = GOOGLE_ULONGLONG(0);
  clear_has_item_count();
}
inline ::google::protobuf::uint64 BatchGetMaterialResp::item_count() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetMaterialResp.item_count)
  return item_count_;
}
inline void BatchGetMaterialResp::set_item_count(::google::protobuf::uint64 value) {
  set_has_item_count();
  item_count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetMaterialResp.item_count)
}

// -------------------------------------------------------------------

// Tag

// optional uint64 id = 1;
inline bool Tag::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tag::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tag::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tag::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Tag::id() const {
  // @@protoc_insertion_point(field_get:mpcomm.Tag.id)
  return id_;
}
inline void Tag::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.Tag.id)
}

// optional string name = 2;
inline bool Tag::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tag::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tag::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tag::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Tag::name() const {
  // @@protoc_insertion_point(field_get:mpcomm.Tag.name)
  return *name_;
}
inline void Tag::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.Tag.name)
}
inline void Tag::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.Tag.name)
}
inline void Tag::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.Tag.name)
}
inline ::std::string* Tag::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.Tag.name)
  return name_;
}
inline ::std::string* Tag::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Tag::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.Tag.name)
}

// optional uint64 count = 3;
inline bool Tag::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tag::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tag::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tag::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::uint64 Tag::count() const {
  // @@protoc_insertion_point(field_get:mpcomm.Tag.count)
  return count_;
}
inline void Tag::set_count(::google::protobuf::uint64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.Tag.count)
}

// -------------------------------------------------------------------

// CreateTagsReq

// optional string access_token = 1;
inline bool CreateTagsReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateTagsReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateTagsReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateTagsReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& CreateTagsReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.CreateTagsReq.access_token)
  return *access_token_;
}
inline void CreateTagsReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CreateTagsReq.access_token)
}
inline void CreateTagsReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CreateTagsReq.access_token)
}
inline void CreateTagsReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CreateTagsReq.access_token)
}
inline ::std::string* CreateTagsReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CreateTagsReq.access_token)
  return access_token_;
}
inline ::std::string* CreateTagsReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateTagsReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CreateTagsReq.access_token)
}

// optional .mpcomm.Tag tag = 2;
inline bool CreateTagsReq::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateTagsReq::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateTagsReq::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateTagsReq::clear_tag() {
  if (tag_ != NULL) tag_->::mpcomm::Tag::Clear();
  clear_has_tag();
}
inline const ::mpcomm::Tag& CreateTagsReq::tag() const {
  // @@protoc_insertion_point(field_get:mpcomm.CreateTagsReq.tag)
  return tag_ != NULL ? *tag_ : *default_instance_->tag_;
}
inline ::mpcomm::Tag* CreateTagsReq::mutable_tag() {
  set_has_tag();
  if (tag_ == NULL) tag_ = new ::mpcomm::Tag;
  // @@protoc_insertion_point(field_mutable:mpcomm.CreateTagsReq.tag)
  return tag_;
}
inline ::mpcomm::Tag* CreateTagsReq::release_tag() {
  clear_has_tag();
  ::mpcomm::Tag* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline void CreateTagsReq::set_allocated_tag(::mpcomm::Tag* tag) {
  delete tag_;
  tag_ = tag;
  if (tag) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CreateTagsReq.tag)
}

// -------------------------------------------------------------------

// CreateTagsResp

// optional int64 errcode = 1;
inline bool CreateTagsResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateTagsResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateTagsResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateTagsResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 CreateTagsResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.CreateTagsResp.errcode)
  return errcode_;
}
inline void CreateTagsResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.CreateTagsResp.errcode)
}

// optional string errmsg = 2;
inline bool CreateTagsResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateTagsResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateTagsResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateTagsResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& CreateTagsResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.CreateTagsResp.errmsg)
  return *errmsg_;
}
inline void CreateTagsResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.CreateTagsResp.errmsg)
}
inline void CreateTagsResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.CreateTagsResp.errmsg)
}
inline void CreateTagsResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.CreateTagsResp.errmsg)
}
inline ::std::string* CreateTagsResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.CreateTagsResp.errmsg)
  return errmsg_;
}
inline ::std::string* CreateTagsResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateTagsResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CreateTagsResp.errmsg)
}

// optional .mpcomm.Tag tag = 3;
inline bool CreateTagsResp::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateTagsResp::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateTagsResp::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateTagsResp::clear_tag() {
  if (tag_ != NULL) tag_->::mpcomm::Tag::Clear();
  clear_has_tag();
}
inline const ::mpcomm::Tag& CreateTagsResp::tag() const {
  // @@protoc_insertion_point(field_get:mpcomm.CreateTagsResp.tag)
  return tag_ != NULL ? *tag_ : *default_instance_->tag_;
}
inline ::mpcomm::Tag* CreateTagsResp::mutable_tag() {
  set_has_tag();
  if (tag_ == NULL) tag_ = new ::mpcomm::Tag;
  // @@protoc_insertion_point(field_mutable:mpcomm.CreateTagsResp.tag)
  return tag_;
}
inline ::mpcomm::Tag* CreateTagsResp::release_tag() {
  clear_has_tag();
  ::mpcomm::Tag* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline void CreateTagsResp::set_allocated_tag(::mpcomm::Tag* tag) {
  delete tag_;
  tag_ = tag;
  if (tag) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.CreateTagsResp.tag)
}

// -------------------------------------------------------------------

// GetTagsReq

// optional string access_token = 1;
inline bool GetTagsReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTagsReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTagsReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTagsReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetTagsReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagsReq.access_token)
  return *access_token_;
}
inline void GetTagsReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagsReq.access_token)
}
inline void GetTagsReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetTagsReq.access_token)
}
inline void GetTagsReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetTagsReq.access_token)
}
inline ::std::string* GetTagsReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagsReq.access_token)
  return access_token_;
}
inline ::std::string* GetTagsReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTagsReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagsReq.access_token)
}

// -------------------------------------------------------------------

// GetTagsResp

// optional int64 errcode = 1;
inline bool GetTagsResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTagsResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTagsResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTagsResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetTagsResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagsResp.errcode)
  return errcode_;
}
inline void GetTagsResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetTagsResp.errcode)
}

// optional string errmsg = 2;
inline bool GetTagsResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTagsResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTagsResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTagsResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetTagsResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagsResp.errmsg)
  return *errmsg_;
}
inline void GetTagsResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagsResp.errmsg)
}
inline void GetTagsResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetTagsResp.errmsg)
}
inline void GetTagsResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetTagsResp.errmsg)
}
inline ::std::string* GetTagsResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagsResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetTagsResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTagsResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagsResp.errmsg)
}

// repeated .mpcomm.Tag tags = 3;
inline int GetTagsResp::tags_size() const {
  return tags_.size();
}
inline void GetTagsResp::clear_tags() {
  tags_.Clear();
}
inline const ::mpcomm::Tag& GetTagsResp::tags(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagsResp.tags)
  return tags_.Get(index);
}
inline ::mpcomm::Tag* GetTagsResp::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagsResp.tags)
  return tags_.Mutable(index);
}
inline ::mpcomm::Tag* GetTagsResp::add_tags() {
  // @@protoc_insertion_point(field_add:mpcomm.GetTagsResp.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::Tag >&
GetTagsResp::tags() const {
  // @@protoc_insertion_point(field_list:mpcomm.GetTagsResp.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::Tag >*
GetTagsResp::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.GetTagsResp.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// UpdateTagsReq

// optional string access_token = 1;
inline bool UpdateTagsReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTagsReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTagsReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTagsReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UpdateTagsReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateTagsReq.access_token)
  return *access_token_;
}
inline void UpdateTagsReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateTagsReq.access_token)
}
inline void UpdateTagsReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateTagsReq.access_token)
}
inline void UpdateTagsReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateTagsReq.access_token)
}
inline ::std::string* UpdateTagsReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateTagsReq.access_token)
  return access_token_;
}
inline ::std::string* UpdateTagsReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateTagsReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateTagsReq.access_token)
}

// optional .mpcomm.Tag tag = 2;
inline bool UpdateTagsReq::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTagsReq::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTagsReq::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTagsReq::clear_tag() {
  if (tag_ != NULL) tag_->::mpcomm::Tag::Clear();
  clear_has_tag();
}
inline const ::mpcomm::Tag& UpdateTagsReq::tag() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateTagsReq.tag)
  return tag_ != NULL ? *tag_ : *default_instance_->tag_;
}
inline ::mpcomm::Tag* UpdateTagsReq::mutable_tag() {
  set_has_tag();
  if (tag_ == NULL) tag_ = new ::mpcomm::Tag;
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateTagsReq.tag)
  return tag_;
}
inline ::mpcomm::Tag* UpdateTagsReq::release_tag() {
  clear_has_tag();
  ::mpcomm::Tag* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline void UpdateTagsReq::set_allocated_tag(::mpcomm::Tag* tag) {
  delete tag_;
  tag_ = tag;
  if (tag) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateTagsReq.tag)
}

// -------------------------------------------------------------------

// UpdateTagsResp

// optional int64 errcode = 1;
inline bool UpdateTagsResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTagsResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTagsResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTagsResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 UpdateTagsResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateTagsResp.errcode)
  return errcode_;
}
inline void UpdateTagsResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UpdateTagsResp.errcode)
}

// optional string errmsg = 2;
inline bool UpdateTagsResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTagsResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTagsResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTagsResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& UpdateTagsResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateTagsResp.errmsg)
  return *errmsg_;
}
inline void UpdateTagsResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateTagsResp.errmsg)
}
inline void UpdateTagsResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateTagsResp.errmsg)
}
inline void UpdateTagsResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateTagsResp.errmsg)
}
inline ::std::string* UpdateTagsResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateTagsResp.errmsg)
  return errmsg_;
}
inline ::std::string* UpdateTagsResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateTagsResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateTagsResp.errmsg)
}

// -------------------------------------------------------------------

// UpdateTagsMembersReq

// optional string access_token = 1;
inline bool UpdateTagsMembersReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTagsMembersReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTagsMembersReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTagsMembersReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UpdateTagsMembersReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateTagsMembersReq.access_token)
  return *access_token_;
}
inline void UpdateTagsMembersReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateTagsMembersReq.access_token)
}
inline void UpdateTagsMembersReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateTagsMembersReq.access_token)
}
inline void UpdateTagsMembersReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateTagsMembersReq.access_token)
}
inline ::std::string* UpdateTagsMembersReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateTagsMembersReq.access_token)
  return access_token_;
}
inline ::std::string* UpdateTagsMembersReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateTagsMembersReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateTagsMembersReq.access_token)
}

// optional string openid = 2;
inline bool UpdateTagsMembersReq::has_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTagsMembersReq::set_has_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTagsMembersReq::clear_has_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTagsMembersReq::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& UpdateTagsMembersReq::openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateTagsMembersReq.openid)
  return *openid_;
}
inline void UpdateTagsMembersReq::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateTagsMembersReq.openid)
}
inline void UpdateTagsMembersReq::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateTagsMembersReq.openid)
}
inline void UpdateTagsMembersReq::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateTagsMembersReq.openid)
}
inline ::std::string* UpdateTagsMembersReq::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateTagsMembersReq.openid)
  return openid_;
}
inline ::std::string* UpdateTagsMembersReq::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateTagsMembersReq::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateTagsMembersReq.openid)
}

// optional string to_tagid = 3;
inline bool UpdateTagsMembersReq::has_to_tagid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateTagsMembersReq::set_has_to_tagid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateTagsMembersReq::clear_has_to_tagid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateTagsMembersReq::clear_to_tagid() {
  if (to_tagid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_->clear();
  }
  clear_has_to_tagid();
}
inline const ::std::string& UpdateTagsMembersReq::to_tagid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateTagsMembersReq.to_tagid)
  return *to_tagid_;
}
inline void UpdateTagsMembersReq::set_to_tagid(const ::std::string& value) {
  set_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_ = new ::std::string;
  }
  to_tagid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateTagsMembersReq.to_tagid)
}
inline void UpdateTagsMembersReq::set_to_tagid(const char* value) {
  set_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_ = new ::std::string;
  }
  to_tagid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateTagsMembersReq.to_tagid)
}
inline void UpdateTagsMembersReq::set_to_tagid(const char* value, size_t size) {
  set_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_ = new ::std::string;
  }
  to_tagid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateTagsMembersReq.to_tagid)
}
inline ::std::string* UpdateTagsMembersReq::mutable_to_tagid() {
  set_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateTagsMembersReq.to_tagid)
  return to_tagid_;
}
inline ::std::string* UpdateTagsMembersReq::release_to_tagid() {
  clear_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = to_tagid_;
    to_tagid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateTagsMembersReq::set_allocated_to_tagid(::std::string* to_tagid) {
  if (to_tagid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete to_tagid_;
  }
  if (to_tagid) {
    set_has_to_tagid();
    to_tagid_ = to_tagid;
  } else {
    clear_has_to_tagid();
    to_tagid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateTagsMembersReq.to_tagid)
}

// -------------------------------------------------------------------

// UpdateTagsMembersResp

// optional int64 errcode = 1;
inline bool UpdateTagsMembersResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateTagsMembersResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateTagsMembersResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateTagsMembersResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 UpdateTagsMembersResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateTagsMembersResp.errcode)
  return errcode_;
}
inline void UpdateTagsMembersResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UpdateTagsMembersResp.errcode)
}

// optional string errmsg = 2;
inline bool UpdateTagsMembersResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateTagsMembersResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateTagsMembersResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateTagsMembersResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& UpdateTagsMembersResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateTagsMembersResp.errmsg)
  return *errmsg_;
}
inline void UpdateTagsMembersResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateTagsMembersResp.errmsg)
}
inline void UpdateTagsMembersResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateTagsMembersResp.errmsg)
}
inline void UpdateTagsMembersResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateTagsMembersResp.errmsg)
}
inline ::std::string* UpdateTagsMembersResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateTagsMembersResp.errmsg)
  return errmsg_;
}
inline ::std::string* UpdateTagsMembersResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateTagsMembersResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateTagsMembersResp.errmsg)
}

// -------------------------------------------------------------------

// BatchUpdateTagsMembersReq

// optional string access_token = 1;
inline bool BatchUpdateTagsMembersReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchUpdateTagsMembersReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchUpdateTagsMembersReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchUpdateTagsMembersReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& BatchUpdateTagsMembersReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUpdateTagsMembersReq.access_token)
  return *access_token_;
}
inline void BatchUpdateTagsMembersReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchUpdateTagsMembersReq.access_token)
}
inline void BatchUpdateTagsMembersReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchUpdateTagsMembersReq.access_token)
}
inline void BatchUpdateTagsMembersReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchUpdateTagsMembersReq.access_token)
}
inline ::std::string* BatchUpdateTagsMembersReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchUpdateTagsMembersReq.access_token)
  return access_token_;
}
inline ::std::string* BatchUpdateTagsMembersReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchUpdateTagsMembersReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchUpdateTagsMembersReq.access_token)
}

// repeated string openid_list = 2;
inline int BatchUpdateTagsMembersReq::openid_list_size() const {
  return openid_list_.size();
}
inline void BatchUpdateTagsMembersReq::clear_openid_list() {
  openid_list_.Clear();
}
inline const ::std::string& BatchUpdateTagsMembersReq::openid_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUpdateTagsMembersReq.openid_list)
  return openid_list_.Get(index);
}
inline ::std::string* BatchUpdateTagsMembersReq::mutable_openid_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchUpdateTagsMembersReq.openid_list)
  return openid_list_.Mutable(index);
}
inline void BatchUpdateTagsMembersReq::set_openid_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mpcomm.BatchUpdateTagsMembersReq.openid_list)
  openid_list_.Mutable(index)->assign(value);
}
inline void BatchUpdateTagsMembersReq::set_openid_list(int index, const char* value) {
  openid_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchUpdateTagsMembersReq.openid_list)
}
inline void BatchUpdateTagsMembersReq::set_openid_list(int index, const char* value, size_t size) {
  openid_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchUpdateTagsMembersReq.openid_list)
}
inline ::std::string* BatchUpdateTagsMembersReq::add_openid_list() {
  return openid_list_.Add();
}
inline void BatchUpdateTagsMembersReq::add_openid_list(const ::std::string& value) {
  openid_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mpcomm.BatchUpdateTagsMembersReq.openid_list)
}
inline void BatchUpdateTagsMembersReq::add_openid_list(const char* value) {
  openid_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mpcomm.BatchUpdateTagsMembersReq.openid_list)
}
inline void BatchUpdateTagsMembersReq::add_openid_list(const char* value, size_t size) {
  openid_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mpcomm.BatchUpdateTagsMembersReq.openid_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchUpdateTagsMembersReq::openid_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.BatchUpdateTagsMembersReq.openid_list)
  return openid_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchUpdateTagsMembersReq::mutable_openid_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.BatchUpdateTagsMembersReq.openid_list)
  return &openid_list_;
}

// optional string to_tagid = 3;
inline bool BatchUpdateTagsMembersReq::has_to_tagid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatchUpdateTagsMembersReq::set_has_to_tagid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatchUpdateTagsMembersReq::clear_has_to_tagid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatchUpdateTagsMembersReq::clear_to_tagid() {
  if (to_tagid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_->clear();
  }
  clear_has_to_tagid();
}
inline const ::std::string& BatchUpdateTagsMembersReq::to_tagid() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUpdateTagsMembersReq.to_tagid)
  return *to_tagid_;
}
inline void BatchUpdateTagsMembersReq::set_to_tagid(const ::std::string& value) {
  set_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_ = new ::std::string;
  }
  to_tagid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchUpdateTagsMembersReq.to_tagid)
}
inline void BatchUpdateTagsMembersReq::set_to_tagid(const char* value) {
  set_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_ = new ::std::string;
  }
  to_tagid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchUpdateTagsMembersReq.to_tagid)
}
inline void BatchUpdateTagsMembersReq::set_to_tagid(const char* value, size_t size) {
  set_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_ = new ::std::string;
  }
  to_tagid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchUpdateTagsMembersReq.to_tagid)
}
inline ::std::string* BatchUpdateTagsMembersReq::mutable_to_tagid() {
  set_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_tagid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchUpdateTagsMembersReq.to_tagid)
  return to_tagid_;
}
inline ::std::string* BatchUpdateTagsMembersReq::release_to_tagid() {
  clear_has_to_tagid();
  if (to_tagid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = to_tagid_;
    to_tagid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchUpdateTagsMembersReq::set_allocated_to_tagid(::std::string* to_tagid) {
  if (to_tagid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete to_tagid_;
  }
  if (to_tagid) {
    set_has_to_tagid();
    to_tagid_ = to_tagid;
  } else {
    clear_has_to_tagid();
    to_tagid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchUpdateTagsMembersReq.to_tagid)
}

// -------------------------------------------------------------------

// BatchUpdateTagsMembersResp

// optional int64 errcode = 1;
inline bool BatchUpdateTagsMembersResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchUpdateTagsMembersResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchUpdateTagsMembersResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchUpdateTagsMembersResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 BatchUpdateTagsMembersResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUpdateTagsMembersResp.errcode)
  return errcode_;
}
inline void BatchUpdateTagsMembersResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchUpdateTagsMembersResp.errcode)
}

// optional string errmsg = 2;
inline bool BatchUpdateTagsMembersResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchUpdateTagsMembersResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchUpdateTagsMembersResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchUpdateTagsMembersResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& BatchUpdateTagsMembersResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUpdateTagsMembersResp.errmsg)
  return *errmsg_;
}
inline void BatchUpdateTagsMembersResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchUpdateTagsMembersResp.errmsg)
}
inline void BatchUpdateTagsMembersResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchUpdateTagsMembersResp.errmsg)
}
inline void BatchUpdateTagsMembersResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchUpdateTagsMembersResp.errmsg)
}
inline ::std::string* BatchUpdateTagsMembersResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchUpdateTagsMembersResp.errmsg)
  return errmsg_;
}
inline ::std::string* BatchUpdateTagsMembersResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchUpdateTagsMembersResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchUpdateTagsMembersResp.errmsg)
}

// -------------------------------------------------------------------

// DeleteTagsReq

// optional string access_token = 1;
inline bool DeleteTagsReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteTagsReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteTagsReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteTagsReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& DeleteTagsReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.DeleteTagsReq.access_token)
  return *access_token_;
}
inline void DeleteTagsReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DeleteTagsReq.access_token)
}
inline void DeleteTagsReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DeleteTagsReq.access_token)
}
inline void DeleteTagsReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DeleteTagsReq.access_token)
}
inline ::std::string* DeleteTagsReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DeleteTagsReq.access_token)
  return access_token_;
}
inline ::std::string* DeleteTagsReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteTagsReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DeleteTagsReq.access_token)
}

// optional .mpcomm.Tag tag = 2;
inline bool DeleteTagsReq::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteTagsReq::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteTagsReq::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteTagsReq::clear_tag() {
  if (tag_ != NULL) tag_->::mpcomm::Tag::Clear();
  clear_has_tag();
}
inline const ::mpcomm::Tag& DeleteTagsReq::tag() const {
  // @@protoc_insertion_point(field_get:mpcomm.DeleteTagsReq.tag)
  return tag_ != NULL ? *tag_ : *default_instance_->tag_;
}
inline ::mpcomm::Tag* DeleteTagsReq::mutable_tag() {
  set_has_tag();
  if (tag_ == NULL) tag_ = new ::mpcomm::Tag;
  // @@protoc_insertion_point(field_mutable:mpcomm.DeleteTagsReq.tag)
  return tag_;
}
inline ::mpcomm::Tag* DeleteTagsReq::release_tag() {
  clear_has_tag();
  ::mpcomm::Tag* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline void DeleteTagsReq::set_allocated_tag(::mpcomm::Tag* tag) {
  delete tag_;
  tag_ = tag;
  if (tag) {
    set_has_tag();
  } else {
    clear_has_tag();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DeleteTagsReq.tag)
}

// -------------------------------------------------------------------

// DeleteTagsResp

// optional int64 errcode = 1;
inline bool DeleteTagsResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteTagsResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteTagsResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteTagsResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 DeleteTagsResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.DeleteTagsResp.errcode)
  return errcode_;
}
inline void DeleteTagsResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.DeleteTagsResp.errcode)
}

// optional string errmsg = 2;
inline bool DeleteTagsResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteTagsResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteTagsResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteTagsResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& DeleteTagsResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.DeleteTagsResp.errmsg)
  return *errmsg_;
}
inline void DeleteTagsResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.DeleteTagsResp.errmsg)
}
inline void DeleteTagsResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.DeleteTagsResp.errmsg)
}
inline void DeleteTagsResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.DeleteTagsResp.errmsg)
}
inline ::std::string* DeleteTagsResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.DeleteTagsResp.errmsg)
  return errmsg_;
}
inline ::std::string* DeleteTagsResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteTagsResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.DeleteTagsResp.errmsg)
}

// -------------------------------------------------------------------

// TagUserData

// repeated string openid = 1;
inline int TagUserData::openid_size() const {
  return openid_.size();
}
inline void TagUserData::clear_openid() {
  openid_.Clear();
}
inline const ::std::string& TagUserData::openid(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.TagUserData.openid)
  return openid_.Get(index);
}
inline ::std::string* TagUserData::mutable_openid(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.TagUserData.openid)
  return openid_.Mutable(index);
}
inline void TagUserData::set_openid(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mpcomm.TagUserData.openid)
  openid_.Mutable(index)->assign(value);
}
inline void TagUserData::set_openid(int index, const char* value) {
  openid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.TagUserData.openid)
}
inline void TagUserData::set_openid(int index, const char* value, size_t size) {
  openid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.TagUserData.openid)
}
inline ::std::string* TagUserData::add_openid() {
  return openid_.Add();
}
inline void TagUserData::add_openid(const ::std::string& value) {
  openid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mpcomm.TagUserData.openid)
}
inline void TagUserData::add_openid(const char* value) {
  openid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mpcomm.TagUserData.openid)
}
inline void TagUserData::add_openid(const char* value, size_t size) {
  openid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mpcomm.TagUserData.openid)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TagUserData::openid() const {
  // @@protoc_insertion_point(field_list:mpcomm.TagUserData.openid)
  return openid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TagUserData::mutable_openid() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.TagUserData.openid)
  return &openid_;
}

// -------------------------------------------------------------------

// GetTagUserReq

// optional string access_token = 1;
inline bool GetTagUserReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTagUserReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTagUserReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTagUserReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetTagUserReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagUserReq.access_token)
  return *access_token_;
}
inline void GetTagUserReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagUserReq.access_token)
}
inline void GetTagUserReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetTagUserReq.access_token)
}
inline void GetTagUserReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetTagUserReq.access_token)
}
inline ::std::string* GetTagUserReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagUserReq.access_token)
  return access_token_;
}
inline ::std::string* GetTagUserReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTagUserReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagUserReq.access_token)
}

// optional uint64 tagid = 2;
inline bool GetTagUserReq::has_tagid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTagUserReq::set_has_tagid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTagUserReq::clear_has_tagid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTagUserReq::clear_tagid() {
  tagid_ = GOOGLE_ULONGLONG(0);
  clear_has_tagid();
}
inline ::google::protobuf::uint64 GetTagUserReq::tagid() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagUserReq.tagid)
  return tagid_;
}
inline void GetTagUserReq::set_tagid(::google::protobuf::uint64 value) {
  set_has_tagid();
  tagid_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetTagUserReq.tagid)
}

// optional string next_openid = 3;
inline bool GetTagUserReq::has_next_openid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTagUserReq::set_has_next_openid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTagUserReq::clear_has_next_openid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTagUserReq::clear_next_openid() {
  if (next_openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_->clear();
  }
  clear_has_next_openid();
}
inline const ::std::string& GetTagUserReq::next_openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagUserReq.next_openid)
  return *next_openid_;
}
inline void GetTagUserReq::set_next_openid(const ::std::string& value) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagUserReq.next_openid)
}
inline void GetTagUserReq::set_next_openid(const char* value) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetTagUserReq.next_openid)
}
inline void GetTagUserReq::set_next_openid(const char* value, size_t size) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetTagUserReq.next_openid)
}
inline ::std::string* GetTagUserReq::mutable_next_openid() {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagUserReq.next_openid)
  return next_openid_;
}
inline ::std::string* GetTagUserReq::release_next_openid() {
  clear_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = next_openid_;
    next_openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTagUserReq::set_allocated_next_openid(::std::string* next_openid) {
  if (next_openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete next_openid_;
  }
  if (next_openid) {
    set_has_next_openid();
    next_openid_ = next_openid;
  } else {
    clear_has_next_openid();
    next_openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagUserReq.next_openid)
}

// -------------------------------------------------------------------

// GetTagUserResp

// optional int64 errcode = 1;
inline bool GetTagUserResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTagUserResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTagUserResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTagUserResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetTagUserResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagUserResp.errcode)
  return errcode_;
}
inline void GetTagUserResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetTagUserResp.errcode)
}

// optional string errmsg = 2;
inline bool GetTagUserResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTagUserResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTagUserResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTagUserResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetTagUserResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagUserResp.errmsg)
  return *errmsg_;
}
inline void GetTagUserResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagUserResp.errmsg)
}
inline void GetTagUserResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetTagUserResp.errmsg)
}
inline void GetTagUserResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetTagUserResp.errmsg)
}
inline ::std::string* GetTagUserResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagUserResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetTagUserResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTagUserResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagUserResp.errmsg)
}

// optional uint64 count = 3;
inline bool GetTagUserResp::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTagUserResp::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTagUserResp::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTagUserResp::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::uint64 GetTagUserResp::count() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagUserResp.count)
  return count_;
}
inline void GetTagUserResp::set_count(::google::protobuf::uint64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetTagUserResp.count)
}

// optional .mpcomm.TagUserData data = 4;
inline bool GetTagUserResp::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetTagUserResp::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetTagUserResp::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetTagUserResp::clear_data() {
  if (data_ != NULL) data_->::mpcomm::TagUserData::Clear();
  clear_has_data();
}
inline const ::mpcomm::TagUserData& GetTagUserResp::data() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagUserResp.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::mpcomm::TagUserData* GetTagUserResp::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::mpcomm::TagUserData;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagUserResp.data)
  return data_;
}
inline ::mpcomm::TagUserData* GetTagUserResp::release_data() {
  clear_has_data();
  ::mpcomm::TagUserData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void GetTagUserResp::set_allocated_data(::mpcomm::TagUserData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagUserResp.data)
}

// optional string next_openid = 5;
inline bool GetTagUserResp::has_next_openid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetTagUserResp::set_has_next_openid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetTagUserResp::clear_has_next_openid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetTagUserResp::clear_next_openid() {
  if (next_openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_->clear();
  }
  clear_has_next_openid();
}
inline const ::std::string& GetTagUserResp::next_openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagUserResp.next_openid)
  return *next_openid_;
}
inline void GetTagUserResp::set_next_openid(const ::std::string& value) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagUserResp.next_openid)
}
inline void GetTagUserResp::set_next_openid(const char* value) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetTagUserResp.next_openid)
}
inline void GetTagUserResp::set_next_openid(const char* value, size_t size) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetTagUserResp.next_openid)
}
inline ::std::string* GetTagUserResp::mutable_next_openid() {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagUserResp.next_openid)
  return next_openid_;
}
inline ::std::string* GetTagUserResp::release_next_openid() {
  clear_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = next_openid_;
    next_openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTagUserResp::set_allocated_next_openid(::std::string* next_openid) {
  if (next_openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete next_openid_;
  }
  if (next_openid) {
    set_has_next_openid();
    next_openid_ = next_openid;
  } else {
    clear_has_next_openid();
    next_openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagUserResp.next_openid)
}

// -------------------------------------------------------------------

// BatchTaggingMembersReq

// optional string access_token = 1;
inline bool BatchTaggingMembersReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchTaggingMembersReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchTaggingMembersReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchTaggingMembersReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& BatchTaggingMembersReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchTaggingMembersReq.access_token)
  return *access_token_;
}
inline void BatchTaggingMembersReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchTaggingMembersReq.access_token)
}
inline void BatchTaggingMembersReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchTaggingMembersReq.access_token)
}
inline void BatchTaggingMembersReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchTaggingMembersReq.access_token)
}
inline ::std::string* BatchTaggingMembersReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchTaggingMembersReq.access_token)
  return access_token_;
}
inline ::std::string* BatchTaggingMembersReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchTaggingMembersReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchTaggingMembersReq.access_token)
}

// repeated string openid_list = 2;
inline int BatchTaggingMembersReq::openid_list_size() const {
  return openid_list_.size();
}
inline void BatchTaggingMembersReq::clear_openid_list() {
  openid_list_.Clear();
}
inline const ::std::string& BatchTaggingMembersReq::openid_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchTaggingMembersReq.openid_list)
  return openid_list_.Get(index);
}
inline ::std::string* BatchTaggingMembersReq::mutable_openid_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchTaggingMembersReq.openid_list)
  return openid_list_.Mutable(index);
}
inline void BatchTaggingMembersReq::set_openid_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mpcomm.BatchTaggingMembersReq.openid_list)
  openid_list_.Mutable(index)->assign(value);
}
inline void BatchTaggingMembersReq::set_openid_list(int index, const char* value) {
  openid_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchTaggingMembersReq.openid_list)
}
inline void BatchTaggingMembersReq::set_openid_list(int index, const char* value, size_t size) {
  openid_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchTaggingMembersReq.openid_list)
}
inline ::std::string* BatchTaggingMembersReq::add_openid_list() {
  return openid_list_.Add();
}
inline void BatchTaggingMembersReq::add_openid_list(const ::std::string& value) {
  openid_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mpcomm.BatchTaggingMembersReq.openid_list)
}
inline void BatchTaggingMembersReq::add_openid_list(const char* value) {
  openid_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mpcomm.BatchTaggingMembersReq.openid_list)
}
inline void BatchTaggingMembersReq::add_openid_list(const char* value, size_t size) {
  openid_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mpcomm.BatchTaggingMembersReq.openid_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchTaggingMembersReq::openid_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.BatchTaggingMembersReq.openid_list)
  return openid_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchTaggingMembersReq::mutable_openid_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.BatchTaggingMembersReq.openid_list)
  return &openid_list_;
}

// optional uint64 tagid = 3;
inline bool BatchTaggingMembersReq::has_tagid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatchTaggingMembersReq::set_has_tagid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatchTaggingMembersReq::clear_has_tagid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatchTaggingMembersReq::clear_tagid() {
  tagid_ = GOOGLE_ULONGLONG(0);
  clear_has_tagid();
}
inline ::google::protobuf::uint64 BatchTaggingMembersReq::tagid() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchTaggingMembersReq.tagid)
  return tagid_;
}
inline void BatchTaggingMembersReq::set_tagid(::google::protobuf::uint64 value) {
  set_has_tagid();
  tagid_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchTaggingMembersReq.tagid)
}

// -------------------------------------------------------------------

// BatchTaggingMembersResp

// optional int64 errcode = 1;
inline bool BatchTaggingMembersResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchTaggingMembersResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchTaggingMembersResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchTaggingMembersResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 BatchTaggingMembersResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchTaggingMembersResp.errcode)
  return errcode_;
}
inline void BatchTaggingMembersResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchTaggingMembersResp.errcode)
}

// optional string errmsg = 2;
inline bool BatchTaggingMembersResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchTaggingMembersResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchTaggingMembersResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchTaggingMembersResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& BatchTaggingMembersResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchTaggingMembersResp.errmsg)
  return *errmsg_;
}
inline void BatchTaggingMembersResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchTaggingMembersResp.errmsg)
}
inline void BatchTaggingMembersResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchTaggingMembersResp.errmsg)
}
inline void BatchTaggingMembersResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchTaggingMembersResp.errmsg)
}
inline ::std::string* BatchTaggingMembersResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchTaggingMembersResp.errmsg)
  return errmsg_;
}
inline ::std::string* BatchTaggingMembersResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchTaggingMembersResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchTaggingMembersResp.errmsg)
}

// -------------------------------------------------------------------

// BatchUnTaggingMembersReq

// optional string access_token = 1;
inline bool BatchUnTaggingMembersReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchUnTaggingMembersReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchUnTaggingMembersReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchUnTaggingMembersReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& BatchUnTaggingMembersReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUnTaggingMembersReq.access_token)
  return *access_token_;
}
inline void BatchUnTaggingMembersReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchUnTaggingMembersReq.access_token)
}
inline void BatchUnTaggingMembersReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchUnTaggingMembersReq.access_token)
}
inline void BatchUnTaggingMembersReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchUnTaggingMembersReq.access_token)
}
inline ::std::string* BatchUnTaggingMembersReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchUnTaggingMembersReq.access_token)
  return access_token_;
}
inline ::std::string* BatchUnTaggingMembersReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchUnTaggingMembersReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchUnTaggingMembersReq.access_token)
}

// repeated string openid_list = 2;
inline int BatchUnTaggingMembersReq::openid_list_size() const {
  return openid_list_.size();
}
inline void BatchUnTaggingMembersReq::clear_openid_list() {
  openid_list_.Clear();
}
inline const ::std::string& BatchUnTaggingMembersReq::openid_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUnTaggingMembersReq.openid_list)
  return openid_list_.Get(index);
}
inline ::std::string* BatchUnTaggingMembersReq::mutable_openid_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchUnTaggingMembersReq.openid_list)
  return openid_list_.Mutable(index);
}
inline void BatchUnTaggingMembersReq::set_openid_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mpcomm.BatchUnTaggingMembersReq.openid_list)
  openid_list_.Mutable(index)->assign(value);
}
inline void BatchUnTaggingMembersReq::set_openid_list(int index, const char* value) {
  openid_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchUnTaggingMembersReq.openid_list)
}
inline void BatchUnTaggingMembersReq::set_openid_list(int index, const char* value, size_t size) {
  openid_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchUnTaggingMembersReq.openid_list)
}
inline ::std::string* BatchUnTaggingMembersReq::add_openid_list() {
  return openid_list_.Add();
}
inline void BatchUnTaggingMembersReq::add_openid_list(const ::std::string& value) {
  openid_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mpcomm.BatchUnTaggingMembersReq.openid_list)
}
inline void BatchUnTaggingMembersReq::add_openid_list(const char* value) {
  openid_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mpcomm.BatchUnTaggingMembersReq.openid_list)
}
inline void BatchUnTaggingMembersReq::add_openid_list(const char* value, size_t size) {
  openid_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mpcomm.BatchUnTaggingMembersReq.openid_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchUnTaggingMembersReq::openid_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.BatchUnTaggingMembersReq.openid_list)
  return openid_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchUnTaggingMembersReq::mutable_openid_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.BatchUnTaggingMembersReq.openid_list)
  return &openid_list_;
}

// optional uint64 tagid = 3;
inline bool BatchUnTaggingMembersReq::has_tagid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatchUnTaggingMembersReq::set_has_tagid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatchUnTaggingMembersReq::clear_has_tagid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatchUnTaggingMembersReq::clear_tagid() {
  tagid_ = GOOGLE_ULONGLONG(0);
  clear_has_tagid();
}
inline ::google::protobuf::uint64 BatchUnTaggingMembersReq::tagid() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUnTaggingMembersReq.tagid)
  return tagid_;
}
inline void BatchUnTaggingMembersReq::set_tagid(::google::protobuf::uint64 value) {
  set_has_tagid();
  tagid_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchUnTaggingMembersReq.tagid)
}

// -------------------------------------------------------------------

// BatchUnTaggingMembersResp

// optional int64 errcode = 1;
inline bool BatchUnTaggingMembersResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchUnTaggingMembersResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchUnTaggingMembersResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchUnTaggingMembersResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 BatchUnTaggingMembersResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUnTaggingMembersResp.errcode)
  return errcode_;
}
inline void BatchUnTaggingMembersResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchUnTaggingMembersResp.errcode)
}

// optional string errmsg = 2;
inline bool BatchUnTaggingMembersResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchUnTaggingMembersResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchUnTaggingMembersResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchUnTaggingMembersResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& BatchUnTaggingMembersResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchUnTaggingMembersResp.errmsg)
  return *errmsg_;
}
inline void BatchUnTaggingMembersResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchUnTaggingMembersResp.errmsg)
}
inline void BatchUnTaggingMembersResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchUnTaggingMembersResp.errmsg)
}
inline void BatchUnTaggingMembersResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchUnTaggingMembersResp.errmsg)
}
inline ::std::string* BatchUnTaggingMembersResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchUnTaggingMembersResp.errmsg)
  return errmsg_;
}
inline ::std::string* BatchUnTaggingMembersResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchUnTaggingMembersResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchUnTaggingMembersResp.errmsg)
}

// -------------------------------------------------------------------

// GetTagsIdListReq

// optional string access_token = 1;
inline bool GetTagsIdListReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTagsIdListReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTagsIdListReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTagsIdListReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetTagsIdListReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagsIdListReq.access_token)
  return *access_token_;
}
inline void GetTagsIdListReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagsIdListReq.access_token)
}
inline void GetTagsIdListReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetTagsIdListReq.access_token)
}
inline void GetTagsIdListReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetTagsIdListReq.access_token)
}
inline ::std::string* GetTagsIdListReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagsIdListReq.access_token)
  return access_token_;
}
inline ::std::string* GetTagsIdListReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTagsIdListReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagsIdListReq.access_token)
}

// optional string openid = 2;
inline bool GetTagsIdListReq::has_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTagsIdListReq::set_has_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTagsIdListReq::clear_has_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTagsIdListReq::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& GetTagsIdListReq::openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagsIdListReq.openid)
  return *openid_;
}
inline void GetTagsIdListReq::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagsIdListReq.openid)
}
inline void GetTagsIdListReq::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetTagsIdListReq.openid)
}
inline void GetTagsIdListReq::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetTagsIdListReq.openid)
}
inline ::std::string* GetTagsIdListReq::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagsIdListReq.openid)
  return openid_;
}
inline ::std::string* GetTagsIdListReq::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTagsIdListReq::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagsIdListReq.openid)
}

// -------------------------------------------------------------------

// GetTagsIdListResp

// optional int64 errcode = 1;
inline bool GetTagsIdListResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTagsIdListResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTagsIdListResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTagsIdListResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetTagsIdListResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagsIdListResp.errcode)
  return errcode_;
}
inline void GetTagsIdListResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetTagsIdListResp.errcode)
}

// optional string errmsg = 2;
inline bool GetTagsIdListResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTagsIdListResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTagsIdListResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTagsIdListResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetTagsIdListResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagsIdListResp.errmsg)
  return *errmsg_;
}
inline void GetTagsIdListResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagsIdListResp.errmsg)
}
inline void GetTagsIdListResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetTagsIdListResp.errmsg)
}
inline void GetTagsIdListResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetTagsIdListResp.errmsg)
}
inline ::std::string* GetTagsIdListResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetTagsIdListResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetTagsIdListResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetTagsIdListResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetTagsIdListResp.errmsg)
}

// repeated uint64 tagid_list = 3;
inline int GetTagsIdListResp::tagid_list_size() const {
  return tagid_list_.size();
}
inline void GetTagsIdListResp::clear_tagid_list() {
  tagid_list_.Clear();
}
inline ::google::protobuf::uint64 GetTagsIdListResp::tagid_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.GetTagsIdListResp.tagid_list)
  return tagid_list_.Get(index);
}
inline void GetTagsIdListResp::set_tagid_list(int index, ::google::protobuf::uint64 value) {
  tagid_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:mpcomm.GetTagsIdListResp.tagid_list)
}
inline void GetTagsIdListResp::add_tagid_list(::google::protobuf::uint64 value) {
  tagid_list_.Add(value);
  // @@protoc_insertion_point(field_add:mpcomm.GetTagsIdListResp.tagid_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetTagsIdListResp::tagid_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.GetTagsIdListResp.tagid_list)
  return tagid_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetTagsIdListResp::mutable_tagid_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.GetTagsIdListResp.tagid_list)
  return &tagid_list_;
}

// -------------------------------------------------------------------

// UpdateUserInfoRemarkReq

// optional string access_token = 1;
inline bool UpdateUserInfoRemarkReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserInfoRemarkReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserInfoRemarkReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserInfoRemarkReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UpdateUserInfoRemarkReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateUserInfoRemarkReq.access_token)
  return *access_token_;
}
inline void UpdateUserInfoRemarkReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateUserInfoRemarkReq.access_token)
}
inline void UpdateUserInfoRemarkReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateUserInfoRemarkReq.access_token)
}
inline void UpdateUserInfoRemarkReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateUserInfoRemarkReq.access_token)
}
inline ::std::string* UpdateUserInfoRemarkReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateUserInfoRemarkReq.access_token)
  return access_token_;
}
inline ::std::string* UpdateUserInfoRemarkReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserInfoRemarkReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateUserInfoRemarkReq.access_token)
}

// optional string openid = 2;
inline bool UpdateUserInfoRemarkReq::has_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateUserInfoRemarkReq::set_has_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateUserInfoRemarkReq::clear_has_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateUserInfoRemarkReq::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& UpdateUserInfoRemarkReq::openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateUserInfoRemarkReq.openid)
  return *openid_;
}
inline void UpdateUserInfoRemarkReq::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateUserInfoRemarkReq.openid)
}
inline void UpdateUserInfoRemarkReq::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateUserInfoRemarkReq.openid)
}
inline void UpdateUserInfoRemarkReq::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateUserInfoRemarkReq.openid)
}
inline ::std::string* UpdateUserInfoRemarkReq::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateUserInfoRemarkReq.openid)
  return openid_;
}
inline ::std::string* UpdateUserInfoRemarkReq::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserInfoRemarkReq::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateUserInfoRemarkReq.openid)
}

// optional string remark = 3;
inline bool UpdateUserInfoRemarkReq::has_remark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateUserInfoRemarkReq::set_has_remark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateUserInfoRemarkReq::clear_has_remark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateUserInfoRemarkReq::clear_remark() {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& UpdateUserInfoRemarkReq::remark() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateUserInfoRemarkReq.remark)
  return *remark_;
}
inline void UpdateUserInfoRemarkReq::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateUserInfoRemarkReq.remark)
}
inline void UpdateUserInfoRemarkReq::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateUserInfoRemarkReq.remark)
}
inline void UpdateUserInfoRemarkReq::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateUserInfoRemarkReq.remark)
}
inline ::std::string* UpdateUserInfoRemarkReq::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateUserInfoRemarkReq.remark)
  return remark_;
}
inline ::std::string* UpdateUserInfoRemarkReq::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserInfoRemarkReq::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateUserInfoRemarkReq.remark)
}

// -------------------------------------------------------------------

// UpdateUserInfoRemarkResp

// optional int64 errcode = 1;
inline bool UpdateUserInfoRemarkResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserInfoRemarkResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserInfoRemarkResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserInfoRemarkResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 UpdateUserInfoRemarkResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateUserInfoRemarkResp.errcode)
  return errcode_;
}
inline void UpdateUserInfoRemarkResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UpdateUserInfoRemarkResp.errcode)
}

// optional string errmsg = 2;
inline bool UpdateUserInfoRemarkResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateUserInfoRemarkResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateUserInfoRemarkResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateUserInfoRemarkResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& UpdateUserInfoRemarkResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.UpdateUserInfoRemarkResp.errmsg)
  return *errmsg_;
}
inline void UpdateUserInfoRemarkResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UpdateUserInfoRemarkResp.errmsg)
}
inline void UpdateUserInfoRemarkResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UpdateUserInfoRemarkResp.errmsg)
}
inline void UpdateUserInfoRemarkResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UpdateUserInfoRemarkResp.errmsg)
}
inline ::std::string* UpdateUserInfoRemarkResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UpdateUserInfoRemarkResp.errmsg)
  return errmsg_;
}
inline ::std::string* UpdateUserInfoRemarkResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpdateUserInfoRemarkResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UpdateUserInfoRemarkResp.errmsg)
}

// -------------------------------------------------------------------

// UserInfoReq

// optional string access_token = 1;
inline bool UserInfoReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UserInfoReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoReq.access_token)
  return *access_token_;
}
inline void UserInfoReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoReq.access_token)
}
inline void UserInfoReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoReq.access_token)
}
inline void UserInfoReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoReq.access_token)
}
inline ::std::string* UserInfoReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoReq.access_token)
  return access_token_;
}
inline ::std::string* UserInfoReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoReq.access_token)
}

// optional string openid = 2;
inline bool UserInfoReq::has_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoReq::set_has_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoReq::clear_has_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoReq::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& UserInfoReq::openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoReq.openid)
  return *openid_;
}
inline void UserInfoReq::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoReq.openid)
}
inline void UserInfoReq::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoReq.openid)
}
inline void UserInfoReq::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoReq.openid)
}
inline ::std::string* UserInfoReq::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoReq.openid)
  return openid_;
}
inline ::std::string* UserInfoReq::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoReq::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoReq.openid)
}

// optional string lang = 3;
inline bool UserInfoReq::has_lang() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoReq::set_has_lang() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoReq::clear_has_lang() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoReq::clear_lang() {
  if (lang_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_->clear();
  }
  clear_has_lang();
}
inline const ::std::string& UserInfoReq::lang() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoReq.lang)
  return *lang_;
}
inline void UserInfoReq::set_lang(const ::std::string& value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoReq.lang)
}
inline void UserInfoReq::set_lang(const char* value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoReq.lang)
}
inline void UserInfoReq::set_lang(const char* value, size_t size) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_ = new ::std::string;
  }
  lang_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoReq.lang)
}
inline ::std::string* UserInfoReq::mutable_lang() {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoReq.lang)
  return lang_;
}
inline ::std::string* UserInfoReq::release_lang() {
  clear_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lang_;
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoReq::set_allocated_lang(::std::string* lang) {
  if (lang_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lang_;
  }
  if (lang) {
    set_has_lang();
    lang_ = lang;
  } else {
    clear_has_lang();
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoReq.lang)
}

// -------------------------------------------------------------------

// UserInfoResp

// optional int64 errcode = 1;
inline bool UserInfoResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 UserInfoResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.errcode)
  return errcode_;
}
inline void UserInfoResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.errcode)
}

// optional string errmsg = 2;
inline bool UserInfoResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& UserInfoResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.errmsg)
  return *errmsg_;
}
inline void UserInfoResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.errmsg)
}
inline void UserInfoResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.errmsg)
}
inline void UserInfoResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.errmsg)
}
inline ::std::string* UserInfoResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.errmsg)
  return errmsg_;
}
inline ::std::string* UserInfoResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.errmsg)
}

// optional uint64 subscribe = 3;
inline bool UserInfoResp::has_subscribe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoResp::set_has_subscribe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoResp::clear_has_subscribe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoResp::clear_subscribe() {
  subscribe_ = GOOGLE_ULONGLONG(0);
  clear_has_subscribe();
}
inline ::google::protobuf::uint64 UserInfoResp::subscribe() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.subscribe)
  return subscribe_;
}
inline void UserInfoResp::set_subscribe(::google::protobuf::uint64 value) {
  set_has_subscribe();
  subscribe_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.subscribe)
}

// optional string openid = 4;
inline bool UserInfoResp::has_openid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoResp::set_has_openid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoResp::clear_has_openid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoResp::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& UserInfoResp::openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.openid)
  return *openid_;
}
inline void UserInfoResp::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.openid)
}
inline void UserInfoResp::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.openid)
}
inline void UserInfoResp::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.openid)
}
inline ::std::string* UserInfoResp::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.openid)
  return openid_;
}
inline ::std::string* UserInfoResp::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.openid)
}

// optional string nickname = 5;
inline bool UserInfoResp::has_nickname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfoResp::set_has_nickname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfoResp::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfoResp::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& UserInfoResp::nickname() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.nickname)
  return *nickname_;
}
inline void UserInfoResp::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.nickname)
}
inline void UserInfoResp::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.nickname)
}
inline void UserInfoResp::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.nickname)
}
inline ::std::string* UserInfoResp::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.nickname)
  return nickname_;
}
inline ::std::string* UserInfoResp::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.nickname)
}

// optional uint64 sex = 6;
inline bool UserInfoResp::has_sex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfoResp::set_has_sex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfoResp::clear_has_sex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfoResp::clear_sex() {
  sex_ = GOOGLE_ULONGLONG(0);
  clear_has_sex();
}
inline ::google::protobuf::uint64 UserInfoResp::sex() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.sex)
  return sex_;
}
inline void UserInfoResp::set_sex(::google::protobuf::uint64 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.sex)
}

// optional string language = 7;
inline bool UserInfoResp::has_language() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfoResp::set_has_language() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfoResp::clear_has_language() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfoResp::clear_language() {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& UserInfoResp::language() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.language)
  return *language_;
}
inline void UserInfoResp::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.language)
}
inline void UserInfoResp::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.language)
}
inline void UserInfoResp::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.language)
}
inline ::std::string* UserInfoResp::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.language)
  return language_;
}
inline ::std::string* UserInfoResp::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.language)
}

// optional string city = 8;
inline bool UserInfoResp::has_city() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfoResp::set_has_city() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfoResp::clear_has_city() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfoResp::clear_city() {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& UserInfoResp::city() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.city)
  return *city_;
}
inline void UserInfoResp::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.city)
}
inline void UserInfoResp::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.city)
}
inline void UserInfoResp::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.city)
}
inline ::std::string* UserInfoResp::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.city)
  return city_;
}
inline ::std::string* UserInfoResp::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.city)
}

// optional string province = 9;
inline bool UserInfoResp::has_province() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfoResp::set_has_province() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfoResp::clear_has_province() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfoResp::clear_province() {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& UserInfoResp::province() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.province)
  return *province_;
}
inline void UserInfoResp::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.province)
}
inline void UserInfoResp::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.province)
}
inline void UserInfoResp::set_province(const char* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.province)
}
inline ::std::string* UserInfoResp::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.province)
  return province_;
}
inline ::std::string* UserInfoResp::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_province(::std::string* province) {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete province_;
  }
  if (province) {
    set_has_province();
    province_ = province;
  } else {
    clear_has_province();
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.province)
}

// optional string country = 10;
inline bool UserInfoResp::has_country() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfoResp::set_has_country() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfoResp::clear_has_country() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfoResp::clear_country() {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& UserInfoResp::country() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.country)
  return *country_;
}
inline void UserInfoResp::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.country)
}
inline void UserInfoResp::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.country)
}
inline void UserInfoResp::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.country)
}
inline ::std::string* UserInfoResp::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.country)
  return country_;
}
inline ::std::string* UserInfoResp::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.country)
}

// optional string headimgurl = 11;
inline bool UserInfoResp::has_headimgurl() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfoResp::set_has_headimgurl() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfoResp::clear_has_headimgurl() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfoResp::clear_headimgurl() {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_->clear();
  }
  clear_has_headimgurl();
}
inline const ::std::string& UserInfoResp::headimgurl() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.headimgurl)
  return *headimgurl_;
}
inline void UserInfoResp::set_headimgurl(const ::std::string& value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.headimgurl)
}
inline void UserInfoResp::set_headimgurl(const char* value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.headimgurl)
}
inline void UserInfoResp::set_headimgurl(const char* value, size_t size) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.headimgurl)
}
inline ::std::string* UserInfoResp::mutable_headimgurl() {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.headimgurl)
  return headimgurl_;
}
inline ::std::string* UserInfoResp::release_headimgurl() {
  clear_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headimgurl_;
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_headimgurl(::std::string* headimgurl) {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headimgurl_;
  }
  if (headimgurl) {
    set_has_headimgurl();
    headimgurl_ = headimgurl;
  } else {
    clear_has_headimgurl();
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.headimgurl)
}

// optional uint64 subscribe_time = 12;
inline bool UserInfoResp::has_subscribe_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfoResp::set_has_subscribe_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfoResp::clear_has_subscribe_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfoResp::clear_subscribe_time() {
  subscribe_time_ = GOOGLE_ULONGLONG(0);
  clear_has_subscribe_time();
}
inline ::google::protobuf::uint64 UserInfoResp::subscribe_time() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.subscribe_time)
  return subscribe_time_;
}
inline void UserInfoResp::set_subscribe_time(::google::protobuf::uint64 value) {
  set_has_subscribe_time();
  subscribe_time_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.subscribe_time)
}

// optional string unionid = 13;
inline bool UserInfoResp::has_unionid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserInfoResp::set_has_unionid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserInfoResp::clear_has_unionid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserInfoResp::clear_unionid() {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_->clear();
  }
  clear_has_unionid();
}
inline const ::std::string& UserInfoResp::unionid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.unionid)
  return *unionid_;
}
inline void UserInfoResp::set_unionid(const ::std::string& value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.unionid)
}
inline void UserInfoResp::set_unionid(const char* value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.unionid)
}
inline void UserInfoResp::set_unionid(const char* value, size_t size) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.unionid)
}
inline ::std::string* UserInfoResp::mutable_unionid() {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.unionid)
  return unionid_;
}
inline ::std::string* UserInfoResp::release_unionid() {
  clear_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unionid_;
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_unionid(::std::string* unionid) {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unionid_;
  }
  if (unionid) {
    set_has_unionid();
    unionid_ = unionid;
  } else {
    clear_has_unionid();
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.unionid)
}

// optional string remark = 14;
inline bool UserInfoResp::has_remark() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserInfoResp::set_has_remark() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserInfoResp::clear_has_remark() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserInfoResp::clear_remark() {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& UserInfoResp::remark() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.remark)
  return *remark_;
}
inline void UserInfoResp::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.remark)
}
inline void UserInfoResp::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoResp.remark)
}
inline void UserInfoResp::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoResp.remark)
}
inline ::std::string* UserInfoResp::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoResp.remark)
  return remark_;
}
inline ::std::string* UserInfoResp::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoResp::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoResp.remark)
}

// optional uint64 groupid = 15;
inline bool UserInfoResp::has_groupid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserInfoResp::set_has_groupid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserInfoResp::clear_has_groupid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserInfoResp::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 UserInfoResp::groupid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.groupid)
  return groupid_;
}
inline void UserInfoResp::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.groupid)
}

// repeated uint64 tagid_list = 16;
inline int UserInfoResp::tagid_list_size() const {
  return tagid_list_.size();
}
inline void UserInfoResp::clear_tagid_list() {
  tagid_list_.Clear();
}
inline ::google::protobuf::uint64 UserInfoResp::tagid_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoResp.tagid_list)
  return tagid_list_.Get(index);
}
inline void UserInfoResp::set_tagid_list(int index, ::google::protobuf::uint64 value) {
  tagid_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoResp.tagid_list)
}
inline void UserInfoResp::add_tagid_list(::google::protobuf::uint64 value) {
  tagid_list_.Add(value);
  // @@protoc_insertion_point(field_add:mpcomm.UserInfoResp.tagid_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UserInfoResp::tagid_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.UserInfoResp.tagid_list)
  return tagid_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UserInfoResp::mutable_tagid_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.UserInfoResp.tagid_list)
  return &tagid_list_;
}

// -------------------------------------------------------------------

// BatchGetUserItem

// optional string openid = 1;
inline bool BatchGetUserItem::has_openid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchGetUserItem::set_has_openid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchGetUserItem::clear_has_openid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchGetUserItem::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& BatchGetUserItem::openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetUserItem.openid)
  return *openid_;
}
inline void BatchGetUserItem::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetUserItem.openid)
}
inline void BatchGetUserItem::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchGetUserItem.openid)
}
inline void BatchGetUserItem::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchGetUserItem.openid)
}
inline ::std::string* BatchGetUserItem::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetUserItem.openid)
  return openid_;
}
inline ::std::string* BatchGetUserItem::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchGetUserItem::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchGetUserItem.openid)
}

// optional string lang = 2;
inline bool BatchGetUserItem::has_lang() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchGetUserItem::set_has_lang() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchGetUserItem::clear_has_lang() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchGetUserItem::clear_lang() {
  if (lang_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_->clear();
  }
  clear_has_lang();
}
inline const ::std::string& BatchGetUserItem::lang() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetUserItem.lang)
  return *lang_;
}
inline void BatchGetUserItem::set_lang(const ::std::string& value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetUserItem.lang)
}
inline void BatchGetUserItem::set_lang(const char* value) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_ = new ::std::string;
  }
  lang_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchGetUserItem.lang)
}
inline void BatchGetUserItem::set_lang(const char* value, size_t size) {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_ = new ::std::string;
  }
  lang_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchGetUserItem.lang)
}
inline ::std::string* BatchGetUserItem::mutable_lang() {
  set_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lang_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetUserItem.lang)
  return lang_;
}
inline ::std::string* BatchGetUserItem::release_lang() {
  clear_has_lang();
  if (lang_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lang_;
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchGetUserItem::set_allocated_lang(::std::string* lang) {
  if (lang_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lang_;
  }
  if (lang) {
    set_has_lang();
    lang_ = lang;
  } else {
    clear_has_lang();
    lang_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchGetUserItem.lang)
}

// -------------------------------------------------------------------

// BatchGetUserInfoReq

// optional string access_token = 1;
inline bool BatchGetUserInfoReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchGetUserInfoReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchGetUserInfoReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchGetUserInfoReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& BatchGetUserInfoReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetUserInfoReq.access_token)
  return *access_token_;
}
inline void BatchGetUserInfoReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetUserInfoReq.access_token)
}
inline void BatchGetUserInfoReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchGetUserInfoReq.access_token)
}
inline void BatchGetUserInfoReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchGetUserInfoReq.access_token)
}
inline ::std::string* BatchGetUserInfoReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetUserInfoReq.access_token)
  return access_token_;
}
inline ::std::string* BatchGetUserInfoReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchGetUserInfoReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchGetUserInfoReq.access_token)
}

// repeated .mpcomm.BatchGetUserItem user_list = 2;
inline int BatchGetUserInfoReq::user_list_size() const {
  return user_list_.size();
}
inline void BatchGetUserInfoReq::clear_user_list() {
  user_list_.Clear();
}
inline const ::mpcomm::BatchGetUserItem& BatchGetUserInfoReq::user_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetUserInfoReq.user_list)
  return user_list_.Get(index);
}
inline ::mpcomm::BatchGetUserItem* BatchGetUserInfoReq::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetUserInfoReq.user_list)
  return user_list_.Mutable(index);
}
inline ::mpcomm::BatchGetUserItem* BatchGetUserInfoReq::add_user_list() {
  // @@protoc_insertion_point(field_add:mpcomm.BatchGetUserInfoReq.user_list)
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::BatchGetUserItem >&
BatchGetUserInfoReq::user_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.BatchGetUserInfoReq.user_list)
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::BatchGetUserItem >*
BatchGetUserInfoReq::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.BatchGetUserInfoReq.user_list)
  return &user_list_;
}

// -------------------------------------------------------------------

// UserInfoItem

// optional uint64 subscribe = 1;
inline bool UserInfoItem::has_subscribe() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoItem::set_has_subscribe() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoItem::clear_has_subscribe() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoItem::clear_subscribe() {
  subscribe_ = GOOGLE_ULONGLONG(0);
  clear_has_subscribe();
}
inline ::google::protobuf::uint64 UserInfoItem::subscribe() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.subscribe)
  return subscribe_;
}
inline void UserInfoItem::set_subscribe(::google::protobuf::uint64 value) {
  set_has_subscribe();
  subscribe_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.subscribe)
}

// optional string openid = 2;
inline bool UserInfoItem::has_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoItem::set_has_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoItem::clear_has_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoItem::clear_openid() {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& UserInfoItem::openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.openid)
  return *openid_;
}
inline void UserInfoItem::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.openid)
}
inline void UserInfoItem::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoItem.openid)
}
inline void UserInfoItem::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoItem.openid)
}
inline ::std::string* UserInfoItem::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoItem.openid)
  return openid_;
}
inline ::std::string* UserInfoItem::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoItem::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoItem.openid)
}

// optional string nickname = 3;
inline bool UserInfoItem::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoItem::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoItem::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoItem::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& UserInfoItem::nickname() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.nickname)
  return *nickname_;
}
inline void UserInfoItem::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.nickname)
}
inline void UserInfoItem::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoItem.nickname)
}
inline void UserInfoItem::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoItem.nickname)
}
inline ::std::string* UserInfoItem::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoItem.nickname)
  return nickname_;
}
inline ::std::string* UserInfoItem::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoItem::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoItem.nickname)
}

// optional uint64 sex = 4;
inline bool UserInfoItem::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoItem::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoItem::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoItem::clear_sex() {
  sex_ = GOOGLE_ULONGLONG(0);
  clear_has_sex();
}
inline ::google::protobuf::uint64 UserInfoItem::sex() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.sex)
  return sex_;
}
inline void UserInfoItem::set_sex(::google::protobuf::uint64 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.sex)
}

// optional string language = 5;
inline bool UserInfoItem::has_language() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfoItem::set_has_language() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfoItem::clear_has_language() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfoItem::clear_language() {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& UserInfoItem::language() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.language)
  return *language_;
}
inline void UserInfoItem::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.language)
}
inline void UserInfoItem::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoItem.language)
}
inline void UserInfoItem::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoItem.language)
}
inline ::std::string* UserInfoItem::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoItem.language)
  return language_;
}
inline ::std::string* UserInfoItem::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoItem::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoItem.language)
}

// optional string city = 6;
inline bool UserInfoItem::has_city() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfoItem::set_has_city() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfoItem::clear_has_city() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfoItem::clear_city() {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& UserInfoItem::city() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.city)
  return *city_;
}
inline void UserInfoItem::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.city)
}
inline void UserInfoItem::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoItem.city)
}
inline void UserInfoItem::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoItem.city)
}
inline ::std::string* UserInfoItem::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoItem.city)
  return city_;
}
inline ::std::string* UserInfoItem::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoItem::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoItem.city)
}

// optional string province = 7;
inline bool UserInfoItem::has_province() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfoItem::set_has_province() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfoItem::clear_has_province() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfoItem::clear_province() {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& UserInfoItem::province() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.province)
  return *province_;
}
inline void UserInfoItem::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.province)
}
inline void UserInfoItem::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoItem.province)
}
inline void UserInfoItem::set_province(const char* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoItem.province)
}
inline ::std::string* UserInfoItem::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoItem.province)
  return province_;
}
inline ::std::string* UserInfoItem::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoItem::set_allocated_province(::std::string* province) {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete province_;
  }
  if (province) {
    set_has_province();
    province_ = province;
  } else {
    clear_has_province();
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoItem.province)
}

// optional string country = 8;
inline bool UserInfoItem::has_country() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfoItem::set_has_country() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfoItem::clear_has_country() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfoItem::clear_country() {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& UserInfoItem::country() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.country)
  return *country_;
}
inline void UserInfoItem::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.country)
}
inline void UserInfoItem::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoItem.country)
}
inline void UserInfoItem::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoItem.country)
}
inline ::std::string* UserInfoItem::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoItem.country)
  return country_;
}
inline ::std::string* UserInfoItem::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoItem::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoItem.country)
}

// optional string headimgurl = 9;
inline bool UserInfoItem::has_headimgurl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfoItem::set_has_headimgurl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfoItem::clear_has_headimgurl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfoItem::clear_headimgurl() {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_->clear();
  }
  clear_has_headimgurl();
}
inline const ::std::string& UserInfoItem::headimgurl() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.headimgurl)
  return *headimgurl_;
}
inline void UserInfoItem::set_headimgurl(const ::std::string& value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.headimgurl)
}
inline void UserInfoItem::set_headimgurl(const char* value) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoItem.headimgurl)
}
inline void UserInfoItem::set_headimgurl(const char* value, size_t size) {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  headimgurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoItem.headimgurl)
}
inline ::std::string* UserInfoItem::mutable_headimgurl() {
  set_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    headimgurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoItem.headimgurl)
  return headimgurl_;
}
inline ::std::string* UserInfoItem::release_headimgurl() {
  clear_has_headimgurl();
  if (headimgurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = headimgurl_;
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoItem::set_allocated_headimgurl(::std::string* headimgurl) {
  if (headimgurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete headimgurl_;
  }
  if (headimgurl) {
    set_has_headimgurl();
    headimgurl_ = headimgurl;
  } else {
    clear_has_headimgurl();
    headimgurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoItem.headimgurl)
}

// optional uint64 subscribe_time = 10;
inline bool UserInfoItem::has_subscribe_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfoItem::set_has_subscribe_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfoItem::clear_has_subscribe_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfoItem::clear_subscribe_time() {
  subscribe_time_ = GOOGLE_ULONGLONG(0);
  clear_has_subscribe_time();
}
inline ::google::protobuf::uint64 UserInfoItem::subscribe_time() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.subscribe_time)
  return subscribe_time_;
}
inline void UserInfoItem::set_subscribe_time(::google::protobuf::uint64 value) {
  set_has_subscribe_time();
  subscribe_time_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.subscribe_time)
}

// optional string unionid = 11;
inline bool UserInfoItem::has_unionid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfoItem::set_has_unionid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfoItem::clear_has_unionid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfoItem::clear_unionid() {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_->clear();
  }
  clear_has_unionid();
}
inline const ::std::string& UserInfoItem::unionid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.unionid)
  return *unionid_;
}
inline void UserInfoItem::set_unionid(const ::std::string& value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.unionid)
}
inline void UserInfoItem::set_unionid(const char* value) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoItem.unionid)
}
inline void UserInfoItem::set_unionid(const char* value, size_t size) {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  unionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoItem.unionid)
}
inline ::std::string* UserInfoItem::mutable_unionid() {
  set_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoItem.unionid)
  return unionid_;
}
inline ::std::string* UserInfoItem::release_unionid() {
  clear_has_unionid();
  if (unionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unionid_;
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoItem::set_allocated_unionid(::std::string* unionid) {
  if (unionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unionid_;
  }
  if (unionid) {
    set_has_unionid();
    unionid_ = unionid;
  } else {
    clear_has_unionid();
    unionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoItem.unionid)
}

// optional string remark = 12;
inline bool UserInfoItem::has_remark() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfoItem::set_has_remark() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfoItem::clear_has_remark() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfoItem::clear_remark() {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& UserInfoItem::remark() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.remark)
  return *remark_;
}
inline void UserInfoItem::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.remark)
}
inline void UserInfoItem::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserInfoItem.remark)
}
inline void UserInfoItem::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserInfoItem.remark)
}
inline ::std::string* UserInfoItem::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.UserInfoItem.remark)
  return remark_;
}
inline ::std::string* UserInfoItem::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfoItem::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.UserInfoItem.remark)
}

// optional uint64 groupid = 13;
inline bool UserInfoItem::has_groupid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserInfoItem::set_has_groupid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserInfoItem::clear_has_groupid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserInfoItem::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 UserInfoItem::groupid() const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.groupid)
  return groupid_;
}
inline void UserInfoItem::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.groupid)
}

// repeated uint64 tagid_list = 14;
inline int UserInfoItem::tagid_list_size() const {
  return tagid_list_.size();
}
inline void UserInfoItem::clear_tagid_list() {
  tagid_list_.Clear();
}
inline ::google::protobuf::uint64 UserInfoItem::tagid_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.UserInfoItem.tagid_list)
  return tagid_list_.Get(index);
}
inline void UserInfoItem::set_tagid_list(int index, ::google::protobuf::uint64 value) {
  tagid_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:mpcomm.UserInfoItem.tagid_list)
}
inline void UserInfoItem::add_tagid_list(::google::protobuf::uint64 value) {
  tagid_list_.Add(value);
  // @@protoc_insertion_point(field_add:mpcomm.UserInfoItem.tagid_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UserInfoItem::tagid_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.UserInfoItem.tagid_list)
  return tagid_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UserInfoItem::mutable_tagid_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.UserInfoItem.tagid_list)
  return &tagid_list_;
}

// -------------------------------------------------------------------

// BatchGetUserInfoResp

// optional int64 errcode = 1;
inline bool BatchGetUserInfoResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchGetUserInfoResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchGetUserInfoResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchGetUserInfoResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 BatchGetUserInfoResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetUserInfoResp.errcode)
  return errcode_;
}
inline void BatchGetUserInfoResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetUserInfoResp.errcode)
}

// optional string errmsg = 2;
inline bool BatchGetUserInfoResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchGetUserInfoResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchGetUserInfoResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchGetUserInfoResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& BatchGetUserInfoResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetUserInfoResp.errmsg)
  return *errmsg_;
}
inline void BatchGetUserInfoResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.BatchGetUserInfoResp.errmsg)
}
inline void BatchGetUserInfoResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.BatchGetUserInfoResp.errmsg)
}
inline void BatchGetUserInfoResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.BatchGetUserInfoResp.errmsg)
}
inline ::std::string* BatchGetUserInfoResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetUserInfoResp.errmsg)
  return errmsg_;
}
inline ::std::string* BatchGetUserInfoResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BatchGetUserInfoResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.BatchGetUserInfoResp.errmsg)
}

// repeated .mpcomm.UserInfoItem user_info_list = 3;
inline int BatchGetUserInfoResp::user_info_list_size() const {
  return user_info_list_.size();
}
inline void BatchGetUserInfoResp::clear_user_info_list() {
  user_info_list_.Clear();
}
inline const ::mpcomm::UserInfoItem& BatchGetUserInfoResp::user_info_list(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.BatchGetUserInfoResp.user_info_list)
  return user_info_list_.Get(index);
}
inline ::mpcomm::UserInfoItem* BatchGetUserInfoResp::mutable_user_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.BatchGetUserInfoResp.user_info_list)
  return user_info_list_.Mutable(index);
}
inline ::mpcomm::UserInfoItem* BatchGetUserInfoResp::add_user_info_list() {
  // @@protoc_insertion_point(field_add:mpcomm.BatchGetUserInfoResp.user_info_list)
  return user_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mpcomm::UserInfoItem >&
BatchGetUserInfoResp::user_info_list() const {
  // @@protoc_insertion_point(field_list:mpcomm.BatchGetUserInfoResp.user_info_list)
  return user_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::mpcomm::UserInfoItem >*
BatchGetUserInfoResp::mutable_user_info_list() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.BatchGetUserInfoResp.user_info_list)
  return &user_info_list_;
}

// -------------------------------------------------------------------

// GetUserReq

// optional string access_token = 1;
inline bool GetUserReq::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserReq::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserReq::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserReq::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& GetUserReq::access_token() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetUserReq.access_token)
  return *access_token_;
}
inline void GetUserReq::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetUserReq.access_token)
}
inline void GetUserReq::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetUserReq.access_token)
}
inline void GetUserReq::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetUserReq.access_token)
}
inline ::std::string* GetUserReq::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    access_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetUserReq.access_token)
  return access_token_;
}
inline ::std::string* GetUserReq::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetUserReq::set_allocated_access_token(::std::string* access_token) {
  if (access_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete access_token_;
  }
  if (access_token) {
    set_has_access_token();
    access_token_ = access_token;
  } else {
    clear_has_access_token();
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetUserReq.access_token)
}

// optional string next_openid = 2;
inline bool GetUserReq::has_next_openid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserReq::set_has_next_openid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserReq::clear_has_next_openid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserReq::clear_next_openid() {
  if (next_openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_->clear();
  }
  clear_has_next_openid();
}
inline const ::std::string& GetUserReq::next_openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetUserReq.next_openid)
  return *next_openid_;
}
inline void GetUserReq::set_next_openid(const ::std::string& value) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetUserReq.next_openid)
}
inline void GetUserReq::set_next_openid(const char* value) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetUserReq.next_openid)
}
inline void GetUserReq::set_next_openid(const char* value, size_t size) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetUserReq.next_openid)
}
inline ::std::string* GetUserReq::mutable_next_openid() {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetUserReq.next_openid)
  return next_openid_;
}
inline ::std::string* GetUserReq::release_next_openid() {
  clear_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = next_openid_;
    next_openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetUserReq::set_allocated_next_openid(::std::string* next_openid) {
  if (next_openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete next_openid_;
  }
  if (next_openid) {
    set_has_next_openid();
    next_openid_ = next_openid;
  } else {
    clear_has_next_openid();
    next_openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetUserReq.next_openid)
}

// -------------------------------------------------------------------

// UserList

// repeated string openid = 1;
inline int UserList::openid_size() const {
  return openid_.size();
}
inline void UserList::clear_openid() {
  openid_.Clear();
}
inline const ::std::string& UserList::openid(int index) const {
  // @@protoc_insertion_point(field_get:mpcomm.UserList.openid)
  return openid_.Get(index);
}
inline ::std::string* UserList::mutable_openid(int index) {
  // @@protoc_insertion_point(field_mutable:mpcomm.UserList.openid)
  return openid_.Mutable(index);
}
inline void UserList::set_openid(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mpcomm.UserList.openid)
  openid_.Mutable(index)->assign(value);
}
inline void UserList::set_openid(int index, const char* value) {
  openid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.UserList.openid)
}
inline void UserList::set_openid(int index, const char* value, size_t size) {
  openid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.UserList.openid)
}
inline ::std::string* UserList::add_openid() {
  return openid_.Add();
}
inline void UserList::add_openid(const ::std::string& value) {
  openid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mpcomm.UserList.openid)
}
inline void UserList::add_openid(const char* value) {
  openid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mpcomm.UserList.openid)
}
inline void UserList::add_openid(const char* value, size_t size) {
  openid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mpcomm.UserList.openid)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserList::openid() const {
  // @@protoc_insertion_point(field_list:mpcomm.UserList.openid)
  return openid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserList::mutable_openid() {
  // @@protoc_insertion_point(field_mutable_list:mpcomm.UserList.openid)
  return &openid_;
}

// -------------------------------------------------------------------

// GetUserResp

// optional int64 errcode = 1;
inline bool GetUserResp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserResp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserResp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserResp::clear_errcode() {
  errcode_ = GOOGLE_LONGLONG(0);
  clear_has_errcode();
}
inline ::google::protobuf::int64 GetUserResp::errcode() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetUserResp.errcode)
  return errcode_;
}
inline void GetUserResp::set_errcode(::google::protobuf::int64 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetUserResp.errcode)
}

// optional string errmsg = 2;
inline bool GetUserResp::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserResp::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserResp::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserResp::clear_errmsg() {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_->clear();
  }
  clear_has_errmsg();
}
inline const ::std::string& GetUserResp::errmsg() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetUserResp.errmsg)
  return *errmsg_;
}
inline void GetUserResp::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetUserResp.errmsg)
}
inline void GetUserResp::set_errmsg(const char* value) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetUserResp.errmsg)
}
inline void GetUserResp::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  errmsg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetUserResp.errmsg)
}
inline ::std::string* GetUserResp::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    errmsg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetUserResp.errmsg)
  return errmsg_;
}
inline ::std::string* GetUserResp::release_errmsg() {
  clear_has_errmsg();
  if (errmsg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = errmsg_;
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetUserResp::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete errmsg_;
  }
  if (errmsg) {
    set_has_errmsg();
    errmsg_ = errmsg;
  } else {
    clear_has_errmsg();
    errmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetUserResp.errmsg)
}

// optional uint64 total = 3;
inline bool GetUserResp::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserResp::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserResp::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserResp::clear_total() {
  total_ = GOOGLE_ULONGLONG(0);
  clear_has_total();
}
inline ::google::protobuf::uint64 GetUserResp::total() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetUserResp.total)
  return total_;
}
inline void GetUserResp::set_total(::google::protobuf::uint64 value) {
  set_has_total();
  total_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetUserResp.total)
}

// optional uint64 count = 4;
inline bool GetUserResp::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUserResp::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetUserResp::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetUserResp::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::uint64 GetUserResp::count() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetUserResp.count)
  return count_;
}
inline void GetUserResp::set_count(::google::protobuf::uint64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:mpcomm.GetUserResp.count)
}

// optional .mpcomm.UserList data = 5;
inline bool GetUserResp::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetUserResp::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetUserResp::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetUserResp::clear_data() {
  if (data_ != NULL) data_->::mpcomm::UserList::Clear();
  clear_has_data();
}
inline const ::mpcomm::UserList& GetUserResp::data() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetUserResp.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::mpcomm::UserList* GetUserResp::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::mpcomm::UserList;
  // @@protoc_insertion_point(field_mutable:mpcomm.GetUserResp.data)
  return data_;
}
inline ::mpcomm::UserList* GetUserResp::release_data() {
  clear_has_data();
  ::mpcomm::UserList* temp = data_;
  data_ = NULL;
  return temp;
}
inline void GetUserResp::set_allocated_data(::mpcomm::UserList* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetUserResp.data)
}

// optional string next_openid = 6;
inline bool GetUserResp::has_next_openid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetUserResp::set_has_next_openid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetUserResp::clear_has_next_openid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetUserResp::clear_next_openid() {
  if (next_openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_->clear();
  }
  clear_has_next_openid();
}
inline const ::std::string& GetUserResp::next_openid() const {
  // @@protoc_insertion_point(field_get:mpcomm.GetUserResp.next_openid)
  return *next_openid_;
}
inline void GetUserResp::set_next_openid(const ::std::string& value) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(value);
  // @@protoc_insertion_point(field_set:mpcomm.GetUserResp.next_openid)
}
inline void GetUserResp::set_next_openid(const char* value) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(value);
  // @@protoc_insertion_point(field_set_char:mpcomm.GetUserResp.next_openid)
}
inline void GetUserResp::set_next_openid(const char* value, size_t size) {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  next_openid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mpcomm.GetUserResp.next_openid)
}
inline ::std::string* GetUserResp::mutable_next_openid() {
  set_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    next_openid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mpcomm.GetUserResp.next_openid)
  return next_openid_;
}
inline ::std::string* GetUserResp::release_next_openid() {
  clear_has_next_openid();
  if (next_openid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = next_openid_;
    next_openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetUserResp::set_allocated_next_openid(::std::string* next_openid) {
  if (next_openid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete next_openid_;
  }
  if (next_openid) {
    set_has_next_openid();
    next_openid_ = next_openid;
  } else {
    clear_has_next_openid();
    next_openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mpcomm.GetUserResp.next_openid)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mpcomm

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mpmsg_2eproto__INCLUDED
